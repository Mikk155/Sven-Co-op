{
	"namespace SurvivalEndRoundHook":
	{
		"prefix":[ "Hooks::Game::SurvivalEndRoundHook", "SurvivalEndRoundHook" ],
		"body": "Hooks::Game::SurvivalEndRoundHook",
		"description": "Called once when a survival mode round ends at the moment there is no more alive players."
	},
	"funcdef HookReturnCode SurvivalEndRoundHook();":
	{
		"prefix":[ "SurvivalEndRoundHook" ],
		"body": "HookReturnCode SurvivalEndRoundHook()",
		"description": "Called once when a survival mode round ends at the moment there is no more alive players."
	},
	"namespace PlayerJumpHook":
	{
		"prefix":[ "Hooks::Player::PlayerJumpHook", "PlayerJumpHook" ],
		"body": "Hooks::Player::PlayerJumpHook",
		"description": "Called when a player jumps"
	},
	"funcdef HookReturnCode PlayerJumpHook( CBasePlayer@ );":
	{
		"prefix":[ "PlayerJumpHook" ],
		"body": "HookReturnCode PlayerJumpHook( ${1:CBasePlayer@})",
		"description": "Called when a player jumps"
	},
	"namespace PlayerKeyInputHook":
	{
		"prefix":[ "Hooks::Player::PlayerKeyInputHook", "PlayerKeyInputHook" ],
		"body": "Hooks::Player::PlayerKeyInputHook",
		"description": "Called when a player pev->buttons changes"
	},
	"funcdef HookReturnCode PlayerKeyInputHook( CBasePlayer@, In_Buttons, const bool );":
	{
		"prefix":[ "PlayerKeyInputHook" ],
		"body": "HookReturnCode PlayerKeyInputHook( ${1:CBasePlayer@}, ${2:In_Buttons}, ${3:const bool})",
		"description": "Called when a player pev->buttons changes. the given bool returns whatever the button has been released or pressed"
	},
	"namespace PlayerObserverModeHook":
	{
		"prefix":[ "Hooks::Player::PlayerObserverModeHook", "PlayerObserverModeHook" ],
		"body": "Hooks::Player::PlayerObserverModeHook",
		"description": "Called when a player change its spectator mode"
	},
	"funcdef HookReturnCode PlayerObserverModeHook( CBasePlayer@, ObserverMode );":
	{
		"prefix":[ "PlayerObserverModeHook" ],
		"body": "HookReturnCode PlayerObserverModeHook( ${1:CBasePlayer@}, ${2:ObserverMode})",
		"description": "Called when a player change its spectator mode."
	},
	"string to_string( RGBA From, bool AddColons = false, bool AddSpace = true )":
	{
		"prefix":[ "fft::to_string", "to_string", "RGBA", "format" ],
		"body": "fft::.to_string( ${1:RGBA From}, ${2:bool AddColons = false}, ${3:bool AddSpace = true})",
		"description": "Format the given RGBA to string. If AddColons is true add colons. If AddSpace is false then do not add white spaces."
	},
	"string to_string( bool From, bool MakeDigit = false )":
	{
		"prefix":[ "fft::to_string", "to_string", "bool", "format" ],
		"body": "fft::.to_string( ${1:bool From}, ${2:bool MakeDigit = false})",
		"description": "Format the given bool to string, if MakeDigit is true then false = 0, true = 1"
	},
	"string to_string( Vector From, bool AddColons = false, bool AddSpace = true )":
	{
		"prefix":[ "fft::to_string", "to_string", "Vector", "format" ],
		"body": "fft::.to_string( ${1:Vector From}, ${2:bool AddColons = false}, ${3:bool AddSpace = true})",
		"description": "Format the given Vector to string. If AddColons is true add colons. If AddSpace is false then do not add white spaces."
	},
	"string to_string( Vector2D From, bool AddColons = false, bool AddSpace = true )":
	{
		"prefix":[ "fft::to_string", "to_string", "Vector2D", "format" ],
		"body": "fft::.to_string( ${1:Vector2D From}, ${2:bool AddColons = false}, ${3:bool AddSpace = true})",
		"description": "Format the given Vector2D to string. If AddColons is true add colons. If AddSpace is false then do not add white spaces."
	},
	"RGBA HueToRGBA( float H )":
	{
		"prefix":[ "fft::HueToRGBA", "fft::Hue", "fft::RGBA", "Hue", "format" ],
		"body": "fft::.HueToRGBA( ${1:float H})",
		"description": "Format the given hue float value to RGBA (.a will most likely be empty)"
	},
	"float RGBAToHue( RGBA rgb ){ return ToHue( Vector( rgb.r, rgb.g, rgb.b ) ); }":
	{
		"prefix":[ "fft::ToHue", "fft::Hue", "fft::RGBAToHue", "RGBAToHue", "Hue", "format" ],
		"body": "fft::.RGBAToHue( ${1:RGBA rgb})",
		"description": "Format the given RGBA to hue value in a float form"
	},
	"float ToHue( Vector rgb )":
	{
		"prefix":[ "fft::ToHue", "fft::Hue", "Hue", "format" ],
		"body": "fft::.ToHue( ${1:Vector rgb})",
		"description": "Format the given Vector to hue value in a float form"
	},
	"RGBA atorgba( const string From )":
	{
		"prefix":[ "atorgba" ],
		"body": "atorgba( ${1:const string From})",
		"description": "Return the given string as a 4D RGBA"
	},
	"Vector atov( const string From )":
	{
		"prefix":[ "atov", "StringToVecto" ],
		"body": "atov( ${1:const string From})",
		"description": "Return the given string as a 3D Vector"
	},
	"bool atob( const string From )":
	{
		"prefix":[ "atobool", "stringtobool" ],
		"body": "atob( ${1:const string From})",
		"description": "Return the given string as a boolean, 0/1 or false/true"
	},
	"string opIndex( uint index )":
	{
		"prefix":[ "JsonValue", "opInd" ],
		"body": "opIndex( ${1:uint index})",
		"description": "Return the given value on the array of this json if any, else returns empty string"
	},
	"bool exists( string &in key, bool CheckValue = false )":
	{
		"prefix":[ "json", "exists" ],
		"body": "exists( ${1:string &in key}, ${2:bool CheckValue = false})",
		"description": "Return whatever the given key exists, if vlvalue is true it will check for both to exist"
	},
	"uint size()":
	{
		"prefix":[ "json", "siz" ],
		"body": "size()",
		"description": "Return the whole size of this json data"
	},
	"uint length()":
	{
		"prefix":[ "json", "length" ],
		"body": "length()",
		"description": "Return the length of this json data"
	},
	"JsonValue opIndex( string key )":
	{
		"prefix":[ "json", "opInd" ],
		"body": "opIndex( ${1:string key})",
		"description": "Return the JsonValue of the given key"
	},
	"string Instance( string key, bool ToString = false ){ return get( key ).Instance( ToString ); }":
	{
		"prefix":[ "json", "Instanc" ],
		"body": "Instance( ${1:string key}, ${2:bool ToString = false})",
		"description": "Return the instance name on enum JsonValueType, if ToString is true return as a string"
	},
	"":
	{
		"prefix":[ "" ],
		"body": "",
		"description": ""
	},
	"uint reload( string m_szLoad, bool include = false )":
	{
		"prefix":[ "load", "json", "pars" ],
		"body": "reload( ${1:string m_szLoad}, ${2:bool include = false})",
		"description": "Aliases to \"load\" but will return 1 if this json doesn't has a key \"reload\" on true"
	},
	"uint load( string m_szLoad, bool include = false )":
	{
		"prefix":[ "load", "json", "pars" ],
		"body": "load( ${1:string m_szLoad}, ${2:bool include = false})",
		"description": "Loads a json file within a json class. if no format '.json' is provided it asumes you sent a string with json format if include is true the json is not cleared and new data will be written above, When specifying format, folder maps/plugins is necesary to include in the path. Return codes: 0 = everything fine 1 = empty string sent 2 = file not found"
	},
	"enum MKLANG::CHAT":
	{
		"prefix": [ "CHAT", "MKLANG::CHAT" ],
		"body": "MKLANG::CHAT",
		"description": "ClientPrint -> HUD_PRINTTALK",
	},
	"enum MKLANG::BIND":
	{
		"prefix": [ "BIND", "MKLANG::BIND" ],
		"body": "MKLANG::BIND",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString",
	},
	"enum MKLANG::CENTER":
	{
		"prefix": [ "CENTER", "MKLANG::CENTER" ],
		"body": "MKLANG::CENTER",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER",
	},
	"enum MKLANG::HUDMSG":
	{
		"prefix": [ "HUDMSG", "MKLANG::HUDMSG" ],
		"body": "MKLANG::HUDMSG",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER HudMessage Pass arguments in the json file. x = -1, y = -1, effect = 1, color = 255 255 255, color2 = 255 255 255, fadein = 0, fadeout = 1, hold = 1, fxtime = 1, channel = 8",
	},
	"enum MKLANG::NOTIFY":
	{
		"prefix": [ "NOTIFY", "MKLANG::NOTIFY" ],
		"body": "MKLANG::NOTIFY",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER HudMessage Pass arguments in the json file. x = -1, y = -1, effect = 1, color = 255 255 255, color2 = 255 255 255, fadein = 0, fadeout = 1, hold = 1, fxtime = 1, channel = 8 ClientPrint -> HUD_PRINTNOTIFY",
	},
	"enum MKLANG::CONSOLE":
	{
		"prefix": [ "CONSOLE", "MKLANG::CONSOLE" ],
		"body": "MKLANG::CONSOLE",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER HudMessage Pass arguments in the json file. x = -1, y = -1, effect = 1, color = 255 255 255, color2 = 255 255 255, fadein = 0, fadeout = 1, hold = 1, fxtime = 1, channel = 8 ClientPrint -> HUD_PRINTNOTIFY ClientPrint -> HUD_PRINTCONSOLE",
	},
	"string GetLanguage( CBasePlayer@ pPlayer, json@ pJson, dictionary@ pReplacement = null )":
	{
		"prefix":[ "Mikk.Language.GetLanguage", "GetLanguag" ],
		"body": "Mikk.Language.GetLanguage( ${1:CBasePlayer@ pPlayer}, ${2:json@ pJson}, ${3:dictionary@ pReplacement = null})",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER HudMessage Pass arguments in the json file. x = -1, y = -1, effect = 1, color = 255 255 255, color2 = 255 255 255, fadein = 0, fadeout = 1, hold = 1, fxtime = 1, channel = 8 ClientPrint -> HUD_PRINTNOTIFY ClientPrint -> HUD_PRINTCONSOLE Gets a language string from the given json value, pReplacement keys will be replaced with their values. note in the json string it have to be enclosed with two $"
	},
	"void PrintAll( json@ pJson, MKLANG PrintType = CHAT, dictionary@ pReplacement = null )":
	{
		"prefix":[ "Mikk.Language.PrintAll", "PrintAll", "Languag" ],
		"body": "Mikk.Language.PrintAll( ${1:json@ pJson}, ${2:MKLANG PrintType = CHAT}, ${3:dictionary@ pReplacement = null})",
		"description": "Prints a language string from the given json value, PrintType is the message type. see the enum pReplacement keys will be replaced with their values. note in the json string it have to be enclosed with two $"
	},
	"void Print( CBasePlayer@ pPlayer, json@ pJson, MKLANG PrintType = CHAT, dictionary@ pReplacement = null )":
	{
		"prefix":[ "Mikk.Language.PrintAll", "PrintAll", "Languag" ],
		"body": "Mikk.Language.Print( ${1:CBasePlayer@ pPlayer}, ${2:json@ pJson}, ${3:MKLANG PrintType = CHAT}, ${4:dictionary@ pReplacement = null})",
		"description": "Prints a language string from the given json value, PrintType is the message type. see the enum pReplacement keys will be replaced with their values. note in the json string it have to be enclosed with two $"
	},
	"void GetColormap( CBasePlayer@ pPlayer, RGBA &out TopRGB, RGBA &out BotRGB )":
	{
		"prefix":[ "Mikk.PlayerFuncs.GetColormap", "GetColormap", "colormap", "bottomcolor", "topcolor", "Hu" ],
		"body": "Mikk.PlayerFuncs.GetColormap( ${1:CBasePlayer@ pPlayer}, ${2:RGBA &out TopRGB}, ${3:RGBA &out BotRGB})",
		"description": "Gets bottomcolor and topcolor from the given player as a RGBA values"
	},
	"void ClientCommand( string_t m_iszCommand, CBasePlayer@ pPlayer, bool bAllPlayers = false )":
	{
		"prefix":[ "Mikk.PlayerFuncs.ClientCommand", "ClientCommand", "Command" ],
		"body": "Mikk.PlayerFuncs.ClientCommand( ${1:string_t m_iszCommand}, ${2:CBasePlayer@ pPlayer}, ${3:bool bAllPlayers = false})",
		"description": "Executes a console command on the given player or all players if bAllPlayers is true"
	},
	"CBasePlayer@ FindPlayerBySteamID( const string &in m_iszSteamID )":
	{
		"prefix":[ "Mikk.PlayerFuncs.FindPlayerBySteamID", "FindPlayerBySteamID", "SteamID" ],
		"body": "Mikk.PlayerFuncs.FindPlayerBySteamID( ${1:const string &in m_iszSteamID})",
		"description": "Get the CBasePlayer@ instance of the given SteamID"
	},
	"string GetSteamID( CBasePlayer@ pPlayer )":
	{
		"prefix":[ "Mikk.PlayerFuncs.GetSteamID", "GetSteamID", "SteamID" ],
		"body": "Mikk.PlayerFuncs.GetSteamID( ${1:CBasePlayer@ pPlayer})",
		"description": "Return the SteamID of the given player, BOTS will be enumerated by their index"
	},
	"bool RespawnPlayer( CBasePlayer@ pPlayer )":
	{
		"prefix":[ "Mikk.PlayerFuncs.RespawnPlayer", "RespawnPlay" ],
		"body": "Mikk.PlayerFuncs.RespawnPlayer( ${1:CBasePlayer@ pPlayer})",
		"description": "Revives the given player and then relocates him to a valid spawnpoint, returns true if revived"
	},
	"void PlayerSay( CBaseEntity@ pPlayer, string m_szMessage, CBasePlayer@ pTarget = null )":
	{
		"prefix":[ "Mikk.PlayerFuncs.PlayerSay", "chat", "say" ],
		"body": "Mikk.PlayerFuncs.PlayerSay( ${1:CBaseEntity@ pPlayer}, ${2:string m_szMessage}, ${3:CBasePlayer@ pTarget = null})",
		"description": "Make a player say something, if pTarget is not null, only pTarget will see the message."
	},
	"CBaseEntity@ CreateEntity( dictionary g_Data, bool blSpawnNow = true )":
	{
		"prefix":[ "Mikk.EntityFuncs.CreateEntity", "CreateEntity", "EntityCreat" ],
		"body": "Mikk.EntityFuncs.CreateEntity( ${1:dictionary g_Data}, ${2:bool blSpawnNow = true})",
		"description": "Creates a entity with the given keyvalue data, if blSpawnNow is false the entity is not spawned"
	},
	"bool LoadEntFile( const string &in m_szPath )":
	{
		"prefix":[ "Mikk.EntityFuncs.LoadEntFile", "LoadEntFil" ],
		"body": "Mikk.EntityFuncs.LoadEntFile( ${1:const string &in m_szPath})",
		"description": "Loads an external .ent file into the map"
	},
	"int Call( const string m_iszFunction )":
	{
		"prefix":[ "g_Reflection.Call", "g_Reflection.CallFunction", "CallFunction", "Reflection" ],
		"body": "g_Reflection.Call( ${1:const string m_iszFunction})",
		"description": "Calls a function globaly in all namespaces. Returns the number of functions called."
	},
	"Reflection::Function@ opIndex( string m_iszFunction )":
	{
		"prefix":[ "g_Reflection.opIndex", "g_Reflection.Get", "g_Reflection.Function", "Reflection" ],
		"body": "g_Reflection.opIndex( ${1:string m_iszFunction})",
		"description": "Get a script function by name or namespace::name"
	},
	"string GetDiscord()":
	{
		"prefix":[ "Mikk.GetDiscord", "Discord" ],
		"body": "Mikk.GetDiscord()",
		"description": "Get discord server invite"
	},
	"string GetContactInfo()":
	{
		"prefix":[ "Mikk.GetContactInfo", "Contact" ],
		"body": "Mikk.GetContactInfo()",
		"description": "Get contact info"
	},
	"void UpdateTimer( CScheduledFunction@ &out pTimer, string &in szFunction, float flTime, int iRepeat = 0 )":
	{
		"prefix":[ "Mikk.UpdateTimer", "UpdateTim" ],
		"body": "Mikk.UpdateTimer( ${1:CScheduledFunction@ &out pTimer}, ${2:string &in szFunction}, ${3:float flTime}, ${4:int iRepeat = 0})",
		"description": "Clears and sets a CScheduledFunction@ function with the given parameters"
	},
	"bool IsPluginInstalled( string m_iszPluginName, bool bCaseSensitive = false )":
	{
		"prefix":[ "Mikk.IsPluginInstalled", "IsPluginInstalled", "Plugin", "Installed", "IsInstalled" ],
		"body": "Mikk.IsPluginInstalled( ${1:string m_iszPluginName}, ${2:bool bCaseSensitive = false})",
		"description": "Return whatever the given plugin name is installed on the server."
	},
	"string CustomKeyValue( CBaseEntity@ pEntity, const string&in m_iszKey, const string&in m_iszValue = String::EMPTY_STRING )":
	{
		"prefix":[ "CKV", "CustomKeyValu" ],
		"body": "CustomKeyValue( ${1:CBaseEntity@ pEntity}, ${2:const string&in m_iszKey}, ${3:const string&in m_iszValue = String::EMPTY_STRING})",
		"description": "Return the value of the given CustomKeyValue, if m_iszValue is given it will update the value, return String::INVALID_INDEX if the given entity is null, return String::EMPTY_STRING if the given entity doesn't have the custom key value"
	}
}
