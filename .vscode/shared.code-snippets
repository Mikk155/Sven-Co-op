{
	"namespace SurvivalEndRoundHook":
	{
		"prefix":[ "Hooks::Game::SurvivalEndRoundHook", "SurvivalEndRoundHook" ],
		"body": "Hooks::Game::SurvivalEndRoundHook",
		"description": "Called once when a survival mode round ends at the moment there is no more alive players."
	},
	"funcdef HookReturnCode SurvivalEndRoundHook();":
	{
		"prefix":[ "SurvivalEndRoundHook" ],
		"body": "HookReturnCode SurvivalEndRoundHook()",
		"description": "Called once when a survival mode round ends at the moment there is no more alive players."
	},
	"namespace PlayerJumpHook":
	{
		"prefix":[ "Hooks::Player::PlayerJumpHook", "PlayerJumpHook" ],
		"body": "Hooks::Player::PlayerJumpHook",
		"description": "Called when a player jumps"
	},
	"funcdef HookReturnCode PlayerJumpHook( CBasePlayer@ );":
	{
		"prefix":[ "PlayerJumpHook" ],
		"body": "HookReturnCode PlayerJumpHook( ${1:CBasePlayer@})",
		"description": "Called when a player jumps"
	},
	"namespace PlayerKeyInputHook":
	{
		"prefix":[ "Hooks::Player::PlayerKeyInputHook", "PlayerKeyInputHook" ],
		"body": "Hooks::Player::PlayerKeyInputHook",
		"description": "Called when a player pev->buttons changes"
	},
	"funcdef HookReturnCode PlayerKeyInputHook( CBasePlayer@, In_Buttons, const bool );":
	{
		"prefix":[ "PlayerKeyInputHook" ],
		"body": "HookReturnCode PlayerKeyInputHook( ${1:CBasePlayer@}, ${2:In_Buttons}, ${3:const bool})",
		"description": "Called when a player pev->buttons changes. the given bool returns whatever the button has been released or pressed"
	},
	"namespace PlayerObserverModeHook":
	{
		"prefix":[ "Hooks::Player::PlayerObserverModeHook", "PlayerObserverModeHook" ],
		"body": "Hooks::Player::PlayerObserverModeHook",
		"description": "Called when a player change its spectator mode"
	},
	"funcdef HookReturnCode PlayerObserverModeHook( CBasePlayer@, ObserverMode );":
	{
		"prefix":[ "PlayerObserverModeHook" ],
		"body": "HookReturnCode PlayerObserverModeHook( ${1:CBasePlayer@}, ${2:ObserverMode})",
		"description": "Called when a player change its spectator mode."
	},
	"string opIndex( uint index )":
	{
		"prefix":[ "JsonValue", "opInd" ],
		"body": "opIndex( ${1:uint index})",
		"description": "Return the given value on the array of this json if any, else returns empty string"
	},
	"string opIndex( uint index )":
	{
		"prefix":[ "json", "exists" ],
		"body": "opIndex( ${1:uint index})",
		"description": "Return the value of the given index"
	},
	"bool exists( string &in key, bool CheckValue = false )":
	{
		"prefix":[ "json", "exists" ],
		"body": "exists( ${1:string &in key}, ${2:bool CheckValue = false})",
		"description": "Return whatever the given key exists, if vlvalue is true it will check for both to exist"
	},
	"uint size()":
	{
		"prefix":[ "json", "siz" ],
		"body": "size()",
		"description": "Return the whole size of this json data"
	},
	"uint length()":
	{
		"prefix":[ "json", "length" ],
		"body": "length()",
		"description": "Return the length of this json data"
	},
	"JsonValue opIndex( string key )":
	{
		"prefix":[ "json", "opInd" ],
		"body": "opIndex( ${1:string key})",
		"description": "Return the JsonValue of the given key"
	},
	"string Instance( string key, bool ToString = false ){ return get( key ).Instance( ToString ); }":
	{
		"prefix":[ "json", "Instanc" ],
		"body": "Instance( ${1:string key}, ${2:bool ToString = false})",
		"description": "Return the instance name on enum JsonValueType, if ToString is true return as a string"
	},
	"":
	{
		"prefix":[ "" ],
		"body": "",
		"description": "Vector get( string key, Vector value ){ return this[ key, value ]; } Vector opIndex( string key, Vector value ) { return ( this[ key, '' ].IsEmpty() &&  && g_Utility.IsString3DVec( this[ key, '' ]) ? value : atov( this[ key, '' ] ) ); }  Vector2D get( string key, Vector2D value ){ return this[ key, value ]; } Vector2D opIndex( string key, Vector2D value ) { if( this.exists( key, true ) ) { array<string> szSplit = string( data[ key ] ).Split( ' ' );  if( szSplit.length() == 2 && g_Utility.IsStringFloat( szSplit[0] ) && g_Utility.IsStringFloat( szSplit[1] ) ) { return atov( string( data[ key ] ) ).Make2D(); } } return value; }  RGBA get( string key, RGBA value ){ return this[ key, value ]; } RGBA opIndex( string key, RGBA value ) { if( this.exists( key, true ) ) { array<string> szSplit = this[ key ].Split( ' ' );  for( uint ui = 0; ui < szSplit.length() && g_Utility.IsStringInt( szSplit[ui] ); ui++ ) { if( ui == 3 ) { return atorgba( string( data[ key ] ) ); } } } return value; }*/ json get( string key, json value ){ return this[ key, value ]; } json opIndex( string key, json value ){ return this[ key, value.data ]; } json get( string key, dictionary value ){ return this[ key, value ]; } json opIndex( string key, dictionary value ) { json pJson; if( this.data.exists( key ) ) { if( this.Instance( key ) == JsonValueType::ARRAY ) { array<string> str = this[ key ].arrayvalue;  for( uint ui = 0; ui < str.length(); ui++ ) { pJson.data[ string(ui) ] = str[ui]; } } else { pJson.data = dictionary( this.data[ key ] ); } } return pJson; }  array<string> getKeys() { return this.data.getKeys(); }  json opAssign( dictionary pkvd ) { array<string> str = pkvd.getKeys();  for( uint ui = 0; ui < str.length(); ui++ ) { if( string( pkvd[ str[ui] ] ).IsEmpty() ) { this.data.delete( str[ui] ); } else { this.data[ str[ui] ] = string( pkvd[ str[ui] ] ); } } return this; }"
	},
	"uint load( string m_szLoad, bool include = false )":
	{
		"prefix":[ "load", "json", "pars" ],
		"body": "load( ${1:string m_szLoad}, ${2:bool include = false})",
		"description": "Loads a json file within a json class. if no format '.json' is provided it asumes you sent a string with json format if include is true the json is not cleared and new data will be written above, When specifying format, folder maps/plugins is necesary to include in the path. Return codes: 0 = everything fine 1 = empty string sent 2 = file not found"
	},
	"enum MKLANG::CHAT":
	{
		"prefix": [ "CHAT", "MKLANG::CHAT" ],
		"body": "MKLANG::CHAT",
		"description": "ClientPrint -> HUD_PRINTTALK",
	},
	"enum MKLANG::BIND":
	{
		"prefix": [ "BIND", "MKLANG::BIND" ],
		"body": "MKLANG::BIND",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString",
	},
	"enum MKLANG::CENTER":
	{
		"prefix": [ "CENTER", "MKLANG::CENTER" ],
		"body": "MKLANG::CENTER",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER",
	},
	"enum MKLANG::HUDMSG":
	{
		"prefix": [ "HUDMSG", "MKLANG::HUDMSG" ],
		"body": "MKLANG::HUDMSG",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER HudMessage Pass arguments in the json file. x = -1, y = -1, effect = 1, color = 255 255 255, color2 = 255 255 255, fadein = 0, fadeout = 1, hold = 1, fxtime = 1, channel = 8",
	},
	"enum MKLANG::NOTIFY":
	{
		"prefix": [ "NOTIFY", "MKLANG::NOTIFY" ],
		"body": "MKLANG::NOTIFY",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER HudMessage Pass arguments in the json file. x = -1, y = -1, effect = 1, color = 255 255 255, color2 = 255 255 255, fadein = 0, fadeout = 1, hold = 1, fxtime = 1, channel = 8 ClientPrint -> HUD_PRINTNOTIFY",
	},
	"enum MKLANG::CONSOLE":
	{
		"prefix": [ "CONSOLE", "MKLANG::CONSOLE" ],
		"body": "MKLANG::CONSOLE",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER HudMessage Pass arguments in the json file. x = -1, y = -1, effect = 1, color = 255 255 255, color2 = 255 255 255, fadein = 0, fadeout = 1, hold = 1, fxtime = 1, channel = 8 ClientPrint -> HUD_PRINTNOTIFY ClientPrint -> HUD_PRINTCONSOLE",
	},
	"string GetLanguage( CBasePlayer@ pPlayer, json@ pJson, dictionary@ pReplacement = null )":
	{
		"prefix":[ "Mikk.Language.GetLanguage", "GetLanguag" ],
		"body": "Mikk.Language.GetLanguage( ${1:CBasePlayer@ pPlayer}, ${2:json@ pJson}, ${3:dictionary@ pReplacement = null})",
		"description": "ClientPrint -> HUD_PRINTTALK PrintKeyBindingString ClientPrint -> HUD_PRINTCENTER HudMessage Pass arguments in the json file. x = -1, y = -1, effect = 1, color = 255 255 255, color2 = 255 255 255, fadein = 0, fadeout = 1, hold = 1, fxtime = 1, channel = 8 ClientPrint -> HUD_PRINTNOTIFY ClientPrint -> HUD_PRINTCONSOLE Gets a language string from the given json value, pReplacement keys will be replaced with their values. note in the json string it have to be enclosed with two $"
	},
	"void PrintAll( json@ pJson, MKLANG PrintType = CHAT, dictionary@ pReplacement = null )":
	{
		"prefix":[ "Mikk.Language.PrintAll", "PrintAll", "Languag" ],
		"body": "Mikk.Language.PrintAll( ${1:json@ pJson}, ${2:MKLANG PrintType = CHAT}, ${3:dictionary@ pReplacement = null})",
		"description": "Prints a language string from the given json value, PrintType is the message type. see the enum pReplacement keys will be replaced with their values. note in the json string it have to be enclosed with two $"
	},
	"void Print( CBasePlayer@ pPlayer, json@ pJson, MKLANG PrintType = CHAT, dictionary@ pReplacement = null )":
	{
		"prefix":[ "Mikk.Language.PrintAll", "PrintAll", "Languag" ],
		"body": "Mikk.Language.Print( ${1:CBasePlayer@ pPlayer}, ${2:json@ pJson}, ${3:MKLANG PrintType = CHAT}, ${4:dictionary@ pReplacement = null})",
		"description": "Prints a language string from the given json value, PrintType is the message type. see the enum pReplacement keys will be replaced with their values. note in the json string it have to be enclosed with two $"
	},
	"void GetColormap( CBasePlayer@ pPlayer, RGBA &out TopRGB, RGBA &out BotRGB )":
	{
		"prefix":[ "Mikk.PlayerFuncs.GetColormap", "GetColormap", "colormap", "bottomcolor", "topcolor", "Hu" ],
		"body": "Mikk.PlayerFuncs.GetColormap( ${1:CBasePlayer@ pPlayer}, ${2:RGBA &out TopRGB}, ${3:RGBA &out BotRGB})",
		"description": "Gets bottomcolor and topcolor from the given player as a RGBA values"
	},
	"void ClientCommand( string_t m_iszCommand, CBasePlayer@ pPlayer, bool bAllPlayers = false )":
	{
		"prefix":[ "Mikk.PlayerFuncs.ClientCommand", "ClientCommand", "Command" ],
		"body": "Mikk.PlayerFuncs.ClientCommand( ${1:string_t m_iszCommand}, ${2:CBasePlayer@ pPlayer}, ${3:bool bAllPlayers = false})",
		"description": "Executes a console command on the given player or all players if bAllPlayers is true"
	},
	"CBasePlayer@ FindPlayerBySteamID( const string &in m_iszSteamID )":
	{
		"prefix":[ "Mikk.PlayerFuncs.FindPlayerBySteamID", "FindPlayerBySteamID", "SteamID" ],
		"body": "Mikk.PlayerFuncs.FindPlayerBySteamID( ${1:const string &in m_iszSteamID})",
		"description": "Get the CBasePlayer@ instance of the given SteamID"
	},
	"string GetSteamID( CBasePlayer@ pPlayer )":
	{
		"prefix":[ "Mikk.PlayerFuncs.GetSteamID", "GetSteamID", "SteamID" ],
		"body": "Mikk.PlayerFuncs.GetSteamID( ${1:CBasePlayer@ pPlayer})",
		"description": "Return the SteamID of the given player, BOTS will be enumerated by their index"
	},
	"bool RespawnPlayer( CBasePlayer@ pPlayer )":
	{
		"prefix":[ "Mikk.PlayerFuncs.RespawnPlayer", "RespawnPlay" ],
		"body": "Mikk.PlayerFuncs.RespawnPlayer( ${1:CBasePlayer@ pPlayer})",
		"description": "Revives the given player and then relocates him to a valid spawnpoint, returns true if revived"
	},
	"void PlayerSay( CBaseEntity@ pPlayer, string m_szMessage, CBasePlayer@ pTarget = null )":
	{
		"prefix":[ "Mikk.PlayerFuncs.PlayerSay", "chat", "say" ],
		"body": "Mikk.PlayerFuncs.PlayerSay( ${1:CBaseEntity@ pPlayer}, ${2:string m_szMessage}, ${3:CBasePlayer@ pTarget = null})",
		"description": "Make a player say something, if pTarget is not null, only pTarget will see the message."
	},
	"CBaseEntity@ CreateEntity( dictionary g_Data, bool blSpawnNow = true )":
	{
		"prefix":[ "Mikk.EntityFuncs.CreateEntity", "CreateEntity", "EntityCreat" ],
		"body": "Mikk.EntityFuncs.CreateEntity( ${1:dictionary g_Data}, ${2:bool blSpawnNow = true})",
		"description": "Creates a entity with the given keyvalue data, if blSpawnNow is false the entity is not spawned"
	},
	"bool LoadEntFile( const string &in m_szPath )":
	{
		"prefix":[ "Mikk.EntityFuncs.LoadEntFile", "LoadEntFil" ],
		"body": "Mikk.EntityFuncs.LoadEntFile( ${1:const string &in m_szPath})",
		"description": "Loads an external .ent file into the map"
	},
	"int Call( const string m_iszFunction )":
	{
		"prefix":[ "g_Reflection.Call", "g_Reflection.CallFunction", "CallFunction", "Reflection" ],
		"body": "g_Reflection.Call( ${1:const string m_iszFunction})",
		"description": "Calls a function globaly in all namespaces. Returns the number of functions called."
	},
	"Reflection::Function@ opIndex( string m_iszFunction )":
	{
		"prefix":[ "g_Reflection.opIndex", "g_Reflection.Get", "g_Reflection.Function", "Reflection" ],
		"body": "g_Reflection.opIndex( ${1:string m_iszFunction})",
		"description": "Get a script function by name or namespace::name"
	},
	"string GetDiscord()":
	{
		"prefix":[ "Mikk.GetDiscord", "Discord" ],
		"body": "Mikk.GetDiscord()",
		"description": "Get discord server invite"
	},
	"string GetContactInfo()":
	{
		"prefix":[ "Mikk.GetContactInfo", "Contact" ],
		"body": "Mikk.GetContactInfo()",
		"description": "Get contact info"
	},
	"void UpdateTimer( CScheduledFunction@ &out pTimer, string &in szFunction, float flTime, int iRepeat = 0 )":
	{
		"prefix":[ "Mikk.UpdateTimer", "UpdateTim" ],
		"body": "Mikk.UpdateTimer( ${1:CScheduledFunction@ &out pTimer}, ${2:string &in szFunction}, ${3:float flTime}, ${4:int iRepeat = 0})",
		"description": "Clears and sets a CScheduledFunction@ function with the given parameters"
	},
	"bool IsPluginInstalled( string m_iszPluginName, bool bCaseSensitive = false )":
	{
		"prefix":[ "Mikk.IsPluginInstalled", "IsPluginInstalled", "Plugin", "Installed", "IsInstalled" ],
		"body": "Mikk.IsPluginInstalled( ${1:string m_iszPluginName}, ${2:bool bCaseSensitive = false})",
		"description": "Return whatever the given plugin name is installed on the server."
	},
	"RGBA atorgba( const string m_iszFrom )":
	{
		"prefix":[ "atorgba" ],
		"body": "atorgba( ${1:const string m_iszFrom})",
		"description": "Return the given string as a 4D RGBA"
	},
	"Vector atov( const string m_iszFrom )":
	{
		"prefix":[ "atov", "StringToVecto" ],
		"body": "atov( ${1:const string m_iszFrom})",
		"description": "Return the given string as a 3D Vector"
	},
	"bool atob( const string m_iszFrom )":
	{
		"prefix":[ "atobool", "stringtobool" ],
		"body": "atob( ${1:const string m_iszFrom})",
		"description": "Return the given string as a boolean, 0/1 or false/true"
	},
	"string CustomKeyValue( CBaseEntity@ pEntity, const string&in m_iszKey, const string&in m_iszValue = String::EMPTY_STRING )":
	{
		"prefix":[ "CKV", "CustomKeyValu" ],
		"body": "CustomKeyValue( ${1:CBaseEntity@ pEntity}, ${2:const string&in m_iszKey}, ${3:const string&in m_iszValue = String::EMPTY_STRING})",
		"description": "Return the value of the given CustomKeyValue, if m_iszValue is given it will update the value, return String::INVALID_INDEX if the given entity is null, return String::EMPTY_STRING if the given entity doesn't have the custom key value"
	},
	"RGBA HUEtoRGB( float H )":
	{
		"prefix":[ "Hue", "HUEtoRGB" ],
		"body": "HUEtoRGB( ${1:float H})",
		"description": "Return a RGB color from a Hue color"
	},
	"float RGBtoHUE(Vector rgb)":
	{
		"prefix":[ "Hue", "RGBtoHUE" ],
		"body": "RGBtoHUE( ${1:Vector rg})",
		"description": "Return a Hue color from a RGB color"
	}
}
