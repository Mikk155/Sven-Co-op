{
	"void ClientCommand( const string_t &in m_iszCommand, const int &in m_iPlayerIndex = CMKPlayerFuncs_ALL_PLAYERS )":
	{
		"prefix":
		[
			"mk.PlayerFuncs.ClientCommand", "ClientCommand"
		],
		"body":
		[
			"mk.PlayerFuncs.ClientCommand( ${1:const string_t &in m_iszCommand}, ${2:const int &in m_iPlayerIndex = CMKPlayerFuncs_ALL_PLAYERS} )"
		],
		"description": "[Mikk] Executes a client command for the given player's index, if m_iPlayerIndex is zero, all players are affected."
	},
	"void ShowMOTD( const string &in m_iszMessage, const string &in m_iszTitle = String::EMPTY_STRING, const int &in m_iPlayerIndex = CMKPlayerFuncs_ALL_PLAYERS )":
	{
		"prefix":
		[
			"mk.PlayerFuncs.ShowMOTD", "ShowMOTD"
		],
		"body":
		[
			"mk.PlayerFuncs.ShowMOTD( ${1:const string &in m_iszMessage}, ${2:const string &in m_iszTitle = String::EMPTY_STRING}, ${3:const int &in m_iPlayerIndex = CMKPlayerFuncs_ALL_PLAYERS} )"
		],
		"description": "[Mikk] Shows a MOTD Pop-up message for the given player's index, if m_iPlayerIndex is zero, all players are affected"
	},
	"CBasePlayer@ FindPlayerBySteamID( const string &in m_iszSteamID )":
	{
		"prefix":
		[
			"mk.PlayerFuncs.FindPlayerBySteamID", "FindPlayerBySteamID"
		],
		"body":
		[
			"mk.PlayerFuncs.FindPlayerBySteamID( ${1:const string &in m_iszSteamID} )"
		],
		"description": "[Mikk] Gets the CBasePlayer owner of the given SteamID."
	},
	"string GetSteamID( CBasePlayer@ pPlayer )":
	{
		"prefix":
		[
			"mk.PlayerFuncs.GetSteamID", "GetSteamID"
		],
		"body":
		[
			"mk.PlayerFuncs.GetSteamID( ${1:CBasePlayer@ pPlayer} )"
		],
		"description": "[Mikk] Gets the STEAM ID of the given player."
	},
	"bool RespawnPlayer( CBasePlayer@ pPlayer )":
	{
		"prefix":
		[
			"mk.PlayerFuncs.RespawnPlayer", "RespawnPlayer"
		],
		"body":
		[
			"mk.PlayerFuncs.RespawnPlayer( ${1:CBasePlayer@ pPlayer} )"
		],
		"description": "[Mikk] *Revive* the given player into a valid spawnpoint, return false if there are no spawnpoints available."
	},
	"string GetLanguage( CBasePlayer@ pPlayer, dictionary g_Languages )":
	{
		"prefix":
		[
			"mk.PlayerFuncs.GetLanguage", "GetLanguage"
		],
		"body":
		[
			"mk.PlayerFuncs.GetLanguage",
			"(",
			"    ${1:CBasePlayer@ pPlayer},",
			"    {",
			"        { 'english', '${2:String Message}' },",
			"        { 'spanish', '${3:String Message}' },",
			"        { 'spanish spain', '${4:String Message}' },",
			"        { 'portuguese', '${5:String Message}' },",
			"        { 'german', '${6:String Message}' },",
			"        { 'french', '${7:String Message}' },",
			"        { 'italian', '${8:String Message}' },",
			"        { 'esperanto', '${9:String Message}' },",
			"        { 'czech', '${10:String Message}' },",
			"        { 'dutch', '${11:String Message}' },",
			"        { 'indonesian', '${12:String Message}' },",
			"        { 'romanian', '${13:String Message}' },",
			"        { 'turkish', '${14:String Message}' },",
			"        { 'albanian', '${15:String Message}' }",
			"    }",
			")"
		],
		"description": "[Mikk] return the current language for the given player"
	},
	"string GetLanguage( CBasePlayer@ pPlayer, dictionary@ g_Languages )":
	{
		"prefix":
		[
			"mk.PlayerFuncs.GetLanguage", "GetLanguage"
		],
		"body": "mk.PlayerFuncs.GetLanguage( ${1:CBasePlayer@ pPlayer}, ${2:dictionary@ g_Languages} )",
		"description": "[Mikk] return the current language for the given player"
	},
	"string PrintMessage( CBasePlayer@ pCaller, dictionary g_Message, int CMKPlayerFuncs_enum MSG_ENUM = CMKPlayerFuncs_PRINT_CHAT, bool bAllPlayers = false, dictionary@ rArgs = null )":
	{
		"prefix":
		[
			"mk.PlayerFuncs.PrintMessage", "PrintMessage"
		],
		"body": "mk.PlayerFuncs.PrintMessage( ${1:CBasePlayer@ pCaller}, ${2:dictionary g_Message}, ${3:int CMKPlayerFuncs_enum MSG_ENUM = CMKPlayerFuncs_PRINT_CHAT}, ${4:bool bAllPlayers = false}, ${5:dictionary@ rArgs = null} )",
		"description": "[Mikk] Prints a message with the given language."
	},
	/*
	shouldn't use this, send the enum directly because they are subject to change it's values
	"enum CMKPlayerFuncs_enum":
	{
		"prefix": "CMKPlayerFuncs_enum",
		"body": "CMKPlayerFuncs_enum( ${1:int CMKPlayerFuncs_enum} )",
		"description" : "[Mikk] converts a integer into CMKPlayerFuncs_enum"
	},
	*/
	"enum CMKPlayerFuncs_enum {..., CMKPlayerFuncs_ALL_PLAYERS, ...}":
	{
		"prefix": [ "CMKPlayerFuncs_enum", "CMKPlayerFuncs_ALL_PLAYERS" ],
		"body": "CMKPlayerFuncs_ALL_PLAYERS",
		"description" : "[Mikk] (0) Targets all connected players"
	},
	"enum CMKPlayerFuncs_enum {..., CMKPlayerFuncs_PRINT_CHAT, ...}":
	{
		"prefix": [ "CMKPlayerFuncs_enum", "CMKPlayerFuncs_PRINT_CHAT" ],
		"body": "CMKPlayerFuncs_PRINT_CHAT",
		"description" : "[Mikk] Chat message"
	},
	"enum CMKPlayerFuncs_enum {..., CMKPlayerFuncs_PRINT_BIND, ...}":
	{
		"prefix": [ "CMKPlayerFuncs_enum", "CMKPlayerFuncs_PRINT_BIND" ],
		"body": "CMKPlayerFuncs_PRINT_BIND",
		"description" : "[Mikk] Center + KeyBind"
	},
	"enum CMKPlayerFuncs_enum {..., CMKPlayerFuncs_PRINT_HUD, ...}":
	{
		"prefix": [ "CMKPlayerFuncs_enum", "CMKPlayerFuncs_PRINT_HUD" ],
		"body": "CMKPlayerFuncs_PRINT_HUD",
		"description" : "[Mikk] HUD game_text like, send arguments, same keyvalues as game_text."
	},
	"enum CMKPlayerFuncs_enum {..., CMKPlayerFuncs_PRINT_CONSOLE, ...}":
	{
		"prefix": [ "CMKPlayerFuncs_enum", "CMKPlayerFuncs_PRINT_CONSOLE" ],
		"body": "CMKPlayerFuncs_PRINT_CONSOLE",
		"description" : "[Mikk] Console"
	},
	"enum CMKPlayerFuncs_enum {..., CMKPlayerFuncs_PRINT_CENTER, ...}":
	{
		"prefix": [ "CMKPlayerFuncs_enum", "CMKPlayerFuncs_PRINT_CENTER" ],
		"body": "CMKPlayerFuncs_PRINT_CENTER",
		"description" : "[Mikk] Center"
	},
	"enum CMKPlayerFuncs_enum {..., CMKPlayerFuncs_PRINT_NOTIFY, ...}":
	{
		"prefix": [ "CMKPlayerFuncs_enum", "CMKPlayerFuncs_PRINT_NOTIFY" ],
		"body": "CMKPlayerFuncs_PRINT_NOTIFY",
		"description" : "[Mikk] Upper-Left notify"
	},
	"Vector atov( const string m_iszFrom )":
	{
		"prefix": "atov",
		"body":
		[
			"atov( ${1:const string m_iszFrom} )"
		],
		"description": "[Mikk] Return the given string as a 3 Digits Vector"
	},
	"RGBA atorgba":
	{
		"prefix": "atorgba",
		"body":
		[
			"atorgba( ${1:const string m_iszFrom} )"
		],
		"description": "[Mikk] Return the given string as a 4 Digits RGBA"
	},
	"bool IsPluginInstalled( string m_iszPluginName, bool bCaseSensitive = false )":
	{
		"prefix":
		[
			"mk.FileManager.IsPluginInstalled", "IsPluginInstalled"
		],
		"body":
		[
			"mk.FileManager.IsPluginInstalled( ${1:string m_iszPluginName}, ${2:bool bCaseSensitive = false} )"
		],
		"description": "[Mikk] Return whatever the given plugin name is installed in the server."
	},
	"bool IsMapScript( const string & in m_iszAngelScript )":
	{
		"prefix":
		[
			"mk.FileManager.IsMapScript", "IsMapScript"
		],
		"body":
		[
			"mk.FileManager.IsMapScript( ${1:const string & in m_iszAngelScript} )"
		],
		"description": "[Mikk] Return whatever the given angelscript have been already registered as a map_script."
	},
	"void global_messages( dictionary & out g_KeyValues, const string & in m_iszFind, bool & in IsPlugin = false, const string & in m_iszCustomPath = 'mikk/global_messages.ini' )":
	{
		"prefix":
		[
			"mk.FileManager.global_messages", "global_messages"
		],
		"body":
		[
			"mk.FileManager.global_messages( ${1:dictionary & out g_KeyValues}, ${2:const string & in m_iszFind}, ${3:bool & in IsPlugin = false}, ${4:const string & in m_iszCustomPath = 'mikk/global_messages.ini'} )"
		],
		"description": "[Mikk] Loads custom messages with multiple languages from a external filer."
	},
	"bool LoadEntFile( const string iszFileLoad, string iszClassname = String::INVALID_INDEX )":
	{
		"prefix":
		[
			"mk.FileManager.LoadEntFile", "LoadEntFile"
		],
		"body":
		[
			"mk.FileManager.LoadEntFile( ${1:const string iszFileLoad}, ${2:string iszClassname = String::INVALID_INDEX} )"
		],
		"description": "[Mikk] Loads entities from a external text file."
	},
	"bool IsStringInFile( const string m_iszPath, string m_iszComparator, const bool bLowerCase = true )":
	{
		"prefix":
		[
			"mk.FileManager.IsStringInFile", "IsStringInFile"
		],
		"body":
		[
			"mk.FileManager.IsStringInFile( ${1:const string m_iszPath}, ${2:string m_iszComparator}, ${3:const bool bLowerCase = true} )"
		],
		"description": "[Mikk] Return whatever the given text file contains the given comparator, support start or end wildcard (*), if bLowerCase is set to false, not lowercased will be applied."
	},
	"bool GetKeyAndValue( const string iszFileLoad, dictionary & out g_KeyValues, const bool blReplaceDict = false )":
	{
		"prefix":
		[
			"mk.FileManager.GetKeyAndValue", "GetKeyAndValue"
		],
		"body":
		[
			"mk.FileManager.GetKeyAndValue( ${1:const string m_iszPath}, ${2:dictionary & out g_KeyValues}, ${3:const bool blReplaceDict = false} )"
		],
		"description": "[Mikk] Return Keys and Values from a given file, if blReplaceDict is set, already existent values are replaced."
	},
	"void DamagePerSecond( EHandle hVictim, EHandle hInflictor, int itimes, int idamage, int dmgbits )":
	{
		"prefix":
		[
			"mk.EntityFuncs.DamagePerSecond", "DamagePerSecond"
		],
		"body":
		[
			"mk.EntityFuncs.DamagePerSecond( ${1:EHandle hVictim}, ${2:EHandle hInflictor}, ${3:int itimes}, ${4:int dmgbits} )"
		],
		"description": "[Mikk] Does DPS by the given damage and time ammout"
	},
	"bool CustomEntity( string &in m_iszName, bool &in bPrecache = false )":
	{
		"prefix":
		[
			"mk.EntityFuncs.CustomEntity", "CustomEntity"
		],
		"body":
		[
			"mk.EntityFuncs.CustomEntity( ${1:string &in m_iszName}, ${2:bool &in bPrecache = false} )"
		],
		"description": "[Mikk] Registers and precaches a custom entity sharing classname, namespace and class, return true if is registered."
	},
	"bool Trigger( string m_iszTarget, CBaseEntity@ pActivator = null, CBaseEntity@ pCaller = null, USE_TYPE UseTypex = USE_TOGGLE, float m_fDelay = 0.0f )":
	{
		"prefix":
		[
			"mk.EntityFuncs.Trigger", "Trigger"
		],
		"body":
		[
			"mk.EntityFuncs.Trigger( ${1:string m_iszTarget}, ${2:CBaseEntity@ pActivator = null}, ${3:CBaseEntity@ pCaller = null}, ${4:USE_TYPE UseTypex = USE_TOGGLE}, ${5:float m_fDelay = 0.0f} )"
		],
		"description": "[Mikk] Triggers a entity in the map"
	},
	"CBaseEntity@ CreateEntity( dictionary g_Keyvalues )":
	{
		"prefix":
		[
			"mk.EntityFuncs.CreateEntity", "CreateEntity"
		],
		"body":
		[
			"mk.EntityFuncs.CreateEntity",
			"(",
			"    {",
			"        { 'origin', '${1:0 0 0}' },",
			"        { 'classname', '${2:monster_headcrab}' },",
			"        { '${3:Key}', '${4:Value}' },",
			"        { '${5:Key}', '${6:Value}' }",
			"    }",
			")"
		],
		"description": "[Mikk] Creates and return a entity with the given keyvalues from the given dictionary"
	},
	"CBaseEntity@ CreateEntity( dictionary@ g_Keyvalues )":
	{
		"prefix":
		[
			"mk.EntityFuncs.CreateEntity", "CreateEntity"
		],
		"body": "mk.EntityFuncs.CreateEntity( ${1:dictionary@ g_Keyvalues} ",
		"description": "[Mikk] Creates and return a entity with the given keyvalues from the given dictionary"
	},
	"bool WhoAffected( CBasePlayer@ pPlayer, CMKEntityFuncs_enum m_eAffectType = CMKEntityFuncs_ACTIVATOR_ONLY, CBaseEntity@ pActivator = null )":
	{
		"prefix":
		[
			"mk.EntityFuncs.WhoAffected", "WhoAffected"
		],
		"body":
		[
			"mk.EntityFuncs.WhoAffected( ${1:CBasePlayer@ pPlayer}, ${2:CMKEntityFuncs_enum m_eAffectType = CMKEntityFuncs_ACTIVATOR_ONLY}, ${3:CBaseEntity@ pActivator = null} )"
		],
		"description": "[Mikk] return whatever the given player match the given condition (See enum CMKEntityFuncs_enum)"
	},
	"enum CMKEntityFuncs_enum {..., CMKEntityFuncs_ACTIVATOR_ONLY, ...}":
	{
		"prefix": [ "CMKEntityFuncs_enum", "CMKEntityFuncs_ACTIVATOR_ONLY" ],
		"body": "CMKEntityFuncs_ACTIVATOR_ONLY",
		"description" : "[Mikk] Only activator"
	},
	"enum CMKEntityFuncs_enum {..., CMKEntityFuncs_ALL_PLAYERS, ...}":
	{
		"prefix": [ "CMKEntityFuncs_enum", "CMKEntityFuncs_ALL_PLAYERS" ],
		"body": "CMKEntityFuncs_ALL_PLAYERS",
		"description" : "[Mikk] Everyone"
	},
	"enum CMKEntityFuncs_enum {..., CMKEntityFuncs_ALL_BUT_ACTIVATOR, ...}":
	{
		"prefix": [ "CMKEntityFuncs_enum", "CMKEntityFuncs_ALL_BUT_ACTIVATOR" ],
		"body": "CMKEntityFuncs_ALL_BUT_ACTIVATOR",
		"description" : "[Mikk] Everyone but activator"
	},
	"enum CMKEntityFuncs_enum {..., CMKEntityFuncs_ALL_ALIVE_PLAYER, ...}":
	{
		"prefix": [ "CMKEntityFuncs_enum", "CMKEntityFuncs_ALL_ALIVE_PLAYER" ],
		"body": "CMKEntityFuncs_ALL_ALIVE_PLAYER",
		"description" : "[Mikk] Everyone alive"
	},
	"enum CMKEntityFuncs_enum {..., CMKEntityFuncs_ALL_DEAD_PLAYER, ...}":
	{
		"prefix": [ "CMKEntityFuncs_enum", "CMKEntityFuncs_ALL_DEAD_PLAYER" ],
		"body": "CMKEntityFuncs_ALL_DEAD_PLAYER",
		"description" : "[Mikk] Everyone dead"
	},
	"string CustomKeyValue( CBaseEntity@ pEntity, const string&in m_iszKey, const string&in m_iszValue = String::EMPTY_STRING )":
	{
		"prefix":
		[
			"mk.EntityFuncs.CustomKeyValue", "CustomKeyValue"
		],
		"body":
		[
			"mk.EntityFuncs.CustomKeyValue( ${1:CBaseEntity@ pEntity}, ${2:const string&in m_iszKey}, ${3:const string&in m_iszValue = String::EMPTY_STRING} )"
		],
		"description": "[Mikk] Returns or set the custom key value on the given entity."
	},
	"bool Hooks::Player::PlayerKeyInput" :
	{
		"prefix": [ "PlayerKeyInput", "Hooks" ],
		"body" : [ "mk.Hooks.RegisterHook( Hooks::Player::PlayerKeyInput, @PlayerKeyInput )" ],
		"description" : "[Mikk] Call when the player's pev->button changes. m_iButton is the pressed pev->button, m_bReleased is true if the button has been released."
	},
	"HookReturnCode PlayerKeyInput( CBasePlayer@, In_Buttons m_iButton, const bool m_bReleased )":
	{
		"prefix": [ "PlayerKeyInput", "Hooks" ],
		"body" : [ "HookReturnCode PlayerKeyInput( CBasePlayer@, In_Buttons m_iButton, const bool m_bReleased )" ],
		"description" : "[Mikk] Call when the player's pev->button changes. m_iButton is the pressed pev->button, m_bReleased is true if the button has been released."
	},
	"bool Hooks::Player::PlayerFlashLight" :
	{
		"prefix": [ "PlayerFlashLight", "Hooks" ],
		"body" : [ "mk.Hooks.RegisterHook( Hooks::Player::PlayerFlashLight, @PlayerFlashLight )" ],
		"description" : "[Mikk] Call when the player's flashlight has been toggled. m_iRechargeSpeed = 0 stops recharging, < 0 slow recharge > 1 fast recharge, m_iConsumeSpeed = 0 stops consuming, < 0 slow consuming > 1 fast consuming."
	},
	"HookReturnCode PlayerFlashLight( CBasePlayer@ pPlayer, const bool m_bIsActive, int&out m_iRechargeSpeed, int&out m_iConsumeSpeed )":
	{
		"prefix": [ "PlayerFlashLight", "Hooks" ],
		"body" : [ "HookReturnCode PlayerFlashLight( CBasePlayer@ pPlayer, const bool m_bIsActive, int&out m_iRechargeSpeed, int&out m_iConsumeSpeed )" ],
		"description" : "[Mikk] Call when the player's flashlight has been toggled. m_iRechargeSpeed = 0 stops recharging, < 0 slow recharge > 1 fast recharge, m_iConsumeSpeed = 0 stops consuming, < 0 slow consuming > 1 fast consuming."
	},
	"bool Hooks::Player::PlayerObserverMode" :
	{
		"prefix": [ "PlayerObserverMode", "Hooks" ],
		"body" : [ "mk.Hooks.RegisterHook( Hooks::Player::PlayerObserverMode, @PlayerObserverMode )" ],
		"description" : "[Mikk] Call when the player's observer state changes. See ObserverMode enum."
	},
	"HookReturnCode PlayerObserverMode( CBasePlayer@ pPlayer, ObserverMode m_ObserverMode )":
	{
		"prefix": [ "PlayerObserverMode", "Hooks" ],
		"body" : [ "HookReturnCode PlayerObserverMode( CBasePlayer@ pPlayer, ObserverMode m_ObserverMode )" ],
		"description" : "[Mikk] Call when the player's observer state changes. See ObserverMode enum."
	},
	"enum Hooks::Game::MapChanged" :
	{
		"prefix": [ "MapChanged", "Hooks" ],
		"body" : [ "mk.Hooks.RegisterHook( Hooks::Game::MapChanged, @MapChanged )" ],
		"description" : "[Mikk] Called at MapInit."
	},
	"HookReturnCode MapChanged( const string& in m_iszMapName )":
	{
		"prefix": [ "MapChanged", "Hooks" ],
		"body" : [ "HookReturnCode MapChanged( const string& in m_iszMapName )" ],
		"description" : "[Mikk] Called at MapInit."
	}
}