{
	"enum Activity {..., ACT_RESET, ...}": {
		"prefix": "ACT_RESET",
		"body" : [ "ACT_RESET" ],
		"description" : "(0) Set m_Activity to this invalid value to force a reset to m_IdealActivity"
	},
	"enum Activity {..., ACT_IDLE, ...}": {
		"prefix": "ACT_IDLE",
		"body" : [ "ACT_IDLE" ],
		"description" : "(1)"
	},
	"enum Activity {..., ACT_GUARD, ...}": {
		"prefix": "ACT_GUARD",
		"body" : [ "ACT_GUARD" ],
		"description" : "(2)"
	},
	"enum Activity {..., ACT_WALK, ...}": {
		"prefix": "ACT_WALK",
		"body" : [ "ACT_WALK" ],
		"description" : "(3)"
	},
	"enum Activity {..., ACT_RUN, ...}": {
		"prefix": "ACT_RUN",
		"body" : [ "ACT_RUN" ],
		"description" : "(4)"
	},
	"enum Activity {..., ACT_FLY, ...}": {
		"prefix": "ACT_FLY",
		"body" : [ "ACT_FLY" ],
		"description" : "(5) Fly (and flap if appropriate)"
	},
	"enum Activity {..., ACT_SWIM, ...}": {
		"prefix": "ACT_SWIM",
		"body" : [ "ACT_SWIM" ],
		"description" : "(6)"
	},
	"enum Activity {..., ACT_HOP, ...}": {
		"prefix": "ACT_HOP",
		"body" : [ "ACT_HOP" ],
		"description" : "(7) vertical jump"
	},
	"enum Activity {..., ACT_LEAP, ...}": {
		"prefix": "ACT_LEAP",
		"body" : [ "ACT_LEAP" ],
		"description" : "(8) long forward jump"
	},
	"enum Activity {..., ACT_FALL, ...}": {
		"prefix": "ACT_FALL",
		"body" : [ "ACT_FALL" ],
		"description" : "(9)"
	},
	"enum Activity {..., ACT_LAND, ...}": {
		"prefix": "ACT_LAND",
		"body" : [ "ACT_LAND" ],
		"description" : "(10)"
	},
	"enum Activity {..., ACT_STRAFE_LEFT, ...}": {
		"prefix": "ACT_STRAFE_LEFT",
		"body" : [ "ACT_STRAFE_LEFT" ],
		"description" : "(11)"
	},
	"enum Activity {..., ACT_STRAFE_RIGHT, ...}": {
		"prefix": "ACT_STRAFE_RIGHT",
		"body" : [ "ACT_STRAFE_RIGHT" ],
		"description" : "(12)"
	},
	"enum Activity {..., ACT_ROLL_LEFT, ...}": {
		"prefix": "ACT_ROLL_LEFT",
		"body" : [ "ACT_ROLL_LEFT" ],
		"description" : "(13) tuck and roll, left"
	},
	"enum Activity {..., ACT_ROLL_RIGHT, ...}": {
		"prefix": "ACT_ROLL_RIGHT",
		"body" : [ "ACT_ROLL_RIGHT" ],
		"description" : "(14) tuck and roll, right"
	},
	"enum Activity {..., ACT_TURN_LEFT, ...}": {
		"prefix": "ACT_TURN_LEFT",
		"body" : [ "ACT_TURN_LEFT" ],
		"description" : "(15) turn quickly left (stationary)"
	},
	"enum Activity {..., ACT_TURN_RIGHT, ...}": {
		"prefix": "ACT_TURN_RIGHT",
		"body" : [ "ACT_TURN_RIGHT" ],
		"description" : "(16) turn quickly right (stationary)"
	},
	"enum Activity {..., ACT_CROUCH, ...}": {
		"prefix": "ACT_CROUCH",
		"body" : [ "ACT_CROUCH" ],
		"description" : "(17) the act of crouching down from a standing position"
	},
	"enum Activity {..., ACT_CROUCHIDLE, ...}": {
		"prefix": "ACT_CROUCHIDLE",
		"body" : [ "ACT_CROUCHIDLE" ],
		"description" : "(18) holding body in crouched position (loops)"
	},
	"enum Activity {..., ACT_STAND, ...}": {
		"prefix": "ACT_STAND",
		"body" : [ "ACT_STAND" ],
		"description" : "(19) the act of standing from a crouched position"
	},
	"enum Activity {..., ACT_USE, ...}": {
		"prefix": "ACT_USE",
		"body" : [ "ACT_USE" ],
		"description" : "(20)"
	},
	"enum Activity {..., ACT_SIGNAL1, ...}": {
		"prefix": "ACT_SIGNAL1",
		"body" : [ "ACT_SIGNAL1" ],
		"description" : "(21)"
	},
	"enum Activity {..., ACT_SIGNAL2, ...}": {
		"prefix": "ACT_SIGNAL2",
		"body" : [ "ACT_SIGNAL2" ],
		"description" : "(22)"
	},
	"enum Activity {..., ACT_SIGNAL3, ...}": {
		"prefix": "ACT_SIGNAL3",
		"body" : [ "ACT_SIGNAL3" ],
		"description" : "(23)"
	},
	"enum Activity {..., ACT_TWITCH, ...}": {
		"prefix": "ACT_TWITCH",
		"body" : [ "ACT_TWITCH" ],
		"description" : "(24)"
	},
	"enum Activity {..., ACT_COWER, ...}": {
		"prefix": "ACT_COWER",
		"body" : [ "ACT_COWER" ],
		"description" : "(25)"
	},
	"enum Activity {..., ACT_SMALL_FLINCH, ...}": {
		"prefix": "ACT_SMALL_FLINCH",
		"body" : [ "ACT_SMALL_FLINCH" ],
		"description" : "(26)"
	},
	"enum Activity {..., ACT_BIG_FLINCH, ...}": {
		"prefix": "ACT_BIG_FLINCH",
		"body" : [ "ACT_BIG_FLINCH" ],
		"description" : "(27)"
	},
	"enum Activity {..., ACT_RANGE_ATTACK1, ...}": {
		"prefix": "ACT_RANGE_ATTACK1",
		"body" : [ "ACT_RANGE_ATTACK1" ],
		"description" : "(28)"
	},
	"enum Activity {..., ACT_RANGE_ATTACK2, ...}": {
		"prefix": "ACT_RANGE_ATTACK2",
		"body" : [ "ACT_RANGE_ATTACK2" ],
		"description" : "(29)"
	},
	"enum Activity {..., ACT_MELEE_ATTACK1, ...}": {
		"prefix": "ACT_MELEE_ATTACK1",
		"body" : [ "ACT_MELEE_ATTACK1" ],
		"description" : "(30)"
	},
	"enum Activity {..., ACT_MELEE_ATTACK2, ...}": {
		"prefix": "ACT_MELEE_ATTACK2",
		"body" : [ "ACT_MELEE_ATTACK2" ],
		"description" : "(31)"
	},
	"enum Activity {..., ACT_RELOAD, ...}": {
		"prefix": "ACT_RELOAD",
		"body" : [ "ACT_RELOAD" ],
		"description" : "(32)"
	},
	"enum Activity {..., ACT_ARM, ...}": {
		"prefix": "ACT_ARM",
		"body" : [ "ACT_ARM" ],
		"description" : "(33) pull out gun, for instance"
	},
	"enum Activity {..., ACT_DISARM, ...}": {
		"prefix": "ACT_DISARM",
		"body" : [ "ACT_DISARM" ],
		"description" : "(34) reholster gun"
	},
	"enum Activity {..., ACT_EAT, ...}": {
		"prefix": "ACT_EAT",
		"body" : [ "ACT_EAT" ],
		"description" : "(35) monster chowing on a large food item (loop)"
	},
	"enum Activity {..., ACT_DIESIMPLE, ...}": {
		"prefix": "ACT_DIESIMPLE",
		"body" : [ "ACT_DIESIMPLE" ],
		"description" : "(36)"
	},
	"enum Activity {..., ACT_DIEBACKWARD, ...}": {
		"prefix": "ACT_DIEBACKWARD",
		"body" : [ "ACT_DIEBACKWARD" ],
		"description" : "(37)"
	},
	"enum Activity {..., ACT_DIEFORWARD, ...}": {
		"prefix": "ACT_DIEFORWARD",
		"body" : [ "ACT_DIEFORWARD" ],
		"description" : "(38)"
	},
	"enum Activity {..., ACT_DIEVIOLENT, ...}": {
		"prefix": "ACT_DIEVIOLENT",
		"body" : [ "ACT_DIEVIOLENT" ],
		"description" : "(39)"
	},
	"enum Activity {..., ACT_BARNACLE_HIT, ...}": {
		"prefix": "ACT_BARNACLE_HIT",
		"body" : [ "ACT_BARNACLE_HIT" ],
		"description" : "(40) barnacle tongue hits a monster"
	},
	"enum Activity {..., ACT_BARNACLE_PULL, ...}": {
		"prefix": "ACT_BARNACLE_PULL",
		"body" : [ "ACT_BARNACLE_PULL" ],
		"description" : "(41) barnacle is lifting the monster (loop)"
	},
	"enum Activity {..., ACT_BARNACLE_CHOMP, ...}": {
		"prefix": "ACT_BARNACLE_CHOMP",
		"body" : [ "ACT_BARNACLE_CHOMP" ],
		"description" : "(42) barnacle latches on to the monster"
	},
	"enum Activity {..., ACT_BARNACLE_CHEW, ...}": {
		"prefix": "ACT_BARNACLE_CHEW",
		"body" : [ "ACT_BARNACLE_CHEW" ],
		"description" : "(43) barnacle is holding the monster in its mouth (loop)"
	},
	"enum Activity {..., ACT_SLEEP, ...}": {
		"prefix": "ACT_SLEEP",
		"body" : [ "ACT_SLEEP" ],
		"description" : "(44)"
	},
	"enum Activity {..., ACT_INSPECT_FLOOR, ...}": {
		"prefix": "ACT_INSPECT_FLOOR",
		"body" : [ "ACT_INSPECT_FLOOR" ],
		"description" : "(45) for active idles, look at something on or near the floor"
	},
	"enum Activity {..., ACT_INSPECT_WALL, ...}": {
		"prefix": "ACT_INSPECT_WALL",
		"body" : [ "ACT_INSPECT_WALL" ],
		"description" : "(46) for active idles, look at something directly ahead of you (doesn't HAVE to be a wall or on a wall)"
	},
	"enum Activity {..., ACT_IDLE_ANGRY, ...}": {
		"prefix": "ACT_IDLE_ANGRY",
		"body" : [ "ACT_IDLE_ANGRY" ],
		"description" : "(47) alternate idle animation in which the monster is clearly agitated. (loop)"
	},
	"enum Activity {..., ACT_WALK_HURT, ...}": {
		"prefix": "ACT_WALK_HURT",
		"body" : [ "ACT_WALK_HURT" ],
		"description" : "(48) limp (loop)"
	},
	"enum Activity {..., ACT_RUN_HURT, ...}": {
		"prefix": "ACT_RUN_HURT",
		"body" : [ "ACT_RUN_HURT" ],
		"description" : "(49) limp (loop)"
	},
	"enum Activity {..., ACT_HOVER, ...}": {
		"prefix": "ACT_HOVER",
		"body" : [ "ACT_HOVER" ],
		"description" : "(50) Idle while in flight"
	},
	"enum Activity {..., ACT_GLIDE, ...}": {
		"prefix": "ACT_GLIDE",
		"body" : [ "ACT_GLIDE" ],
		"description" : "(51) Fly (don't flap)"
	},
	"enum Activity {..., ACT_FLY_LEFT, ...}": {
		"prefix": "ACT_FLY_LEFT",
		"body" : [ "ACT_FLY_LEFT" ],
		"description" : "(52) Turn left in flight"
	},
	"enum Activity {..., ACT_FLY_RIGHT, ...}": {
		"prefix": "ACT_FLY_RIGHT",
		"body" : [ "ACT_FLY_RIGHT" ],
		"description" : "(53) Turn right in flight"
	},
	"enum Activity {..., ACT_DETECT_SCENT, ...}": {
		"prefix": "ACT_DETECT_SCENT",
		"body" : [ "ACT_DETECT_SCENT" ],
		"description" : "(54) this means the monster smells a scent carried by the air"
	},
	"enum Activity {..., ACT_SNIFF, ...}": {
		"prefix": "ACT_SNIFF",
		"body" : [ "ACT_SNIFF" ],
		"description" : "(55) this is the act of actually sniffing an item in front of the monster"
	},
	"enum Activity {..., ACT_BITE, ...}": {
		"prefix": "ACT_BITE",
		"body" : [ "ACT_BITE" ],
		"description" : "(56) some large monsters can eat small things in one bite. This plays one time, EAT loops."
	},
	"enum Activity {..., ACT_THREAT_DISPLAY, ...}": {
		"prefix": "ACT_THREAT_DISPLAY",
		"body" : [ "ACT_THREAT_DISPLAY" ],
		"description" : "(57) without attacking, monster demonstrates that it is angry. (Yell, stick out chest, etc)"
	},
	"enum Activity {..., ACT_FEAR_DISPLAY, ...}": {
		"prefix": "ACT_FEAR_DISPLAY",
		"body" : [ "ACT_FEAR_DISPLAY" ],
		"description" : "(58) monster just saw something that it is afraid of"
	},
	"enum Activity {..., ACT_EXCITED, ...}": {
		"prefix": "ACT_EXCITED",
		"body" : [ "ACT_EXCITED" ],
		"description" : "(59) for some reason, monster is excited. Sees something he really likes to eat, or whatever."
	},
	"enum Activity {..., ACT_SPECIAL_ATTACK1, ...}": {
		"prefix": "ACT_SPECIAL_ATTACK1",
		"body" : [ "ACT_SPECIAL_ATTACK1" ],
		"description" : "(60) very monster specific special attacks."
	},
	"enum Activity {..., ACT_SPECIAL_ATTACK2, ...}": {
		"prefix": "ACT_SPECIAL_ATTACK2",
		"body" : [ "ACT_SPECIAL_ATTACK2" ],
		"description" : "(61)"
	},
	"enum Activity {..., ACT_COMBAT_IDLE, ...}": {
		"prefix": "ACT_COMBAT_IDLE",
		"body" : [ "ACT_COMBAT_IDLE" ],
		"description" : "(62) agitated idle."
	},
	"enum Activity {..., ACT_WALK_SCARED, ...}": {
		"prefix": "ACT_WALK_SCARED",
		"body" : [ "ACT_WALK_SCARED" ],
		"description" : "(63)"
	},
	"enum Activity {..., ACT_RUN_SCARED, ...}": {
		"prefix": "ACT_RUN_SCARED",
		"body" : [ "ACT_RUN_SCARED" ],
		"description" : "(64)"
	},
	"enum Activity {..., ACT_VICTORY_DANCE, ...}": {
		"prefix": "ACT_VICTORY_DANCE",
		"body" : [ "ACT_VICTORY_DANCE" ],
		"description" : "(65) killed a player, do a victory dance."
	},
	"enum Activity {..., ACT_DIE_HEADSHOT, ...}": {
		"prefix": "ACT_DIE_HEADSHOT",
		"body" : [ "ACT_DIE_HEADSHOT" ],
		"description" : "(66) die, hit in head."
	},
	"enum Activity {..., ACT_DIE_CHESTSHOT, ...}": {
		"prefix": "ACT_DIE_CHESTSHOT",
		"body" : [ "ACT_DIE_CHESTSHOT" ],
		"description" : "(67) die, hit in chest"
	},
	"enum Activity {..., ACT_DIE_GUTSHOT, ...}": {
		"prefix": "ACT_DIE_GUTSHOT",
		"body" : [ "ACT_DIE_GUTSHOT" ],
		"description" : "(68) die, hit in gut"
	},
	"enum Activity {..., ACT_DIE_BACKSHOT, ...}": {
		"prefix": "ACT_DIE_BACKSHOT",
		"body" : [ "ACT_DIE_BACKSHOT" ],
		"description" : "(69) die, hit in back"
	},
	"enum Activity {..., ACT_FLINCH_HEAD, ...}": {
		"prefix": "ACT_FLINCH_HEAD",
		"body" : [ "ACT_FLINCH_HEAD" ],
		"description" : "(70)"
	},
	"enum Activity {..., ACT_FLINCH_CHEST, ...}": {
		"prefix": "ACT_FLINCH_CHEST",
		"body" : [ "ACT_FLINCH_CHEST" ],
		"description" : "(71)"
	},
	"enum Activity {..., ACT_FLINCH_STOMACH, ...}": {
		"prefix": "ACT_FLINCH_STOMACH",
		"body" : [ "ACT_FLINCH_STOMACH" ],
		"description" : "(72)"
	},
	"enum Activity {..., ACT_FLINCH_LEFTARM, ...}": {
		"prefix": "ACT_FLINCH_LEFTARM",
		"body" : [ "ACT_FLINCH_LEFTARM" ],
		"description" : "(73)"
	},
	"enum Activity {..., ACT_FLINCH_RIGHTARM, ...}": {
		"prefix": "ACT_FLINCH_RIGHTARM",
		"body" : [ "ACT_FLINCH_RIGHTARM" ],
		"description" : "(74)"
	},
	"enum Activity {..., ACT_FLINCH_LEFTLEG, ...}": {
		"prefix": "ACT_FLINCH_LEFTLEG",
		"body" : [ "ACT_FLINCH_LEFTLEG" ],
		"description" : "(75)"
	},
	"enum Activity {..., ACT_FLINCH_RIGHTLEG, ...}": {
		"prefix": "ACT_FLINCH_RIGHTLEG",
		"body" : [ "ACT_FLINCH_RIGHTLEG" ],
		"description" : "(76)"
	},
	"enum AddPlayerItemResult {..., APIR_NotAdded, ...}": {
		"prefix": "APIR_NotAdded",
		"body" : [ "APIR_NotAdded" ],
		"description" : "(0) Player could not pick up this item"
	},
	"enum AddPlayerItemResult {..., APIR_DuplicateAdd, ...}": {
		"prefix": "APIR_DuplicateAdd",
		"body" : [ "APIR_DuplicateAdd" ],
		"description" : "(2) Player was able to add it as duplicate"
	},
	"enum AddPlayerItemResult {..., APIR_Added, ...}": {
		"prefix": "APIR_Added",
		"body" : [ "APIR_Added" ],
		"description" : "(3) Player picked up this item"
	},
	"enum AdminLevel_t {..., ADMIN_INIT, ...}": {
		"prefix": "ADMIN_INIT",
		"body" : [ "ADMIN_INIT" ],
		"description" : "(-1) Level on connect, tells functions not to use cached level"
	},
	"enum AdminLevel_t {..., ADMIN_NO, ...}": {
		"prefix": "ADMIN_NO",
		"body" : [ "ADMIN_NO" ],
		"description" : "(0) Not an administrator"
	},
	"enum AdminLevel_t {..., ADMIN_YES, ...}": {
		"prefix": "ADMIN_YES",
		"body" : [ "ADMIN_YES" ],
		"description" : "(1) Server administrator"
	},
	"enum AdminLevel_t {..., ADMIN_OWNER, ...}": {
		"prefix": "ADMIN_OWNER",
		"body" : [ "ADMIN_OWNER" ],
		"description" : "(2) Server owner (applies to a listenserver host player)"
	},
	"enum AITRIGGER {..., AITRIGGER_NONE, ...}": {
		"prefix": "AITRIGGER_NONE",
		"body" : [ "AITRIGGER_NONE" ],
		"description" : "(0) No Trigger"
	},
	"enum AITRIGGER {..., AITRIGGER_SEEPLAYER_ANGRY_AT_PLAYER, ...}": {
		"prefix": "AITRIGGER_SEEPLAYER_ANGRY_AT_PLAYER",
		"body" : [ "AITRIGGER_SEEPLAYER_ANGRY_AT_PLAYER" ],
		"description" : "(1) See Player"
	},
	"enum AITRIGGER {..., AITRIGGER_TAKEDAMAGE, ...}": {
		"prefix": "AITRIGGER_TAKEDAMAGE",
		"body" : [ "AITRIGGER_TAKEDAMAGE" ],
		"description" : "(2) Take Damage"
	},
	"enum AITRIGGER {..., AITRIGGER_HALFHEALTH, ...}": {
		"prefix": "AITRIGGER_HALFHEALTH",
		"body" : [ "AITRIGGER_HALFHEALTH" ],
		"description" : "(3) 50% Health Remaining"
	},
	"enum AITRIGGER {..., AITRIGGER_DEATH, ...}": {
		"prefix": "AITRIGGER_DEATH",
		"body" : [ "AITRIGGER_DEATH" ],
		"description" : "(4) Death"
	},
	"enum AITRIGGER {..., AITRIGGER_SQUADMEMBERDIE, ...}": {
		"prefix": "AITRIGGER_SQUADMEMBERDIE",
		"body" : [ "AITRIGGER_SQUADMEMBERDIE" ],
		"description" : "(5) Squad Member Dead"
	},
	"enum AITRIGGER {..., AITRIGGER_SQUADLEADERDIE, ...}": {
		"prefix": "AITRIGGER_SQUADLEADERDIE",
		"body" : [ "AITRIGGER_SQUADLEADERDIE" ],
		"description" : "(6) Squad Leader Dead"
	},
	"enum AITRIGGER {..., AITRIGGER_HEARWORLD, ...}": {
		"prefix": "AITRIGGER_HEARWORLD",
		"body" : [ "AITRIGGER_HEARWORLD" ],
		"description" : "(7) Hear World"
	},
	"enum AITRIGGER {..., AITRIGGER_HEARPLAYER, ...}": {
		"prefix": "AITRIGGER_HEARPLAYER",
		"body" : [ "AITRIGGER_HEARPLAYER" ],
		"description" : "(8) Hear Player"
	},
	"enum AITRIGGER {..., AITRIGGER_HEARCOMBAT, ...}": {
		"prefix": "AITRIGGER_HEARCOMBAT",
		"body" : [ "AITRIGGER_HEARCOMBAT" ],
		"description" : "(9) Hear Combat"
	},
	"enum AITRIGGER {..., AITRIGGER_SEEPLAYER_UNCONDITIONAL, ...}": {
		"prefix": "AITRIGGER_SEEPLAYER_UNCONDITIONAL",
		"body" : [ "AITRIGGER_SEEPLAYER_UNCONDITIONAL" ],
		"description" : "(10) See Player Unconditional"
	},
	"enum AITRIGGER {..., AITRIGGER_SEEPLAYER_NOT_IN_COMBAT, ...}": {
		"prefix": "AITRIGGER_SEEPLAYER_NOT_IN_COMBAT",
		"body" : [ "AITRIGGER_SEEPLAYER_NOT_IN_COMBAT" ],
		"description" : "(11) See Player, Not In Combat"
	},
	"enum ALERT_TYPE {..., at_notice, ...}": {
		"prefix": "at_notice",
		"body" : [ "at_notice" ],
		"description" : "(0) Prints 'NOTICE: <message>'"
	},
	"enum ALERT_TYPE {..., at_console, ...}": {
		"prefix": "at_console",
		"body" : [ "at_console" ],
		"description" : "(1) Outputs text to the console only if developer is larger than 0"
	},
	"enum ALERT_TYPE {..., at_aiconsole, ...}": {
		"prefix": "at_aiconsole",
		"body" : [ "at_aiconsole" ],
		"description" : "(2) Only shown if developer is 2 or larger"
	},
	"enum ALERT_TYPE {..., at_warning, ...}": {
		"prefix": "at_warning",
		"body" : [ "at_warning" ],
		"description" : "(3) Prints 'Warning: <message>'"
	},
	"enum ALERT_TYPE {..., at_error, ...}": {
		"prefix": "at_error",
		"body" : [ "at_error" ],
		"description" : "(4) Prints 'Error: <message>'"
	},
	"enum ALERT_TYPE {..., at_logged, ...}": {
		"prefix": "at_logged",
		"body" : [ "at_logged" ],
		"description" : "(5) Server print to console (only in multiplayer games)"
	},
	"Arguments@ Reflection::Arguments::Arguments()": {
		"prefix": "Arguments",
		"body" : [ "Arguments()" ],
		"description" : "Default constructor"
	},
	"Arguments@ Reflection::Arguments::Arguments(const Arguments& in other)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:const Arguments& in other} )" ],
		"description" : "Copy constructor"
	},
	"Arguments@ Reflection::Arguments::Arguments() ": {
		"prefix": "Arguments",
		"body" : [ "Arguments()" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments@ Reflection::Arguments::Arguments(?& in)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:?& in} )" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments@ Reflection::Arguments::Arguments(?& in, ?& in)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:?& in}, ${2:?& in} )" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments@ Reflection::Arguments::Arguments(?& in, ?& in, ?& in)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:?& in}, ${2:?& in}, ${3:?& in} )" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments@ Reflection::Arguments::Arguments(?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in} )" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments@ Reflection::Arguments::Arguments(?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments@ Reflection::Arguments::Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments@ Reflection::Arguments::Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments@ Reflection::Arguments::Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Arguments",
		"body" : [ "Arguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Constructs a Arguments instance with the given arguments."
	},
	"Arguments& Reflection::Arguments::opAssign(const Arguments& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const Arguments& in other} )" ],
		"description" : "Assignment operator"
	},
	"size_t Reflection::Arguments::GetCount() const": {
		"prefix": "GetCount",
		"body" : [ "GetCount()" ],
		"description" : "Gets number of arguments."
	},
	"bool Reflection::Arguments::HasArguments() const": {
		"prefix": "HasArguments",
		"body" : [ "HasArguments()" ],
		"description" : "Returns whether this instance holds any arguments."
	},
	"void Reflection::Arguments::Clear()": {
		"prefix": "Clear",
		"body" : [ "Clear()" ],
		"description" : "Clears this instance's data."
	},
	"bool Reflection::Arguments::SetArguments()": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments()" ],
		"description" : "Sets the arguments this instance contains."
	},
	"bool Reflection::Arguments::SetArguments(?& in)": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments( ${1:?& in} )" ],
		"description" : "Sets the arguments this instance contains."
	},
	"bool Reflection::Arguments::SetArguments(?& in, ?& in)": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments( ${1:?& in}, ${2:?& in} )" ],
		"description" : "Sets the arguments this instance contains."
	},
	"bool Reflection::Arguments::SetArguments(?& in, ?& in, ?& in)": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments( ${1:?& in}, ${2:?& in}, ${3:?& in} )" ],
		"description" : "Sets the arguments this instance contains."
	},
	"bool Reflection::Arguments::SetArguments(?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in} )" ],
		"description" : "Sets the arguments this instance contains."
	},
	"bool Reflection::Arguments::SetArguments(?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Sets the arguments this instance contains."
	},
	"bool Reflection::Arguments::SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Sets the arguments this instance contains."
	},
	"bool Reflection::Arguments::SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Sets the arguments this instance contains."
	},
	"bool Reflection::Arguments::SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetArguments",
		"body" : [ "SetArguments( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Sets the arguments this instance contains."
	},
	"enum Reflection::ArgumentType {..., AT_NONE, ...}": {
		"prefix": "AT_NONE",
		"body" : [ "Reflection::AT_NONE" ],
		"description" : "(1) Argument has no type. If an argument has this type it means something went wrong during parsing."
	},
	"enum Reflection::ArgumentType {..., AT_VOID, ...}": {
		"prefix": "AT_VOID",
		"body" : [ "Reflection::AT_VOID" ],
		"description" : "(2) Argument is void."
	},
	"enum Reflection::ArgumentType {..., AT_PRIMITIVE, ...}": {
		"prefix": "AT_PRIMITIVE",
		"body" : [ "Reflection::AT_PRIMITIVE" ],
		"description" : "(4) Argument is a primitive type."
	},
	"enum Reflection::ArgumentType {..., AT_OBJECT, ...}": {
		"prefix": "AT_OBJECT",
		"body" : [ "Reflection::AT_OBJECT" ],
		"description" : "(24) Argument is an object type."
	},
	"enum Reflection::ArgumentType {..., AT_ENUM, ...}": {
		"prefix": "AT_ENUM",
		"body" : [ "Reflection::AT_ENUM" ],
		"description" : "(32) Argument is an enum type."
	},
	"bool BaseEntity::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Calls the base class implementation of KeyValue"
	},
	"void BaseEntity::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Calls the base class implementation of Precache"
	},
	"void BaseEntity::PreSpawn()": {
		"prefix": "PreSpawn",
		"body" : [ "PreSpawn()" ],
		"description" : "Calls the base class implementation of PreSpawn"
	},
	"void BaseEntity::Spawn()": {
		"prefix": "Spawn",
		"body" : [ "Spawn()" ],
		"description" : "Calls the base class implementation of Spawn"
	},
	"void BaseEntity::PostSpawn()": {
		"prefix": "PostSpawn",
		"body" : [ "PostSpawn()" ],
		"description" : "Calls the base class implementation of PostSpawn"
	},
	"void BaseEntity::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Calls the base class implementation of Think"
	},
	"void BaseEntity::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Touch"
	},
	"void BaseEntity::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Calls the base class implementation of Use"
	},
	"void BaseEntity::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Blocked"
	},
	"void BaseEntity::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Calls the base class implementation of UpdateOnRemove"
	},
	"int BaseEntity::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Calls the base class implementation of ObjectCaps"
	},
	"void BaseEntity::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in ptr}, ${5:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceAttack"
	},
	"int BaseEntity::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TakeDamage"
	},
	"bool BaseEntity::TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:float health_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeHealth"
	},
	"bool BaseEntity::TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:float armor_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeArmor"
	},
	"void BaseEntity::Killed(entvars_t@ pevAttacker, int iGib)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@ pevAttacker}, ${2:int iGib} )" ],
		"description" : "Calls the base class implementation of Killed"
	},
	"int BaseEntity::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Calls the base class implementation of BloodColor"
	},
	"void BaseEntity::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceBleed"
	},
	"float BaseEntity::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Calls the base class implementation of GetPointsForDamage"
	},
	"bool BaseEntity::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Calls the base class implementation of IsRevivable"
	},
	"void BaseEntity::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of BeginRevive"
	},
	"void BaseEntity::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of EndRevive"
	},
	"BaseMonster@ BaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"BaseTank@ BaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"BasePlayerItem@ BaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"BasePlayerWeapon@ BaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"BasePlayerAmmo@ BaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"BaseItem@ BaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"BaseEntity@ BaseItem::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"bool BaseItem::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Calls the base class implementation of KeyValue"
	},
	"void BaseItem::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Calls the base class implementation of Precache"
	},
	"void BaseItem::PreSpawn()": {
		"prefix": "PreSpawn",
		"body" : [ "PreSpawn()" ],
		"description" : "Calls the base class implementation of PreSpawn"
	},
	"void BaseItem::Spawn()": {
		"prefix": "Spawn",
		"body" : [ "Spawn()" ],
		"description" : "Calls the base class implementation of Spawn"
	},
	"void BaseItem::PostSpawn()": {
		"prefix": "PostSpawn",
		"body" : [ "PostSpawn()" ],
		"description" : "Calls the base class implementation of PostSpawn"
	},
	"void BaseItem::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Calls the base class implementation of Think"
	},
	"void BaseItem::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Touch"
	},
	"void BaseItem::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Calls the base class implementation of Use"
	},
	"void BaseItem::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Blocked"
	},
	"void BaseItem::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Calls the base class implementation of UpdateOnRemove"
	},
	"int BaseItem::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Calls the base class implementation of ObjectCaps"
	},
	"void BaseItem::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in ptr}, ${5:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceAttack"
	},
	"int BaseItem::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TakeDamage"
	},
	"bool BaseItem::TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:float health_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeHealth"
	},
	"bool BaseItem::TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:float armor_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeArmor"
	},
	"void BaseItem::Killed(entvars_t@ pevAttacker, int iGib)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@ pevAttacker}, ${2:int iGib} )" ],
		"description" : "Calls the base class implementation of Killed"
	},
	"int BaseItem::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Calls the base class implementation of BloodColor"
	},
	"void BaseItem::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceBleed"
	},
	"float BaseItem::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Calls the base class implementation of GetPointsForDamage"
	},
	"bool BaseItem::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Calls the base class implementation of IsRevivable"
	},
	"void BaseItem::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of BeginRevive"
	},
	"void BaseItem::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of EndRevive"
	},
	"BaseEntity@ BaseMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"bool BaseMonster::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Calls the base class implementation of KeyValue"
	},
	"void BaseMonster::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Calls the base class implementation of Precache"
	},
	"void BaseMonster::PreSpawn()": {
		"prefix": "PreSpawn",
		"body" : [ "PreSpawn()" ],
		"description" : "Calls the base class implementation of PreSpawn"
	},
	"void BaseMonster::Spawn()": {
		"prefix": "Spawn",
		"body" : [ "Spawn()" ],
		"description" : "Calls the base class implementation of Spawn"
	},
	"void BaseMonster::PostSpawn()": {
		"prefix": "PostSpawn",
		"body" : [ "PostSpawn()" ],
		"description" : "Calls the base class implementation of PostSpawn"
	},
	"void BaseMonster::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Calls the base class implementation of Think"
	},
	"void BaseMonster::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Touch"
	},
	"void BaseMonster::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Calls the base class implementation of Use"
	},
	"void BaseMonster::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Blocked"
	},
	"void BaseMonster::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Calls the base class implementation of UpdateOnRemove"
	},
	"int BaseMonster::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Calls the base class implementation of ObjectCaps"
	},
	"void BaseMonster::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in ptr}, ${5:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceAttack"
	},
	"int BaseMonster::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TakeDamage"
	},
	"bool BaseMonster::TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:float health_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeHealth"
	},
	"bool BaseMonster::TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:float armor_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeArmor"
	},
	"void BaseMonster::Killed(entvars_t@ pevAttacker, int iGib)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@ pevAttacker}, ${2:int iGib} )" ],
		"description" : "Calls the base class implementation of Killed"
	},
	"int BaseMonster::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Calls the base class implementation of BloodColor"
	},
	"void BaseMonster::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceBleed"
	},
	"float BaseMonster::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Calls the base class implementation of GetPointsForDamage"
	},
	"bool BaseMonster::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Calls the base class implementation of IsRevivable"
	},
	"void BaseMonster::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of BeginRevive"
	},
	"void BaseMonster::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of EndRevive"
	},
	"void BaseMonster::SetupFriendly()": {
		"prefix": "SetupFriendly",
		"body" : [ "SetupFriendly()" ],
		"description" : "Calls the base class implementation of SetupFriendly"
	},
	"int BaseMonster::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Calls the base class implementation of Classify"
	},
	"int BaseMonster::IgnoreConditions()": {
		"prefix": "IgnoreConditions",
		"body" : [ "IgnoreConditions()" ],
		"description" : "Calls the base class implementation of IgnoreConditions"
	},
	"void BaseMonster::AlertSound()": {
		"prefix": "AlertSound",
		"body" : [ "AlertSound()" ],
		"description" : "Calls the base class implementation of AlertSound"
	},
	"void BaseMonster::PainSound()": {
		"prefix": "PainSound",
		"body" : [ "PainSound()" ],
		"description" : "Calls the base class implementation of PainSound"
	},
	"void BaseMonster::DeathSound()": {
		"prefix": "DeathSound",
		"body" : [ "DeathSound()" ],
		"description" : "Calls the base class implementation of DeathSound"
	},
	"int BaseMonster::ISoundMask()": {
		"prefix": "ISoundMask",
		"body" : [ "ISoundMask()" ],
		"description" : "Calls the base class implementation of ISoundMask"
	},
	"bool BaseMonster::CheckRangeAttack1(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1",
		"body" : [ "CheckRangeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "Calls the base class implementation of CheckRangeAttack1"
	},
	"bool BaseMonster::CheckRangeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1_Move",
		"body" : [ "CheckRangeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "Calls the base class implementation of CheckRangeAttack1_Move"
	},
	"bool BaseMonster::CheckRangeAttack2(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2",
		"body" : [ "CheckRangeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "Calls the base class implementation of CheckRangeAttack2"
	},
	"bool BaseMonster::CheckRangeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2_Move",
		"body" : [ "CheckRangeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "Calls the base class implementation of CheckRangeAttack2_Move"
	},
	"bool BaseMonster::CheckMeleeAttack1(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1",
		"body" : [ "CheckMeleeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "Calls the base class implementation of CheckMeleeAttack1"
	},
	"bool BaseMonster::CheckMeleeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1_Move",
		"body" : [ "CheckMeleeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "Calls the base class implementation of CheckMeleeAttack1_Move"
	},
	"bool BaseMonster::CheckMeleeAttack2(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2",
		"body" : [ "CheckMeleeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "Calls the base class implementation of CheckMeleeAttack2"
	},
	"bool BaseMonster::CheckMeleeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2_Move",
		"body" : [ "CheckMeleeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "Calls the base class implementation of CheckMeleeAttack2_Move"
	},
	"void BaseMonster::CheckAmmo()": {
		"prefix": "CheckAmmo",
		"body" : [ "CheckAmmo()" ],
		"description" : "Calls the base class implementation of CheckAmmo"
	},
	"void BaseMonster::SetYawSpeed()": {
		"prefix": "SetYawSpeed",
		"body" : [ "SetYawSpeed()" ],
		"description" : "Calls the base class implementation of SetYawSpeed"
	},
	"void BaseMonster::StartTask(Task@ pTask)": {
		"prefix": "StartTask",
		"body" : [ "StartTask( ${1:Task@ pTask} )" ],
		"description" : "Calls the base class implementation of StartTask"
	},
	"void BaseMonster::RunTask(Task@ pTask)": {
		"prefix": "RunTask",
		"body" : [ "RunTask( ${1:Task@ pTask} )" ],
		"description" : "Calls the base class implementation of RunTask"
	},
	"void BaseMonster::HandleAnimEvent(MonsterEvent@ pEvent)": {
		"prefix": "HandleAnimEvent",
		"body" : [ "HandleAnimEvent( ${1:MonsterEvent@ pEvent} )" ],
		"description" : "Calls the base class implementation of HandleAnimEvent"
	},
	"Schedule@ BaseMonster::GetScheduleOfType(int iType)": {
		"prefix": "GetScheduleOfType",
		"body" : [ "GetScheduleOfType( ${1:int iType} )" ],
		"description" : "Calls the base class implementation of GetScheduleOfType"
	},
	"Schedule@ BaseMonster::GetSchedule()": {
		"prefix": "GetSchedule",
		"body" : [ "GetSchedule()" ],
		"description" : "Calls the base class implementation of GetSchedule"
	},
	"Schedule@ BaseMonster::ScheduleFromName(const string& in szName)": {
		"prefix": "ScheduleFromName",
		"body" : [ "ScheduleFromName( ${1:const string& in szName} )" ],
		"description" : "Calls the base class implementation of ScheduleFromName"
	},
	"void BaseMonster::RunAI()": {
		"prefix": "RunAI",
		"body" : [ "RunAI()" ],
		"description" : "Calls the base class implementation of RunAI"
	},
	"void BaseMonster::CallGibMonster()": {
		"prefix": "CallGibMonster",
		"body" : [ "CallGibMonster()" ],
		"description" : "Calls the base class implementation of CallGibMonster"
	},
	"void BaseMonster::GibMonster()": {
		"prefix": "GibMonster",
		"body" : [ "GibMonster()" ],
		"description" : "Calls the base class implementation of GibMonster"
	},
	"BaseEntity@ BasePlayerAmmo::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"bool BasePlayerAmmo::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Calls the base class implementation of KeyValue"
	},
	"void BasePlayerAmmo::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Calls the base class implementation of Precache"
	},
	"void BasePlayerAmmo::PreSpawn()": {
		"prefix": "PreSpawn",
		"body" : [ "PreSpawn()" ],
		"description" : "Calls the base class implementation of PreSpawn"
	},
	"void BasePlayerAmmo::Spawn()": {
		"prefix": "Spawn",
		"body" : [ "Spawn()" ],
		"description" : "Calls the base class implementation of Spawn"
	},
	"void BasePlayerAmmo::PostSpawn()": {
		"prefix": "PostSpawn",
		"body" : [ "PostSpawn()" ],
		"description" : "Calls the base class implementation of PostSpawn"
	},
	"void BasePlayerAmmo::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Calls the base class implementation of Think"
	},
	"void BasePlayerAmmo::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Touch"
	},
	"void BasePlayerAmmo::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Calls the base class implementation of Use"
	},
	"void BasePlayerAmmo::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Blocked"
	},
	"void BasePlayerAmmo::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Calls the base class implementation of UpdateOnRemove"
	},
	"int BasePlayerAmmo::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Calls the base class implementation of ObjectCaps"
	},
	"void BasePlayerAmmo::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in ptr}, ${5:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceAttack"
	},
	"int BasePlayerAmmo::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TakeDamage"
	},
	"bool BasePlayerAmmo::TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:float health_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeHealth"
	},
	"bool BasePlayerAmmo::TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:float armor_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeArmor"
	},
	"void BasePlayerAmmo::Killed(entvars_t@ pevAttacker, int iGib)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@ pevAttacker}, ${2:int iGib} )" ],
		"description" : "Calls the base class implementation of Killed"
	},
	"int BasePlayerAmmo::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Calls the base class implementation of BloodColor"
	},
	"void BasePlayerAmmo::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceBleed"
	},
	"float BasePlayerAmmo::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Calls the base class implementation of GetPointsForDamage"
	},
	"bool BasePlayerAmmo::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Calls the base class implementation of IsRevivable"
	},
	"void BasePlayerAmmo::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of BeginRevive"
	},
	"void BasePlayerAmmo::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of EndRevive"
	},
	"BaseEntity@ BasePlayerItem::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"bool BasePlayerItem::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Calls the base class implementation of KeyValue"
	},
	"void BasePlayerItem::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Calls the base class implementation of Precache"
	},
	"void BasePlayerItem::PreSpawn()": {
		"prefix": "PreSpawn",
		"body" : [ "PreSpawn()" ],
		"description" : "Calls the base class implementation of PreSpawn"
	},
	"void BasePlayerItem::Spawn()": {
		"prefix": "Spawn",
		"body" : [ "Spawn()" ],
		"description" : "Calls the base class implementation of Spawn"
	},
	"void BasePlayerItem::PostSpawn()": {
		"prefix": "PostSpawn",
		"body" : [ "PostSpawn()" ],
		"description" : "Calls the base class implementation of PostSpawn"
	},
	"void BasePlayerItem::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Calls the base class implementation of Think"
	},
	"void BasePlayerItem::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Touch"
	},
	"void BasePlayerItem::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Calls the base class implementation of Use"
	},
	"void BasePlayerItem::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Blocked"
	},
	"void BasePlayerItem::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Calls the base class implementation of UpdateOnRemove"
	},
	"int BasePlayerItem::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Calls the base class implementation of ObjectCaps"
	},
	"void BasePlayerItem::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in ptr}, ${5:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceAttack"
	},
	"int BasePlayerItem::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TakeDamage"
	},
	"bool BasePlayerItem::TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:float health_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeHealth"
	},
	"bool BasePlayerItem::TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:float armor_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeArmor"
	},
	"void BasePlayerItem::Killed(entvars_t@ pevAttacker, int iGib)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@ pevAttacker}, ${2:int iGib} )" ],
		"description" : "Calls the base class implementation of Killed"
	},
	"int BasePlayerItem::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Calls the base class implementation of BloodColor"
	},
	"void BasePlayerItem::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceBleed"
	},
	"float BasePlayerItem::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Calls the base class implementation of GetPointsForDamage"
	},
	"bool BasePlayerItem::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Calls the base class implementation of IsRevivable"
	},
	"void BasePlayerItem::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of BeginRevive"
	},
	"void BasePlayerItem::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of EndRevive"
	},
	"bool BasePlayerItem::AddToPlayer(CBasePlayer@ pPlayer)": {
		"prefix": "AddToPlayer",
		"body" : [ "AddToPlayer( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Calls the base class implementation of AddToPlayer"
	},
	"bool BasePlayerItem::AddDuplicate(CBasePlayerItem@ pItem)": {
		"prefix": "AddDuplicate",
		"body" : [ "AddDuplicate( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Calls the base class implementation of AddDuplicate"
	},
	"void BasePlayerItem::Materialize()": {
		"prefix": "Materialize",
		"body" : [ "Materialize()" ],
		"description" : "Calls the base class implementation of Materialize"
	},
	"void BasePlayerItem::GetItemInfo(ItemInfo& out info)": {
		"prefix": "GetItemInfo",
		"body" : [ "GetItemInfo( ${1:ItemInfo& out info} )" ],
		"description" : "Calls the base class implementation of GetItemInfo"
	},
	"bool BasePlayerItem::CanDeploy()": {
		"prefix": "CanDeploy",
		"body" : [ "CanDeploy()" ],
		"description" : "Calls the base class implementation of CanDeploy"
	},
	"bool BasePlayerItem::Deploy()": {
		"prefix": "Deploy",
		"body" : [ "Deploy()" ],
		"description" : "Calls the base class implementation of Deploy"
	},
	"bool BasePlayerItem::CanHolster()": {
		"prefix": "CanHolster",
		"body" : [ "CanHolster()" ],
		"description" : "Calls the base class implementation of CanHolster"
	},
	"void BasePlayerItem::Holster(int skiplocal = 0)": {
		"prefix": "Holster",
		"body" : [ "Holster( ${1:int skiplocal = 0} )" ],
		"description" : "Calls the base class implementation of Holster"
	},
	"void BasePlayerItem::UpdateItemInfo()": {
		"prefix": "UpdateItemInfo",
		"body" : [ "UpdateItemInfo()" ],
		"description" : "Calls the base class implementation of UpdateItemInfo"
	},
	"void BasePlayerItem::ItemPreFrame()": {
		"prefix": "ItemPreFrame",
		"body" : [ "ItemPreFrame()" ],
		"description" : "Calls the base class implementation of ItemPreFrame"
	},
	"void BasePlayerItem::ItemPostFrame()": {
		"prefix": "ItemPostFrame",
		"body" : [ "ItemPostFrame()" ],
		"description" : "Calls the base class implementation of ItemPostFrame"
	},
	"void BasePlayerItem::InactiveItemPreFrame()": {
		"prefix": "InactiveItemPreFrame",
		"body" : [ "InactiveItemPreFrame()" ],
		"description" : "Calls the base class implementation of InactiveItemPreFrame"
	},
	"void BasePlayerItem::InactiveItemPostFrame()": {
		"prefix": "InactiveItemPostFrame",
		"body" : [ "InactiveItemPostFrame()" ],
		"description" : "Calls the base class implementation of InactiveItemPostFrame"
	},
	"void BasePlayerItem::Kill()": {
		"prefix": "Kill",
		"body" : [ "Kill()" ],
		"description" : "Calls the base class implementation of Kill"
	},
	"void BasePlayerItem::AttachToPlayer(CBasePlayer@ pPlayer)": {
		"prefix": "AttachToPlayer",
		"body" : [ "AttachToPlayer( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Calls the base class implementation of AttachToPlayer"
	},
	"int BasePlayerItem::PrimaryAmmoIndex()": {
		"prefix": "PrimaryAmmoIndex",
		"body" : [ "PrimaryAmmoIndex()" ],
		"description" : "Calls the base class implementation of PrimaryAmmoIndex"
	},
	"int BasePlayerItem::SecondaryAmmoIndex()": {
		"prefix": "SecondaryAmmoIndex",
		"body" : [ "SecondaryAmmoIndex()" ],
		"description" : "Calls the base class implementation of SecondaryAmmoIndex"
	},
	"bool BasePlayerItem::UpdateClientData(CBasePlayer@ pPlayer)": {
		"prefix": "UpdateClientData",
		"body" : [ "UpdateClientData( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Calls the base class implementation of UpdateClientData"
	},
	"float BasePlayerItem::GetRespawnTime() const": {
		"prefix": "GetRespawnTime",
		"body" : [ "GetRespawnTime()" ],
		"description" : "Calls the base class implementation of GetRespawnTime"
	},
	"CBasePlayerItem@ BasePlayerItem::DropItem()": {
		"prefix": "DropItem",
		"body" : [ "DropItem()" ],
		"description" : "Calls the base class implementation of DropItem"
	},
	"bool BasePlayerItem::CanHaveDuplicates()": {
		"prefix": "CanHaveDuplicates",
		"body" : [ "CanHaveDuplicates()" ],
		"description" : "Calls the base class implementation of CanHaveDuplicates"
	},
	"BasePlayerWeapon@ BasePlayerItem::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"BaseEntity@ BasePlayerWeapon::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"bool BasePlayerWeapon::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Calls the base class implementation of KeyValue"
	},
	"void BasePlayerWeapon::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Calls the base class implementation of Precache"
	},
	"void BasePlayerWeapon::PreSpawn()": {
		"prefix": "PreSpawn",
		"body" : [ "PreSpawn()" ],
		"description" : "Calls the base class implementation of PreSpawn"
	},
	"void BasePlayerWeapon::Spawn()": {
		"prefix": "Spawn",
		"body" : [ "Spawn()" ],
		"description" : "Calls the base class implementation of Spawn"
	},
	"void BasePlayerWeapon::PostSpawn()": {
		"prefix": "PostSpawn",
		"body" : [ "PostSpawn()" ],
		"description" : "Calls the base class implementation of PostSpawn"
	},
	"void BasePlayerWeapon::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Calls the base class implementation of Think"
	},
	"void BasePlayerWeapon::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Touch"
	},
	"void BasePlayerWeapon::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Calls the base class implementation of Use"
	},
	"void BasePlayerWeapon::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Blocked"
	},
	"void BasePlayerWeapon::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Calls the base class implementation of UpdateOnRemove"
	},
	"int BasePlayerWeapon::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Calls the base class implementation of ObjectCaps"
	},
	"void BasePlayerWeapon::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in ptr}, ${5:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceAttack"
	},
	"int BasePlayerWeapon::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TakeDamage"
	},
	"bool BasePlayerWeapon::TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:float health_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeHealth"
	},
	"bool BasePlayerWeapon::TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:float armor_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeArmor"
	},
	"void BasePlayerWeapon::Killed(entvars_t@ pevAttacker, int iGib)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@ pevAttacker}, ${2:int iGib} )" ],
		"description" : "Calls the base class implementation of Killed"
	},
	"int BasePlayerWeapon::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Calls the base class implementation of BloodColor"
	},
	"void BasePlayerWeapon::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceBleed"
	},
	"float BasePlayerWeapon::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Calls the base class implementation of GetPointsForDamage"
	},
	"bool BasePlayerWeapon::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Calls the base class implementation of IsRevivable"
	},
	"void BasePlayerWeapon::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of BeginRevive"
	},
	"void BasePlayerWeapon::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of EndRevive"
	},
	"BasePlayerItem@ BasePlayerWeapon::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"bool BasePlayerWeapon::AddToPlayer(CBasePlayer@ pPlayer)": {
		"prefix": "AddToPlayer",
		"body" : [ "AddToPlayer( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Calls the base class implementation of AddToPlayer"
	},
	"bool BasePlayerWeapon::AddDuplicate(CBasePlayerItem@ pItem)": {
		"prefix": "AddDuplicate",
		"body" : [ "AddDuplicate( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Calls the base class implementation of AddDuplicate"
	},
	"void BasePlayerWeapon::Materialize()": {
		"prefix": "Materialize",
		"body" : [ "Materialize()" ],
		"description" : "Calls the base class implementation of Materialize"
	},
	"void BasePlayerWeapon::GetItemInfo(ItemInfo& out info)": {
		"prefix": "GetItemInfo",
		"body" : [ "GetItemInfo( ${1:ItemInfo& out info} )" ],
		"description" : "Calls the base class implementation of GetItemInfo"
	},
	"bool BasePlayerWeapon::CanDeploy()": {
		"prefix": "CanDeploy",
		"body" : [ "CanDeploy()" ],
		"description" : "Calls the base class implementation of CanDeploy"
	},
	"bool BasePlayerWeapon::Deploy()": {
		"prefix": "Deploy",
		"body" : [ "Deploy()" ],
		"description" : "Calls the base class implementation of Deploy"
	},
	"bool BasePlayerWeapon::CanHolster()": {
		"prefix": "CanHolster",
		"body" : [ "CanHolster()" ],
		"description" : "Calls the base class implementation of CanHolster"
	},
	"void BasePlayerWeapon::Holster(int skiplocal = 0)": {
		"prefix": "Holster",
		"body" : [ "Holster( ${1:int skiplocal = 0} )" ],
		"description" : "Calls the base class implementation of Holster"
	},
	"void BasePlayerWeapon::UpdateItemInfo()": {
		"prefix": "UpdateItemInfo",
		"body" : [ "UpdateItemInfo()" ],
		"description" : "Calls the base class implementation of UpdateItemInfo"
	},
	"void BasePlayerWeapon::ItemPreFrame()": {
		"prefix": "ItemPreFrame",
		"body" : [ "ItemPreFrame()" ],
		"description" : "Calls the base class implementation of ItemPreFrame"
	},
	"void BasePlayerWeapon::ItemPostFrame()": {
		"prefix": "ItemPostFrame",
		"body" : [ "ItemPostFrame()" ],
		"description" : "Calls the base class implementation of ItemPostFrame"
	},
	"void BasePlayerWeapon::InactiveItemPreFrame()": {
		"prefix": "InactiveItemPreFrame",
		"body" : [ "InactiveItemPreFrame()" ],
		"description" : "Calls the base class implementation of InactiveItemPreFrame"
	},
	"void BasePlayerWeapon::InactiveItemPostFrame()": {
		"prefix": "InactiveItemPostFrame",
		"body" : [ "InactiveItemPostFrame()" ],
		"description" : "Calls the base class implementation of InactiveItemPostFrame"
	},
	"void BasePlayerWeapon::Kill()": {
		"prefix": "Kill",
		"body" : [ "Kill()" ],
		"description" : "Calls the base class implementation of Kill"
	},
	"void BasePlayerWeapon::AttachToPlayer(CBasePlayer@ pPlayer)": {
		"prefix": "AttachToPlayer",
		"body" : [ "AttachToPlayer( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Calls the base class implementation of AttachToPlayer"
	},
	"int BasePlayerWeapon::PrimaryAmmoIndex()": {
		"prefix": "PrimaryAmmoIndex",
		"body" : [ "PrimaryAmmoIndex()" ],
		"description" : "Calls the base class implementation of PrimaryAmmoIndex"
	},
	"int BasePlayerWeapon::SecondaryAmmoIndex()": {
		"prefix": "SecondaryAmmoIndex",
		"body" : [ "SecondaryAmmoIndex()" ],
		"description" : "Calls the base class implementation of SecondaryAmmoIndex"
	},
	"bool BasePlayerWeapon::UpdateClientData(CBasePlayer@ pPlayer)": {
		"prefix": "UpdateClientData",
		"body" : [ "UpdateClientData( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Calls the base class implementation of UpdateClientData"
	},
	"float BasePlayerWeapon::GetRespawnTime() const": {
		"prefix": "GetRespawnTime",
		"body" : [ "GetRespawnTime()" ],
		"description" : "Calls the base class implementation of GetRespawnTime"
	},
	"CBasePlayerItem@ BasePlayerWeapon::DropItem()": {
		"prefix": "DropItem",
		"body" : [ "DropItem()" ],
		"description" : "Calls the base class implementation of DropItem"
	},
	"bool BasePlayerWeapon::CanHaveDuplicates()": {
		"prefix": "CanHaveDuplicates",
		"body" : [ "CanHaveDuplicates()" ],
		"description" : "Calls the base class implementation of CanHaveDuplicates"
	},
	"bool BasePlayerWeapon::ExtractAmmo(CBasePlayerWeapon@ pWeapon)": {
		"prefix": "ExtractAmmo",
		"body" : [ "ExtractAmmo( ${1:CBasePlayerWeapon@ pWeapon} )" ],
		"description" : "Calls the base class implementation of ExtractAmmo"
	},
	"bool BasePlayerWeapon::AddWeapon()": {
		"prefix": "AddWeapon",
		"body" : [ "AddWeapon()" ],
		"description" : "Calls the base class implementation of AddWeapon"
	},
	"bool BasePlayerWeapon::PlayEmptySound()": {
		"prefix": "PlayEmptySound",
		"body" : [ "PlayEmptySound()" ],
		"description" : "Calls the base class implementation of PlayEmptySound"
	},
	"void BasePlayerWeapon::ResetEmptySound()": {
		"prefix": "ResetEmptySound",
		"body" : [ "ResetEmptySound()" ],
		"description" : "Calls the base class implementation of ResetEmptySound"
	},
	"void BasePlayerWeapon::SendWeaponAnim(int iAnim, int skiplocal = 0, int body = 0)": {
		"prefix": "SendWeaponAnim",
		"body" : [ "SendWeaponAnim( ${1:int iAnim}, ${2:int skiplocal = 0}, ${3:int body = 0} )" ],
		"description" : "Calls the base class implementation of SendWeaponAnim"
	},
	"Vector BasePlayerWeapon::BulletAccuracy(const Vector& in vecMoving, const Vector& in vecStanding, const Vector& in vecCrouched)": {
		"prefix": "BulletAccuracy",
		"body" : [ "BulletAccuracy( ${1:const Vector& in vecMoving}, ${2:const Vector& in vecStanding}, ${3:const Vector& in vecCrouched} )" ],
		"description" : "Calls the base class implementation of BulletAccuracy"
	},
	"bool BasePlayerWeapon::IsUseable()": {
		"prefix": "IsUseable",
		"body" : [ "IsUseable()" ],
		"description" : "Calls the base class implementation of IsUseable"
	},
	"void BasePlayerWeapon::PrimaryAttack()": {
		"prefix": "PrimaryAttack",
		"body" : [ "PrimaryAttack()" ],
		"description" : "Calls the base class implementation of PrimaryAttack"
	},
	"void BasePlayerWeapon::SecondaryAttack()": {
		"prefix": "SecondaryAttack",
		"body" : [ "SecondaryAttack()" ],
		"description" : "Calls the base class implementation of SecondaryAttack"
	},
	"void BasePlayerWeapon::TertiaryAttack()": {
		"prefix": "TertiaryAttack",
		"body" : [ "TertiaryAttack()" ],
		"description" : "Calls the base class implementation of TertiaryAttack"
	},
	"void BasePlayerWeapon::Reload()": {
		"prefix": "Reload",
		"body" : [ "Reload()" ],
		"description" : "Calls the base class implementation of Reload"
	},
	"void BasePlayerWeapon::FinishReload()": {
		"prefix": "FinishReload",
		"body" : [ "FinishReload()" ],
		"description" : "Calls the base class implementation of FinishReload"
	},
	"bool BasePlayerWeapon::ShouldReload()": {
		"prefix": "ShouldReload",
		"body" : [ "ShouldReload()" ],
		"description" : "Calls the base class implementation of ShouldReload"
	},
	"void BasePlayerWeapon::WeaponIdle()": {
		"prefix": "WeaponIdle",
		"body" : [ "WeaponIdle()" ],
		"description" : "Calls the base class implementation of WeaponIdle"
	},
	"void BasePlayerWeapon::RetireWeapon()": {
		"prefix": "RetireWeapon",
		"body" : [ "RetireWeapon()" ],
		"description" : "Calls the base class implementation of RetireWeapon"
	},
	"bool BasePlayerWeapon::ShouldWeaponIdle()": {
		"prefix": "ShouldWeaponIdle",
		"body" : [ "ShouldWeaponIdle()" ],
		"description" : "Calls the base class implementation of ShouldWeaponIdle"
	},
	"bool BasePlayerWeapon::UseDecrement()": {
		"prefix": "UseDecrement",
		"body" : [ "UseDecrement()" ],
		"description" : "Calls the base class implementation of UseDecrement"
	},
	"void BasePlayerWeapon::BurstSupplement()": {
		"prefix": "BurstSupplement",
		"body" : [ "BurstSupplement()" ],
		"description" : "Calls the base class implementation of BurstSupplement"
	},
	"BaseEntity@ BaseTank::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"bool BaseTank::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Calls the base class implementation of KeyValue"
	},
	"void BaseTank::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Calls the base class implementation of Precache"
	},
	"void BaseTank::PreSpawn()": {
		"prefix": "PreSpawn",
		"body" : [ "PreSpawn()" ],
		"description" : "Calls the base class implementation of PreSpawn"
	},
	"void BaseTank::Spawn()": {
		"prefix": "Spawn",
		"body" : [ "Spawn()" ],
		"description" : "Calls the base class implementation of Spawn"
	},
	"void BaseTank::PostSpawn()": {
		"prefix": "PostSpawn",
		"body" : [ "PostSpawn()" ],
		"description" : "Calls the base class implementation of PostSpawn"
	},
	"void BaseTank::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Calls the base class implementation of Think"
	},
	"void BaseTank::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Touch"
	},
	"void BaseTank::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Calls the base class implementation of Use"
	},
	"void BaseTank::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Calls the base class implementation of Blocked"
	},
	"void BaseTank::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Calls the base class implementation of UpdateOnRemove"
	},
	"int BaseTank::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Calls the base class implementation of ObjectCaps"
	},
	"void BaseTank::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in ptr}, ${5:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceAttack"
	},
	"int BaseTank::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TakeDamage"
	},
	"bool BaseTank::TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:float health_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeHealth"
	},
	"bool BaseTank::TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:float armor_cap = 0} )" ],
		"description" : "Calls the base class implementation of TakeArmor"
	},
	"void BaseTank::Killed(entvars_t@ pevAttacker, int iGib)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@ pevAttacker}, ${2:int iGib} )" ],
		"description" : "Calls the base class implementation of Killed"
	},
	"int BaseTank::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Calls the base class implementation of BloodColor"
	},
	"void BaseTank::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Calls the base class implementation of TraceBleed"
	},
	"float BaseTank::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Calls the base class implementation of GetPointsForDamage"
	},
	"bool BaseTank::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Calls the base class implementation of IsRevivable"
	},
	"void BaseTank::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of BeginRevive"
	},
	"void BaseTank::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Calls the base class implementation of EndRevive"
	},
	"void BaseTank::Fire(const Vector& in vecBarrelEnd, const Vector& in vecForward, entvars_t@ pevAttacker)": {
		"prefix": "Fire",
		"body" : [ "Fire( ${1:const Vector& in vecBarrelEnd}, ${2:const Vector& in vecForward}, ${3:entvars_t@ pevAttacker} )" ],
		"description" : "Calls the base class implementation of Fire"
	},
	"Vector BaseTank::UpdateTargetPosition(CBaseEntity@ pTargetEntity)": {
		"prefix": "UpdateTargetPosition",
		"body" : [ "UpdateTargetPosition( ${1:CBaseEntity@ pTargetEntity} )" ],
		"description" : "Calls the base class implementation of UpdateTargetPosition"
	},
	"int BaseTank::BulletCount()": {
		"prefix": "BulletCount",
		"body" : [ "BulletCount()" ],
		"description" : "Calls the base class implementation of BulletCount"
	},
	"enum BeamFlags {..., BEAM_FSINE, ...}": {
		"prefix": "BEAM_FSINE",
		"body" : [ "BEAM_FSINE" ],
		"description" : "(16) Beam shape follows a sinus shape"
	},
	"enum BeamFlags {..., BEAM_FSOLID, ...}": {
		"prefix": "BEAM_FSOLID",
		"body" : [ "BEAM_FSOLID" ],
		"description" : "(32) Beam is a solid shape"
	},
	"enum BeamFlags {..., BEAM_FSHADEIN, ...}": {
		"prefix": "BEAM_FSHADEIN",
		"body" : [ "BEAM_FSHADEIN" ],
		"description" : "(64) Beam fades in at its start point"
	},
	"enum BeamFlags {..., BEAM_FSHADEOUT, ...}": {
		"prefix": "BEAM_FSHADEOUT",
		"body" : [ "BEAM_FSHADEOUT" ],
		"description" : "(128) Beam fades out at its end point"
	},
	"enum BeamType {..., BEAM_POINTS, ...}": {
		"prefix": "BEAM_POINTS",
		"body" : [ "BEAM_POINTS" ],
		"description" : "(0) Beam is a beam between 2 points"
	},
	"enum BeamType {..., BEAM_ENTPOINT, ...}": {
		"prefix": "BEAM_ENTPOINT",
		"body" : [ "BEAM_ENTPOINT" ],
		"description" : "(1) Beam is a beam between point and entity"
	},
	"enum BeamType {..., BEAM_ENTS, ...}": {
		"prefix": "BEAM_ENTS",
		"body" : [ "BEAM_ENTS" ],
		"description" : "(2) Beam is a beam between entities"
	},
	"enum BeamType {..., BEAM_HOSE, ...}": {
		"prefix": "BEAM_HOSE",
		"body" : [ "BEAM_HOSE" ],
		"description" : "(3) I don't even know what this does"
	},
	"enum bits_CAPABILITY {..., bits_CAP_DUCK, ...}": {
		"prefix": "bits_CAP_DUCK",
		"body" : [ "bits_CAP_DUCK" ],
		"description" : "(1) crouch"
	},
	"enum bits_CAPABILITY {..., bits_CAP_JUMP, ...}": {
		"prefix": "bits_CAP_JUMP",
		"body" : [ "bits_CAP_JUMP" ],
		"description" : "(2) jump/leap"
	},
	"enum bits_CAPABILITY {..., bits_CAP_STRAFE, ...}": {
		"prefix": "bits_CAP_STRAFE",
		"body" : [ "bits_CAP_STRAFE" ],
		"description" : "(4) strafe (walk/run sideways)"
	},
	"enum bits_CAPABILITY {..., bits_CAP_SQUAD, ...}": {
		"prefix": "bits_CAP_SQUAD",
		"body" : [ "bits_CAP_SQUAD" ],
		"description" : "(8) can form squads"
	},
	"enum bits_CAPABILITY {..., bits_CAP_SWIM, ...}": {
		"prefix": "bits_CAP_SWIM",
		"body" : [ "bits_CAP_SWIM" ],
		"description" : "(16) proficiently navigate in water"
	},
	"enum bits_CAPABILITY {..., bits_CAP_CLIMB, ...}": {
		"prefix": "bits_CAP_CLIMB",
		"body" : [ "bits_CAP_CLIMB" ],
		"description" : "(32) climb ladders/ropes"
	},
	"enum bits_CAPABILITY {..., bits_CAP_USE, ...}": {
		"prefix": "bits_CAP_USE",
		"body" : [ "bits_CAP_USE" ],
		"description" : "(64) open doors/push buttons/pull levers"
	},
	"enum bits_CAPABILITY {..., bits_CAP_HEAR, ...}": {
		"prefix": "bits_CAP_HEAR",
		"body" : [ "bits_CAP_HEAR" ],
		"description" : "(128) can hear forced sounds"
	},
	"enum bits_CAPABILITY {..., bits_CAP_AUTO_DOORS, ...}": {
		"prefix": "bits_CAP_AUTO_DOORS",
		"body" : [ "bits_CAP_AUTO_DOORS" ],
		"description" : "(256) can trigger auto doors"
	},
	"enum bits_CAPABILITY {..., bits_CAP_OPEN_DOORS, ...}": {
		"prefix": "bits_CAP_OPEN_DOORS",
		"body" : [ "bits_CAP_OPEN_DOORS" ],
		"description" : "(512) can open manual doors"
	},
	"enum bits_CAPABILITY {..., bits_CAP_TURN_HEAD, ...}": {
		"prefix": "bits_CAP_TURN_HEAD",
		"body" : [ "bits_CAP_TURN_HEAD" ],
		"description" : "(1024) can turn head, always bone controller 0"
	},
	"enum bits_CAPABILITY {..., bits_CAP_RANGE_ATTACK1, ...}": {
		"prefix": "bits_CAP_RANGE_ATTACK1",
		"body" : [ "bits_CAP_RANGE_ATTACK1" ],
		"description" : "(2048) can do a range attack 1"
	},
	"enum bits_CAPABILITY {..., bits_CAP_RANGE_ATTACK2, ...}": {
		"prefix": "bits_CAP_RANGE_ATTACK2",
		"body" : [ "bits_CAP_RANGE_ATTACK2" ],
		"description" : "(4096) can do a range attack 2"
	},
	"enum bits_CAPABILITY {..., bits_CAP_MELEE_ATTACK1, ...}": {
		"prefix": "bits_CAP_MELEE_ATTACK1",
		"body" : [ "bits_CAP_MELEE_ATTACK1" ],
		"description" : "(8192) can do a melee attack 1"
	},
	"enum bits_CAPABILITY {..., bits_CAP_MELEE_ATTACK2, ...}": {
		"prefix": "bits_CAP_MELEE_ATTACK2",
		"body" : [ "bits_CAP_MELEE_ATTACK2" ],
		"description" : "(16384) can do a melee attack 2"
	},
	"enum bits_CAPABILITY {..., bits_CAP_FLY, ...}": {
		"prefix": "bits_CAP_FLY",
		"body" : [ "bits_CAP_FLY" ],
		"description" : "(32768) can fly, move all around"
	},
	"enum bits_CAPABILITY {..., bits_CAP_USE_TANK, ...}": {
		"prefix": "bits_CAP_USE_TANK",
		"body" : [ "bits_CAP_USE_TANK" ],
		"description" : "(65536) can use func_tanks"
	},
	"enum bits_CAPABILITY {..., bits_CAP_FALL_DAMAGE, ...}": {
		"prefix": "bits_CAP_FALL_DAMAGE",
		"body" : [ "bits_CAP_FALL_DAMAGE" ],
		"description" : "(131072) can take fall damage"
	},
	"enum bits_CAPABILITY {..., bits_CAP_DOORS_GROUP, ...}": {
		"prefix": "bits_CAP_DOORS_GROUP",
		"body" : [ "bits_CAP_DOORS_GROUP" ],
		"description" : "(832) Combination of bits_CAP_USE, bits_CAP_AUTO_DOORS, and bits_CAP_OPEN_DOORS"
	},
	"enum bits_SOUND {..., bits_SOUND_NONE, ...}": {
		"prefix": "bits_SOUND_NONE",
		"body" : [ "bits_SOUND_NONE" ],
		"description" : "(0)"
	},
	"enum bits_SOUND {..., bits_SOUND_COMBAT, ...}": {
		"prefix": "bits_SOUND_COMBAT",
		"body" : [ "bits_SOUND_COMBAT" ],
		"description" : "(1) gunshots, explosions"
	},
	"enum bits_SOUND {..., bits_SOUND_WORLD, ...}": {
		"prefix": "bits_SOUND_WORLD",
		"body" : [ "bits_SOUND_WORLD" ],
		"description" : "(2) door opening/closing, glass breaking"
	},
	"enum bits_SOUND {..., bits_SOUND_PLAYER, ...}": {
		"prefix": "bits_SOUND_PLAYER",
		"body" : [ "bits_SOUND_PLAYER" ],
		"description" : "(4) all noises generated by player. walking, shooting, falling, splashing"
	},
	"enum bits_SOUND {..., bits_SOUND_CARCASS, ...}": {
		"prefix": "bits_SOUND_CARCASS",
		"body" : [ "bits_SOUND_CARCASS" ],
		"description" : "(8) dead body"
	},
	"enum bits_SOUND {..., bits_SOUND_MEAT, ...}": {
		"prefix": "bits_SOUND_MEAT",
		"body" : [ "bits_SOUND_MEAT" ],
		"description" : "(16) gib or pork chop"
	},
	"enum bits_SOUND {..., bits_SOUND_DANGER, ...}": {
		"prefix": "bits_SOUND_DANGER",
		"body" : [ "bits_SOUND_DANGER" ],
		"description" : "(32) pending danger. Grenade that is about to explode, explosive barrel that is damaged, falling crate"
	},
	"enum bits_SOUND {..., bits_SOUND_GARBAGE, ...}": {
		"prefix": "bits_SOUND_GARBAGE",
		"body" : [ "bits_SOUND_GARBAGE" ],
		"description" : "(64) trash cans, banana peels, old fast food bags."
	},
	"enum bits_SOUND {..., bits_SOUND_BULLETHIT, ...}": {
		"prefix": "bits_SOUND_BULLETHIT",
		"body" : [ "bits_SOUND_BULLETHIT" ],
		"description" : "(128) a bullet just hit at this location"
	},
	"enum bits_SOUND {..., bits_ALL_SOUNDS, ...}": {
		"prefix": "bits_ALL_SOUNDS",
		"body" : [ "bits_ALL_SOUNDS" ],
		"description" : "(-1) All sound flags"
	},
	"bool BLOB::HasAllocatedBuffer() const": {
		"prefix": "HasAllocatedBuffer",
		"body" : [ "HasAllocatedBuffer()" ],
		"description" : "Returns whether this instance has allocated a buffer."
	},
	"size_t BLOB::GetSizeInBytes() const": {
		"prefix": "GetSizeInBytes",
		"body" : [ "GetSizeInBytes()" ],
		"description" : "Gets the size of this BLOB, in bytes."
	},
	"size_t BLOB::GetReadOffset() const": {
		"prefix": "GetReadOffset",
		"body" : [ "GetReadOffset()" ],
		"description" : "Gets the read offset, in bytes."
	},
	"bool BLOB::ReadReachedEnd() const": {
		"prefix": "ReadReachedEnd",
		"body" : [ "ReadReachedEnd()" ],
		"description" : "Returns whether the last read operation reached the end of data that was written to this BLOB."
	},
	"bool BLOB::ReadSizeValid(size_t uiSizeInBytes) const": {
		"prefix": "ReadSizeValid",
		"body" : [ "ReadSizeValid( ${1:size_t uiSizeInBytes} )" ],
		"description" : "Returns whether the given amount of bytes can be read from this BLOB."
	},
	"size_t BLOB::GetWriteOffset() const": {
		"prefix": "GetWriteOffset",
		"body" : [ "GetWriteOffset()" ],
		"description" : "Gets the write offset, in bytes. This is the number of bytes written to this buffer."
	},
	"bool BLOB::CanWriteSize(size_t uiSizeInBytes) const": {
		"prefix": "CanWriteSize",
		"body" : [ "CanWriteSize( ${1:size_t uiSizeInBytes} )" ],
		"description" : "Returns whether the given amount of bytes can be written to this BLOB."
	},
	"size_t BLOB::GetWriteBytesLeft() const": {
		"prefix": "GetWriteBytesLeft",
		"body" : [ "GetWriteBytesLeft()" ],
		"description" : "Gets the number of bytes left that can be written to. This may change if a write operation causes the buffer to be resized."
	},
	"bool BLOB::CanResize() const": {
		"prefix": "CanResize",
		"body" : [ "CanResize()" ],
		"description" : "Returns whether this BLOB is allowed to resize its buffer."
	},
	"void BLOB::SetCanResize(bool fState)": {
		"prefix": "SetCanResize",
		"body" : [ "SetCanResize( ${1:bool fState} )" ],
		"description" : "Sets whether this BLOB is allowed to resize its buffer."
	},
	"int8 BLOB::ReadInt8()": {
		"prefix": "ReadInt8",
		"body" : [ "ReadInt8()" ],
		"description" : "Reads an int8 from this BLOB."
	},
	"int16 BLOB::ReadInt16()": {
		"prefix": "ReadInt16",
		"body" : [ "ReadInt16()" ],
		"description" : "Reads an int16 from this BLOB."
	},
	"int32 BLOB::ReadInt32()": {
		"prefix": "ReadInt32",
		"body" : [ "ReadInt32()" ],
		"description" : "Reads an int32 from this BLOB."
	},
	"int64 BLOB::ReadInt64()": {
		"prefix": "ReadInt64",
		"body" : [ "ReadInt64()" ],
		"description" : "Reads an int64 from this BLOB."
	},
	"uint8 BLOB::ReadUInt8()": {
		"prefix": "ReadUInt8",
		"body" : [ "ReadUInt8()" ],
		"description" : "Reads a uint8 from this BLOB."
	},
	"int16 BLOB::ReadUInt16()": {
		"prefix": "ReadUInt16",
		"body" : [ "ReadUInt16()" ],
		"description" : "Reads a uint16 from this BLOB."
	},
	"int32 BLOB::ReadUInt32()": {
		"prefix": "ReadUInt32",
		"body" : [ "ReadUInt32()" ],
		"description" : "Reads a uint32 from this BLOB."
	},
	"int64 BLOB::ReadUInt64()": {
		"prefix": "ReadUInt64",
		"body" : [ "ReadUInt64()" ],
		"description" : "Reads a uint64 from this BLOB."
	},
	"float BLOB::ReadFloat()": {
		"prefix": "ReadFloat",
		"body" : [ "ReadFloat()" ],
		"description" : "Reads a float from this BLOB."
	},
	"double BLOB::ReadDouble()": {
		"prefix": "ReadDouble",
		"body" : [ "ReadDouble()" ],
		"description" : "Reads a double from this BLOB."
	},
	"int8 BLOB::ReadInt8(bool& out fSuccess)": {
		"prefix": "ReadInt8",
		"body" : [ "ReadInt8( ${1:bool& out fSuccess} )" ],
		"description" : "Reads an int8 from this BLOB. fSuccess is true if the read succeeded."
	},
	"int16 BLOB::ReadInt16(bool& out fSuccess)": {
		"prefix": "ReadInt16",
		"body" : [ "ReadInt16( ${1:bool& out fSuccess} )" ],
		"description" : "Reads an int16 from this BLOB. fSuccess is true if the read succeeded."
	},
	"int32 BLOB::ReadInt32(bool& out fSuccess)": {
		"prefix": "ReadInt32",
		"body" : [ "ReadInt32( ${1:bool& out fSuccess} )" ],
		"description" : "Reads an int32 from this BLOB. fSuccess is true if the read succeeded."
	},
	"int64 BLOB::ReadInt64(bool& out fSuccess)": {
		"prefix": "ReadInt64",
		"body" : [ "ReadInt64( ${1:bool& out fSuccess} )" ],
		"description" : "Reads an int64 from this BLOB. fSuccess is true if the read succeeded."
	},
	"uint8 BLOB::ReadUInt8(bool& out fSuccess)": {
		"prefix": "ReadUInt8",
		"body" : [ "ReadUInt8( ${1:bool& out fSuccess} )" ],
		"description" : "Reads a uint8 from this BLOB. fSuccess is true if the read succeeded."
	},
	"int16 BLOB::ReadUInt16(bool& out fSuccess)": {
		"prefix": "ReadUInt16",
		"body" : [ "ReadUInt16( ${1:bool& out fSuccess} )" ],
		"description" : "Reads a uint16 from this BLOB. fSuccess is true if the read succeeded."
	},
	"int32 BLOB::ReadUInt32(bool& out fSuccess)": {
		"prefix": "ReadUInt32",
		"body" : [ "ReadUInt32( ${1:bool& out fSuccess} )" ],
		"description" : "Reads a uint32 from this BLOB. fSuccess is true if the read succeeded."
	},
	"int64 BLOB::ReadUInt64(bool& out fSuccess)": {
		"prefix": "ReadUInt64",
		"body" : [ "ReadUInt64( ${1:bool& out fSuccess} )" ],
		"description" : "Reads a uint64 from this BLOB. fSuccess is true if the read succeeded."
	},
	"float BLOB::ReadFloat(bool& out fSuccess)": {
		"prefix": "ReadFloat",
		"body" : [ "ReadFloat( ${1:bool& out fSuccess} )" ],
		"description" : "Reads a float from this BLOB. fSuccess is true if the read succeeded."
	},
	"double BLOB::ReadDouble(bool& out fSuccess)": {
		"prefix": "ReadDouble",
		"body" : [ "ReadDouble( ${1:bool& out fSuccess} )" ],
		"description" : "Reads a double from this BLOB. fSuccess is true if the read succeeded."
	},
	"string BLOB::ReadString(size_t uiSizeInBytes)": {
		"prefix": "ReadString",
		"body" : [ "ReadString( ${1:size_t uiSizeInBytes} )" ],
		"description" : "Reads a fixed length string from this BLOB."
	},
	"string BLOB::ReadString(size_t uiSizeInBytes, bool& out fSuccess)": {
		"prefix": "ReadString",
		"body" : [ "ReadString( ${1:size_t uiSizeInBytes}, ${2:bool& out fSuccess} )" ],
		"description" : "Reads a fixed length string from this BLOB. fSuccess is true if the read succeeded."
	},
	"string BLOB::ReadString(bool& out fSuccess)": {
		"prefix": "ReadString",
		"body" : [ "ReadString( ${1:bool& out fSuccess} )" ],
		"description" : "Reads a variable length string from this BLOB. fSuccess is true if the read succeeded."
	},
	"string BLOB::ReadString()": {
		"prefix": "ReadString",
		"body" : [ "ReadString()" ],
		"description" : "Reads a variable length string from this BLOB."
	},
	"bool BLOB::WriteBytes(size_t uiSizeInBytes, int iValue = 0)": {
		"prefix": "WriteBytes",
		"body" : [ "WriteBytes( ${1:size_t uiSizeInBytes}, ${2:int iValue = 0} )" ],
		"description" : "Writes a given value a number of bytes to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::WriteBytesUntil(size_t uiEndOffset, int iValue = 0)": {
		"prefix": "WriteBytesUntil",
		"body" : [ "WriteBytesUntil( ${1:size_t uiEndOffset}, ${2:int iValue = 0} )" ],
		"description" : "Writes a given value until the given end offset to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(int8 data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:int8 data} )" ],
		"description" : "Writes an int8 to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(int16 data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:int16 data} )" ],
		"description" : "Writes an int16 to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(int32 data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:int32 data} )" ],
		"description" : "Writes an int32 to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(int64 data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:int64 data} )" ],
		"description" : "Writes an int64 to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(uint8 data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:uint8 data} )" ],
		"description" : "Writes a uint8 to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(uint16 data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:uint16 data} )" ],
		"description" : "Writes a uint16 to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(uint32 data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:uint32 data} )" ],
		"description" : "Writes a uint32 to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(uint64 data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:uint64 data} )" ],
		"description" : "Writes a uint64 to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(float data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:float data} )" ],
		"description" : "Writes a float to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(double data)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:double data} )" ],
		"description" : "Writes a double to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(const string& in szString, size_t uiSizeInBytes)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:const string& in szString}, ${2:size_t uiSizeInBytes} )" ],
		"description" : "Writes a fixed length string to this BLOB. Returns true if the write succeeded."
	},
	"bool BLOB::Write(const string& in szString)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:const string& in szString} )" ],
		"description" : "Writes a variable length string to this BLOB. Returns true if the write succeeded."
	},
	"void BLOB::Resize(size_t uiNewSize)": {
		"prefix": "Resize",
		"body" : [ "Resize( ${1:size_t uiNewSize} )" ],
		"description" : "Resizes this BLOB. Data may be lost because of this."
	},
	"void BLOB::Reserve(size_t uiMinimumSize)": {
		"prefix": "Reserve",
		"body" : [ "Reserve( ${1:size_t uiMinimumSize} )" ],
		"description" : "Reserves the given amount of space, if needed."
	},
	"void BLOB::ShrinkToFit()": {
		"prefix": "ShrinkToFit",
		"body" : [ "ShrinkToFit()" ],
		"description" : "Shrinks this BLOB to fit the data that was written to it."
	},
	"void BLOB::Clear()": {
		"prefix": "Clear",
		"body" : [ "Clear()" ],
		"description" : "Clears this BLOB of all data and allocated memory. All flags are reset to their default values."
	},
	"enum BLOOD_COLOR {..., DONT_BLEED, ...}": {
		"prefix": "DONT_BLEED",
		"body" : [ "DONT_BLEED" ],
		"description" : "(-1) Don't bleed"
	},
	"enum BLOOD_COLOR {..., BLOOD_COLOR_RED, ...}": {
		"prefix": "BLOOD_COLOR_RED",
		"body" : [ "BLOOD_COLOR_RED" ],
		"description" : "(247) Red blood"
	},
	"enum BLOOD_COLOR {..., BLOOD_COLOR_YELLOW, ...}": {
		"prefix": "BLOOD_COLOR_YELLOW",
		"body" : [ "BLOOD_COLOR_YELLOW" ],
		"description" : "(195) Yellow blood"
	},
	"enum BLOOD_COLOR {..., BLOOD_COLOR_GREEN, ...}": {
		"prefix": "BLOOD_COLOR_GREEN",
		"body" : [ "BLOOD_COLOR_GREEN" ],
		"description" : "(195) Green blood"
	},
	"enum BREAK {..., BREAK_TYPEMASK, ...}": {
		"prefix": "BREAK_TYPEMASK",
		"body" : [ "BREAK_TYPEMASK" ],
		"description" : "(79) Bit mask for all BREAK types."
	},
	"enum BREAK {..., BREAK_GLASS, ...}": {
		"prefix": "BREAK_GLASS",
		"body" : [ "BREAK_GLASS" ],
		"description" : "(1)"
	},
	"enum BREAK {..., BREAK_METAL, ...}": {
		"prefix": "BREAK_METAL",
		"body" : [ "BREAK_METAL" ],
		"description" : "(2)"
	},
	"enum BREAK {..., BREAK_FLESH, ...}": {
		"prefix": "BREAK_FLESH",
		"body" : [ "BREAK_FLESH" ],
		"description" : "(4)"
	},
	"enum BREAK {..., BREAK_WOOD, ...}": {
		"prefix": "BREAK_WOOD",
		"body" : [ "BREAK_WOOD" ],
		"description" : "(8)"
	},
	"enum BREAK {..., BREAK_SMOKE, ...}": {
		"prefix": "BREAK_SMOKE",
		"body" : [ "BREAK_SMOKE" ],
		"description" : "(16) Adds a smoke trail"
	},
	"enum BREAK {..., BREAK_TRANS, ...}": {
		"prefix": "BREAK_TRANS",
		"body" : [ "BREAK_TRANS" ],
		"description" : "(32) Model is transparent"
	},
	"enum BREAK {..., BREAK_CONCRETE, ...}": {
		"prefix": "BREAK_CONCRETE",
		"body" : [ "BREAK_CONCRETE" ],
		"description" : "(64)"
	},
	"enum BREAK {..., BREAK_2, ...}": {
		"prefix": "BREAK_2",
		"body" : [ "BREAK_2" ],
		"description" : "(128) Not used"
	},
	"enum Bullet {..., BULLET_NONE, ...}": {
		"prefix": "BULLET_NONE",
		"body" : [ "BULLET_NONE" ],
		"description" : "(0)"
	},
	"enum Bullet {..., BULLET_PLAYER_9MM, ...}": {
		"prefix": "BULLET_PLAYER_9MM",
		"body" : [ "BULLET_PLAYER_9MM" ],
		"description" : "(1) Glock"
	},
	"enum Bullet {..., BULLET_PLAYER_MP5, ...}": {
		"prefix": "BULLET_PLAYER_MP5",
		"body" : [ "BULLET_PLAYER_MP5" ],
		"description" : "(2) mp5"
	},
	"enum Bullet {..., BULLET_PLAYER_SAW, ...}": {
		"prefix": "BULLET_PLAYER_SAW",
		"body" : [ "BULLET_PLAYER_SAW" ],
		"description" : "(3)"
	},
	"enum Bullet {..., BULLET_PLAYER_SNIPER, ...}": {
		"prefix": "BULLET_PLAYER_SNIPER",
		"body" : [ "BULLET_PLAYER_SNIPER" ],
		"description" : "(4)"
	},
	"enum Bullet {..., BULLET_PLAYER_357, ...}": {
		"prefix": "BULLET_PLAYER_357",
		"body" : [ "BULLET_PLAYER_357" ],
		"description" : "(5) Python"
	},
	"enum Bullet {..., BULLET_PLAYER_EAGLE, ...}": {
		"prefix": "BULLET_PLAYER_EAGLE",
		"body" : [ "BULLET_PLAYER_EAGLE" ],
		"description" : "(6) Desert eagle"
	},
	"enum Bullet {..., BULLET_PLAYER_BUCKSHOT, ...}": {
		"prefix": "BULLET_PLAYER_BUCKSHOT",
		"body" : [ "BULLET_PLAYER_BUCKSHOT" ],
		"description" : "(7) Shotgun"
	},
	"enum Bullet {..., BULLET_PLAYER_CROWBAR, ...}": {
		"prefix": "BULLET_PLAYER_CROWBAR",
		"body" : [ "BULLET_PLAYER_CROWBAR" ],
		"description" : "(8)"
	},
	"enum Bullet {..., BULLET_PLAYER_CUSTOMDAMAGE, ...}": {
		"prefix": "BULLET_PLAYER_CUSTOMDAMAGE",
		"body" : [ "BULLET_PLAYER_CUSTOMDAMAGE" ],
		"description" : "(9) normal bullet with custom damage"
	},
	"enum Bullet {..., BULLET_MONSTER_9MM, ...}": {
		"prefix": "BULLET_MONSTER_9MM",
		"body" : [ "BULLET_MONSTER_9MM" ],
		"description" : "(10)"
	},
	"enum Bullet {..., BULLET_MONSTER_MP5, ...}": {
		"prefix": "BULLET_MONSTER_MP5",
		"body" : [ "BULLET_MONSTER_MP5" ],
		"description" : "(11)"
	},
	"enum Bullet {..., BULLET_MONSTER_SAW, ...}": {
		"prefix": "BULLET_MONSTER_SAW",
		"body" : [ "BULLET_MONSTER_SAW" ],
		"description" : "(12)"
	},
	"enum Bullet {..., BULLET_MONSTER_12MM, ...}": {
		"prefix": "BULLET_MONSTER_12MM",
		"body" : [ "BULLET_MONSTER_12MM" ],
		"description" : "(13)"
	},
	"enum Bullet {..., BULLET_MONSTER_EAGLE, ...}": {
		"prefix": "BULLET_MONSTER_EAGLE",
		"body" : [ "BULLET_MONSTER_EAGLE" ],
		"description" : "(14)"
	},
	"enum Bullet {..., BULLET_MONSTER_SNIPER, ...}": {
		"prefix": "BULLET_MONSTER_SNIPER",
		"body" : [ "BULLET_MONSTER_SNIPER" ],
		"description" : "(15)"
	},
	"enum Bullet {..., BULLET_MONSTER_BUCKSHOT, ...}": {
		"prefix": "BULLET_MONSTER_BUCKSHOT",
		"body" : [ "BULLET_MONSTER_BUCKSHOT" ],
		"description" : "(16) Monster shotgun"
	},
	"enum Bullet {..., DECAL_SCORCH_MARK, ...}": {
		"prefix": "DECAL_SCORCH_MARK",
		"body" : [ "DECAL_SCORCH_MARK" ],
		"description" : "(17)"
	},
	"enum ButtonCode {..., BUTTON_NOTHING, ...}": {
		"prefix": "BUTTON_NOTHING",
		"body" : [ "BUTTON_NOTHING" ],
		"description" : "(0) Do nothing"
	},
	"enum ButtonCode {..., BUTTON_ACTIVATE, ...}": {
		"prefix": "BUTTON_ACTIVATE",
		"body" : [ "BUTTON_ACTIVATE" ],
		"description" : "(1) Activate the button"
	},
	"enum ButtonCode {..., BUTTON_RETURN, ...}": {
		"prefix": "BUTTON_RETURN",
		"body" : [ "BUTTON_RETURN" ],
		"description" : "(2) Return the button to its default state"
	},
	"string CActivityMap::GetName(Activity activity) const": {
		"prefix": "GetName",
		"body" : [ "GetName( ${1:Activity activity} )" ],
		"description" : "Gets the name of the given activity"
	},
	"void CAdminControl::SetReservedSlots(uint uiReservedSlots)": {
		"prefix": "SetReservedSlots",
		"body" : [ "SetReservedSlots( ${1:uint uiReservedSlots} )" ],
		"description" : "Sets the number of reserved slots."
	},
	"uint CAdminControl::GetReservedSlots() const": {
		"prefix": "GetReservedSlots",
		"body" : [ "GetReservedSlots()" ],
		"description" : "Gets the number of reserved slots."
	},
	"bool CAdminControl::KillPlayer(CBasePlayer@ pKiller, CBasePlayer@ pKillee, float flRespawntime = -1.0f)": {
		"prefix": "KillPlayer",
		"body" : [ "KillPlayer( ${1:CBasePlayer@ pKiller}, ${2:CBasePlayer@ pKillee}, ${3:float flRespawntime = -1.0f} )" ],
		"description" : "Kills the given player. Killing player must have admin rights. Target player cannot be an admin."
	},
	"bool CAdminControl::KillPlayer(CBasePlayer@ pKillee, float flRespawntime = -1.0f)": {
		"prefix": "KillPlayer",
		"body" : [ "KillPlayer( ${1:CBasePlayer@ pKillee}, ${2:float flRespawntime = -1.0f} )" ],
		"description" : "Kills the given player."
	},
	"bool CAdminControl::KickPlayer(CBasePlayer@ pKicker, CBasePlayer@ pKickee, const float flCustomBanTime = -1)": {
		"prefix": "KickPlayer",
		"body" : [ "KickPlayer( ${1:CBasePlayer@ pKicker}, ${2:CBasePlayer@ pKickee}, ${3:const float flCustomBanTime = -1} )" ],
		"description" : "Kicks the given player. Kicking player must have admin rights. Target player cannot be an admin."
	},
	"bool CAdminControl::KickPlayer(CBasePlayer@ pKickee, const float flCustomBanTime = -1)": {
		"prefix": "KickPlayer",
		"body" : [ "KickPlayer( ${1:CBasePlayer@ pKickee}, ${2:const float flCustomBanTime = -1} )" ],
		"description" : "Kicks the given player."
	},
	"bool CAdminControl::BanPlayer(CBasePlayer@ pBanner, CBasePlayer@ pBannee, const float flCustomBanTime = -1)": {
		"prefix": "BanPlayer",
		"body" : [ "BanPlayer( ${1:CBasePlayer@ pBanner}, ${2:CBasePlayer@ pBannee}, ${3:const float flCustomBanTime = -1} )" ],
		"description" : "Bans the given player. Banning player must have admin rights Target player cannot be an admin."
	},
	"bool CAdminControl::BanPlayer(CBasePlayer@ pBannee, const float flCustomBanTime = -1)": {
		"prefix": "BanPlayer",
		"body" : [ "BanPlayer( ${1:CBasePlayer@ pBannee}, ${2:const float flCustomBanTime = -1} )" ],
		"description" : "Bans the given player."
	},
	"bool CAdminControl::SlapPlayer(CBasePlayer@ pSlapper, CBasePlayer@ pSlappee, float flDamage, const Vector& in vecDirection, int iDamageType = 0)": {
		"prefix": "SlapPlayer",
		"body" : [ "SlapPlayer( ${1:CBasePlayer@ pSlapper}, ${2:CBasePlayer@ pSlappee}, ${3:float flDamage}, ${4:const Vector& in vecDirection}, ${5:int iDamageType = 0} )" ],
		"description" : "Slaps the given player. Slapping player must have admin rights. Target player cannot be an admin."
	},
	"bool CAdminControl::SlapPlayer(CBasePlayer@ pSlappee, float flDamage, const Vector& in vecDirection, int iDamageType = 0)": {
		"prefix": "SlapPlayer",
		"body" : [ "SlapPlayer( ${1:CBasePlayer@ pSlappee}, ${2:float flDamage}, ${3:const Vector& in vecDirection}, ${4:int iDamageType = 0} )" ],
		"description" : "Slaps the given player."
	},
	"bool CAdminControl::SlapPlayer(CBasePlayer@ pSlapper, CBasePlayer@ pSlappee, float flDamage, int iDamageType = 0)": {
		"prefix": "SlapPlayer",
		"body" : [ "SlapPlayer( ${1:CBasePlayer@ pSlapper}, ${2:CBasePlayer@ pSlappee}, ${3:float flDamage}, ${4:int iDamageType = 0} )" ],
		"description" : "Slaps the given player. Slapping player must have admin rights. Target player cannot be an admin. Slap direction is randomized."
	},
	"bool CAdminControl::SlapPlayer(CBasePlayer@ pSlappee, float flDamage, int iDamageType = 0)": {
		"prefix": "SlapPlayer",
		"body" : [ "SlapPlayer( ${1:CBasePlayer@ pSlappee}, ${2:float flDamage}, ${3:int iDamageType = 0} )" ],
		"description" : "Slaps the given player. Slap direction is randomized."
	},
	"string Reflection::Callable::GetNamespace() const": {
		"prefix": "GetNamespace",
		"body" : [ "GetNamespace()" ],
		"description" : "Gets this instance's namespace."
	},
	"string Reflection::Callable::GetName() const": {
		"prefix": "GetName",
		"body" : [ "GetName()" ],
		"description" : "Gets this instance's name."
	},
	"bool Reflection::Callable::Equals(const Callable@ pCallable) const": {
		"prefix": "Equals",
		"body" : [ "Equals( ${1:const Callable@ pCallable} )" ],
		"description" : "Returns whether the given callable type is identical to this one."
	},
	"bool Reflection::Callable::IsCompatible(const Callable@ pCallable) const": {
		"prefix": "IsCompatible",
		"body" : [ "IsCompatible( ${1:const Callable@ pCallable} )" ],
		"description" : "Returns whether the given object type is compatible with this one."
	},
	"Function@ Reflection::Callable::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"Method@ Reflection::Callable::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"string CAngelscript::GetAngelscriptDescription() const": {
		"prefix": "GetAngelscriptDescription",
		"body" : [ "GetAngelscriptDescription()" ],
		"description" : "Returns a brief description of Angelscript"
	},
	"string CAngelscript::GetAngelscriptVersionString() const": {
		"prefix": "GetAngelscriptVersionString",
		"body" : [ "GetAngelscriptVersionString()" ],
		"description" : "Gets the current version of Angelscript as a string"
	},
	"uint CAngelscript::GetAngelscriptVersion() const": {
		"prefix": "GetAngelscriptVersion",
		"body" : [ "GetAngelscriptVersion()" ],
		"description" : "Gets the current version of Angelscript"
	},
	"uint CAngelscript::GetMajorVersion() const": {
		"prefix": "GetMajorVersion",
		"body" : [ "GetMajorVersion()" ],
		"description" : "Gets the major version of the Angelscript Sven Co-op implementation"
	},
	"uint CAngelscript::GetMinorVersion() const": {
		"prefix": "GetMinorVersion",
		"body" : [ "GetMinorVersion()" ],
		"description" : "Gets the minor version of the Angelscript Sven Co-op implementation"
	},
	"CBaseDelay@ CBaseAnimating::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CBaseAnimating::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBaseAnimating::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBaseAnimating::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBaseAnimating::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBaseAnimating::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBaseAnimating::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBaseAnimating::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBaseAnimating::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBaseAnimating::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBaseAnimating::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBaseAnimating::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBaseAnimating::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBaseAnimating::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBaseAnimating::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBaseAnimating::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBaseAnimating::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBaseAnimating::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBaseAnimating::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBaseAnimating::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBaseAnimating::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBaseAnimating::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBaseAnimating::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBaseAnimating::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBaseAnimating::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBaseAnimating::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBaseAnimating::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBaseAnimating::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBaseAnimating::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBaseAnimating::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBaseAnimating::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBaseAnimating::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBaseAnimating::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBaseAnimating::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBaseAnimating::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBaseAnimating::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBaseAnimating::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBaseAnimating::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBaseAnimating::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBaseAnimating::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBaseAnimating::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBaseAnimating::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBaseAnimating::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBaseAnimating::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBaseAnimating::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBaseAnimating::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBaseAnimating::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBaseAnimating::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBaseAnimating::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBaseAnimating::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBaseAnimating::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBaseAnimating::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBaseAnimating::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBaseAnimating::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBaseAnimating::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBaseAnimating::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBaseAnimating::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBaseAnimating::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBaseAnimating::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBaseAnimating::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBaseAnimating::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBaseAnimating::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBaseAnimating::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBaseAnimating::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBaseAnimating::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBaseAnimating::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBaseAnimating::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBaseAnimating::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBaseAnimating::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBaseAnimating::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBaseAnimating::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBaseAnimating::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBaseAnimating::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBaseAnimating::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBaseAnimating::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBaseAnimating::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBaseAnimating::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBaseAnimating::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBaseAnimating::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBaseAnimating::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBaseAnimating::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBaseAnimating::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBaseAnimating::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBaseAnimating::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBaseAnimating::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBaseAnimating::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBaseAnimating::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBaseAnimating::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBaseAnimating::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBaseAnimating::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBaseAnimating::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBaseAnimating::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBaseAnimating::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBaseAnimating::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBaseAnimating::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBaseAnimating::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBaseAnimating::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBaseAnimating::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBaseAnimating::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBaseAnimating::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBaseAnimating::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBaseAnimating::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBaseAnimating::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBaseAnimating::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBaseAnimating::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBaseAnimating::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBaseAnimating::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CBaseAnimating::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CBaseAnimating::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CBaseAnimating::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CBaseAnimating::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CBaseAnimating::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CBaseAnimating::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CBaseAnimating::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CBaseAnimating::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CBaseAnimating::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CBaseAnimating::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CBaseAnimating::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CBaseAnimating::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CBaseAnimating::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CBaseAnimating::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CBaseAnimating::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CBaseAnimating::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CBaseAnimating::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CBaseAnimating::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CBaseAnimating::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CBaseAnimating::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CBaseAnimating::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CBaseAnimating::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"CBaseToggle@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayerItem@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseMonster@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CCineMonster@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayer@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CGrenade@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayerWeapon@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseButton@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseDoor@ CBaseAnimating::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"entvars_t@ CBaseAnimating::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBaseAnimating::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBaseAnimating::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBaseAnimating::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBaseAnimating::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBaseAnimating::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBaseAnimating::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBaseAnimating::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBaseAnimating::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBaseAnimating::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBaseAnimating::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBaseAnimating::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBaseAnimating::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBaseAnimating::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBaseAnimating::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBaseAnimating::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBaseAnimating::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBaseAnimating::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CBaseAnimating::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CBaseAnimating::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CBaseAnimating::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CBaseAnimating::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CBaseAnimating::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CBaseAnimating::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"CBaseToggle@ CBaseButton::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseAnimating@ CBaseButton::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CBaseButton::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CBaseButton::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBaseButton::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBaseButton::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBaseButton::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBaseButton::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBaseButton::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBaseButton::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBaseButton::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBaseButton::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBaseButton::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBaseButton::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBaseButton::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBaseButton::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBaseButton::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBaseButton::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBaseButton::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBaseButton::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBaseButton::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBaseButton::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBaseButton::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBaseButton::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBaseButton::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBaseButton::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBaseButton::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBaseButton::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBaseButton::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBaseButton::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBaseButton::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBaseButton::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBaseButton::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBaseButton::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBaseButton::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBaseButton::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBaseButton::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBaseButton::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBaseButton::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBaseButton::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBaseButton::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBaseButton::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBaseButton::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBaseButton::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBaseButton::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBaseButton::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBaseButton::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBaseButton::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBaseButton::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBaseButton::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBaseButton::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBaseButton::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBaseButton::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBaseButton::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBaseButton::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBaseButton::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBaseButton::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBaseButton::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBaseButton::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBaseButton::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBaseButton::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBaseButton::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBaseButton::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBaseButton::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBaseButton::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBaseButton::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBaseButton::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBaseButton::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBaseButton::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBaseButton::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBaseButton::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBaseButton::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBaseButton::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBaseButton::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBaseButton::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBaseButton::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBaseButton::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBaseButton::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBaseButton::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBaseButton::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBaseButton::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBaseButton::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBaseButton::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBaseButton::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBaseButton::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBaseButton::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBaseButton::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBaseButton::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBaseButton::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBaseButton::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBaseButton::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBaseButton::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBaseButton::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBaseButton::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBaseButton::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBaseButton::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBaseButton::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBaseButton::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBaseButton::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBaseButton::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBaseButton::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBaseButton::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBaseButton::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBaseButton::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBaseButton::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBaseButton::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBaseButton::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBaseButton::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBaseButton::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CBaseButton::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CBaseButton::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CBaseButton::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CBaseButton::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CBaseButton::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CBaseButton::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CBaseButton::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CBaseButton::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CBaseButton::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CBaseButton::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CBaseButton::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CBaseButton::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CBaseButton::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CBaseButton::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CBaseButton::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CBaseButton::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CBaseButton::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CBaseButton::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CBaseButton::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CBaseButton::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CBaseButton::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CBaseButton::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"void CBaseButton::LinearMove(Vector vecDest, float flSpeed)": {
		"prefix": "LinearMove",
		"body" : [ "LinearMove( ${1:Vector vecDest}, ${2:float flSpeed} )" ],
		"description" : "Performs linear movement."
	},
	"void CBaseButton::AngularMove(Vector vecDestAngle, float flSpeed)": {
		"prefix": "AngularMove",
		"body" : [ "AngularMove( ${1:Vector vecDestAngle}, ${2:float flSpeed} )" ],
		"description" : "Performs angular movement."
	},
	"bool CBaseButton::IsToggleLockedByMaster()": {
		"prefix": "IsToggleLockedByMaster",
		"body" : [ "IsToggleLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master. Separate from IsLockedByMaster due to limitations."
	},
	"InventoryRules@ CBaseButton::get_m_pInventoryRules() const": {
		"prefix": "get_m_pInventoryRules",
		"body" : [ "get_m_pInventoryRules()" ],
		"description" : "The inventory rules."
	},
	"void CBaseButton::ButtonActivate()": {
		"prefix": "ButtonActivate",
		"body" : [ "ButtonActivate()" ],
		"description" : "Activates the button."
	},
	"void CBaseButton::ButtonTouch(CBaseEntity@ pOther)": {
		"prefix": "ButtonTouch",
		"body" : [ "ButtonTouch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Button Touch function."
	},
	"void CBaseButton::ButtonSpark()": {
		"prefix": "ButtonSpark",
		"body" : [ "ButtonSpark()" ],
		"description" : "Makes the button start sparking. The button will spark randomly after this."
	},
	"void CBaseButton::TriggerAndWait()": {
		"prefix": "TriggerAndWait",
		"body" : [ "TriggerAndWait()" ],
		"description" : "Button has reached the \"in/up\" position.  Activate its \"targets\", and pause before \"popping out\"."
	},
	"void CBaseButton::ButtonReturn()": {
		"prefix": "ButtonReturn",
		"body" : [ "ButtonReturn()" ],
		"description" : "Starts the button moving \"out/down\"."
	},
	"void CBaseButton::ButtonBackHome()": {
		"prefix": "ButtonBackHome",
		"body" : [ "ButtonBackHome()" ],
		"description" : "Button has returned to start state.  Quiesce it."
	},
	"void CBaseButton::ButtonUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)": {
		"prefix": "ButtonUse",
		"body" : [ "ButtonUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue} )" ],
		"description" : "Button Use function."
	},
	"ButtonCode CBaseButton::ButtonResponseToTouch()": {
		"prefix": "ButtonResponseToTouch",
		"body" : [ "ButtonResponseToTouch()" ],
		"description" : "Gets the button response to a touch event."
	},
	"entvars_t@ CBaseButton::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBaseButton::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBaseButton::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBaseButton::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBaseButton::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBaseButton::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBaseButton::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBaseButton::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBaseButton::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBaseButton::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBaseButton::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBaseButton::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBaseButton::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBaseButton::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBaseButton::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBaseButton::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBaseButton::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBaseButton::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CBaseButton::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CBaseButton::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CBaseButton::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CBaseButton::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CBaseButton::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CBaseButton::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"TOGGLE_STATE CBaseButton::m_toggle_state": {
		"prefix": "m_toggle_state",
		"body" : [ "m_toggle_state" ],
		"description" : "Current toggle state."
	},
	"float CBaseButton::m_flMoveDistance": {
		"prefix": "m_flMoveDistance",
		"body" : [ "m_flMoveDistance" ],
		"description" : "How far a door should slide or rotate."
	},
	"float CBaseButton::m_flWait": {
		"prefix": "m_flWait",
		"body" : [ "m_flWait" ],
		"description" : "How long to wait before resetting."
	},
	"float CBaseButton::m_flLip": {
		"prefix": "m_flLip",
		"body" : [ "m_flLip" ],
		"description" : "How much to stick out of a wall. Will recede further into walls if negative."
	},
	"float CBaseButton::m_flTWidth": {
		"prefix": "m_flTWidth",
		"body" : [ "m_flTWidth" ],
		"description" : "For plats."
	},
	"float CBaseButton::m_flTLength": {
		"prefix": "m_flTLength",
		"body" : [ "m_flTLength" ],
		"description" : "For plats."
	},
	"int CBaseButton::m_cTriggersLeft": {
		"prefix": "m_cTriggersLeft",
		"body" : [ "m_cTriggersLeft" ],
		"description" : "Trigger_counter only: # of activations remaining."
	},
	"float CBaseButton::m_flHeight": {
		"prefix": "m_flHeight",
		"body" : [ "m_flHeight" ],
		"description" : "Height."
	},
	"EHandle CBaseButton::m_hActivator": {
		"prefix": "m_hActivator",
		"body" : [ "m_hActivator" ],
		"description" : "Handle to the activator."
	},
	"Vector CBaseButton::m_vecPosition1": {
		"prefix": "m_vecPosition1",
		"body" : [ "m_vecPosition1" ],
		"description" : "Closed position."
	},
	"Vector CBaseButton::m_vecPosition2": {
		"prefix": "m_vecPosition2",
		"body" : [ "m_vecPosition2" ],
		"description" : "Open position."
	},
	"Vector CBaseButton::m_vecAngle1": {
		"prefix": "m_vecAngle1",
		"body" : [ "m_vecAngle1" ],
		"description" : "Closed angle."
	},
	"Vector CBaseButton::m_vecAngle2": {
		"prefix": "m_vecAngle2",
		"body" : [ "m_vecAngle2" ],
		"description" : "Open angle."
	},
	"Vector CBaseButton::m_vecFinalDest": {
		"prefix": "m_vecFinalDest",
		"body" : [ "m_vecFinalDest" ],
		"description" : "Final destination."
	},
	"Vector CBaseButton::m_vecFinalAngle": {
		"prefix": "m_vecFinalAngle",
		"body" : [ "m_vecFinalAngle" ],
		"description" : "Final angle."
	},
	"int CBaseButton::m_bitsDamageInflict": {
		"prefix": "m_bitsDamageInflict",
		"body" : [ "m_bitsDamageInflict" ],
		"description" : "DMG_ damage type that the door or trigger does."
	},
	"string_t CBaseButton::m_sMaster": {
		"prefix": "m_sMaster",
		"body" : [ "m_sMaster" ],
		"description" : "This entity's master, if any."
	},
	"bool CBaseButton::m_fStayPushed": {
		"prefix": "m_fStayPushed",
		"body" : [ "m_fStayPushed" ],
		"description" : "button stays pushed in until touched again?"
	},
	"bool CBaseButton::m_fRotating": {
		"prefix": "m_fRotating",
		"body" : [ "m_fRotating" ],
		"description" : "a rotating button?  default is a sliding button."
	},
	"CBaseEntity@ CBaseDelay::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBaseDelay::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBaseDelay::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBaseDelay::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBaseDelay::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBaseDelay::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBaseDelay::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBaseDelay::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBaseDelay::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBaseDelay::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBaseDelay::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBaseDelay::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBaseDelay::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBaseDelay::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBaseDelay::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBaseDelay::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBaseDelay::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBaseDelay::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBaseDelay::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBaseDelay::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBaseDelay::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBaseDelay::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBaseDelay::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBaseDelay::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBaseDelay::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBaseDelay::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBaseDelay::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBaseDelay::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBaseDelay::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBaseDelay::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBaseDelay::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBaseDelay::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBaseDelay::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBaseDelay::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBaseDelay::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBaseDelay::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBaseDelay::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBaseDelay::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBaseDelay::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBaseDelay::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBaseDelay::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBaseDelay::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBaseDelay::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBaseDelay::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBaseDelay::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBaseDelay::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBaseDelay::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBaseDelay::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBaseDelay::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBaseDelay::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBaseDelay::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBaseDelay::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBaseDelay::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBaseDelay::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBaseDelay::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBaseDelay::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBaseDelay::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBaseDelay::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBaseDelay::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBaseDelay::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBaseDelay::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBaseDelay::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBaseDelay::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBaseDelay::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBaseDelay::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBaseDelay::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBaseDelay::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBaseDelay::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBaseDelay::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBaseDelay::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBaseDelay::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBaseDelay::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBaseDelay::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBaseDelay::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBaseDelay::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBaseDelay::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBaseDelay::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBaseDelay::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBaseDelay::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBaseDelay::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBaseDelay::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBaseDelay::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBaseDelay::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBaseDelay::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBaseDelay::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBaseDelay::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBaseDelay::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBaseDelay::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBaseDelay::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBaseDelay::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBaseDelay::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBaseDelay::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBaseDelay::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBaseDelay::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBaseDelay::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBaseDelay::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBaseDelay::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBaseDelay::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBaseDelay::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBaseDelay::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBaseDelay::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBaseDelay::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBaseDelay::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBaseDelay::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBaseDelay::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBaseDelay::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"CBaseAnimating@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseToggle@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayerItem@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseMonster@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CCineMonster@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayer@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CGrenade@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayerWeapon@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseButton@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseDoor@ CBaseDelay::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"entvars_t@ CBaseDelay::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBaseDelay::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBaseDelay::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBaseDelay::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBaseDelay::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBaseDelay::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBaseDelay::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBaseDelay::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBaseDelay::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBaseDelay::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBaseDelay::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBaseDelay::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBaseDelay::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBaseDelay::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBaseDelay::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBaseDelay::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBaseDelay::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBaseDelay::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"CBaseToggle@ CBaseDoor::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseAnimating@ CBaseDoor::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CBaseDoor::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CBaseDoor::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBaseDoor::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBaseDoor::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBaseDoor::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBaseDoor::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBaseDoor::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBaseDoor::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBaseDoor::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBaseDoor::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBaseDoor::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBaseDoor::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBaseDoor::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBaseDoor::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBaseDoor::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBaseDoor::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBaseDoor::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBaseDoor::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBaseDoor::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBaseDoor::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBaseDoor::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBaseDoor::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBaseDoor::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBaseDoor::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBaseDoor::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBaseDoor::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBaseDoor::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBaseDoor::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBaseDoor::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBaseDoor::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBaseDoor::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBaseDoor::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBaseDoor::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBaseDoor::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBaseDoor::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBaseDoor::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBaseDoor::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBaseDoor::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBaseDoor::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBaseDoor::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBaseDoor::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBaseDoor::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBaseDoor::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBaseDoor::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBaseDoor::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBaseDoor::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBaseDoor::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBaseDoor::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBaseDoor::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBaseDoor::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBaseDoor::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBaseDoor::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBaseDoor::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBaseDoor::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBaseDoor::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBaseDoor::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBaseDoor::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBaseDoor::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBaseDoor::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBaseDoor::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBaseDoor::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBaseDoor::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBaseDoor::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBaseDoor::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBaseDoor::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBaseDoor::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBaseDoor::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBaseDoor::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBaseDoor::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBaseDoor::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBaseDoor::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBaseDoor::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBaseDoor::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBaseDoor::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBaseDoor::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBaseDoor::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBaseDoor::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBaseDoor::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBaseDoor::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBaseDoor::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBaseDoor::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBaseDoor::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBaseDoor::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBaseDoor::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBaseDoor::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBaseDoor::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBaseDoor::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBaseDoor::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBaseDoor::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBaseDoor::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBaseDoor::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBaseDoor::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBaseDoor::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBaseDoor::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBaseDoor::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBaseDoor::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBaseDoor::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBaseDoor::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBaseDoor::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBaseDoor::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBaseDoor::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBaseDoor::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBaseDoor::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBaseDoor::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBaseDoor::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBaseDoor::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBaseDoor::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CBaseDoor::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CBaseDoor::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CBaseDoor::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CBaseDoor::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CBaseDoor::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CBaseDoor::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CBaseDoor::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CBaseDoor::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CBaseDoor::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CBaseDoor::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CBaseDoor::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CBaseDoor::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CBaseDoor::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CBaseDoor::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CBaseDoor::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CBaseDoor::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CBaseDoor::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CBaseDoor::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CBaseDoor::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CBaseDoor::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CBaseDoor::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CBaseDoor::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"void CBaseDoor::LinearMove(Vector vecDest, float flSpeed)": {
		"prefix": "LinearMove",
		"body" : [ "LinearMove( ${1:Vector vecDest}, ${2:float flSpeed} )" ],
		"description" : "Performs linear movement."
	},
	"void CBaseDoor::AngularMove(Vector vecDestAngle, float flSpeed)": {
		"prefix": "AngularMove",
		"body" : [ "AngularMove( ${1:Vector vecDestAngle}, ${2:float flSpeed} )" ],
		"description" : "Performs angular movement."
	},
	"bool CBaseDoor::IsToggleLockedByMaster()": {
		"prefix": "IsToggleLockedByMaster",
		"body" : [ "IsToggleLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master. Separate from IsLockedByMaster due to limitations."
	},
	"InventoryRules@ CBaseDoor::get_m_pInventoryRules() const": {
		"prefix": "get_m_pInventoryRules",
		"body" : [ "get_m_pInventoryRules()" ],
		"description" : "The inventory rules."
	},
	"void CBaseDoor::DoorTouch(CBaseEntity@ pOther)": {
		"prefix": "DoorTouch",
		"body" : [ "DoorTouch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Door touch function."
	},
	"void CBaseDoor::DoorGoUp()": {
		"prefix": "DoorGoUp",
		"body" : [ "DoorGoUp()" ],
		"description" : "Makes the door go up."
	},
	"void CBaseDoor::DoorGoDown()": {
		"prefix": "DoorGoDown",
		"body" : [ "DoorGoDown()" ],
		"description" : "Makes the door go down."
	},
	"bool CBaseDoor::DoorChangeDirection()": {
		"prefix": "DoorChangeDirection",
		"body" : [ "DoorChangeDirection()" ],
		"description" : "If the door is moving, changes the movement direction. Returns true if the door was moving."
	},
	"entvars_t@ CBaseDoor::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBaseDoor::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBaseDoor::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBaseDoor::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBaseDoor::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBaseDoor::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBaseDoor::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBaseDoor::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBaseDoor::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBaseDoor::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBaseDoor::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBaseDoor::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBaseDoor::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBaseDoor::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBaseDoor::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBaseDoor::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBaseDoor::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBaseDoor::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CBaseDoor::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CBaseDoor::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CBaseDoor::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CBaseDoor::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CBaseDoor::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CBaseDoor::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"TOGGLE_STATE CBaseDoor::m_toggle_state": {
		"prefix": "m_toggle_state",
		"body" : [ "m_toggle_state" ],
		"description" : "Current toggle state."
	},
	"float CBaseDoor::m_flMoveDistance": {
		"prefix": "m_flMoveDistance",
		"body" : [ "m_flMoveDistance" ],
		"description" : "How far a door should slide or rotate."
	},
	"float CBaseDoor::m_flWait": {
		"prefix": "m_flWait",
		"body" : [ "m_flWait" ],
		"description" : "How long to wait before resetting."
	},
	"float CBaseDoor::m_flLip": {
		"prefix": "m_flLip",
		"body" : [ "m_flLip" ],
		"description" : "How much to stick out of a wall. Will recede further into walls if negative."
	},
	"float CBaseDoor::m_flTWidth": {
		"prefix": "m_flTWidth",
		"body" : [ "m_flTWidth" ],
		"description" : "For plats."
	},
	"float CBaseDoor::m_flTLength": {
		"prefix": "m_flTLength",
		"body" : [ "m_flTLength" ],
		"description" : "For plats."
	},
	"int CBaseDoor::m_cTriggersLeft": {
		"prefix": "m_cTriggersLeft",
		"body" : [ "m_cTriggersLeft" ],
		"description" : "Trigger_counter only: # of activations remaining."
	},
	"float CBaseDoor::m_flHeight": {
		"prefix": "m_flHeight",
		"body" : [ "m_flHeight" ],
		"description" : "Height."
	},
	"EHandle CBaseDoor::m_hActivator": {
		"prefix": "m_hActivator",
		"body" : [ "m_hActivator" ],
		"description" : "Handle to the activator."
	},
	"Vector CBaseDoor::m_vecPosition1": {
		"prefix": "m_vecPosition1",
		"body" : [ "m_vecPosition1" ],
		"description" : "Closed position."
	},
	"Vector CBaseDoor::m_vecPosition2": {
		"prefix": "m_vecPosition2",
		"body" : [ "m_vecPosition2" ],
		"description" : "Open position."
	},
	"Vector CBaseDoor::m_vecAngle1": {
		"prefix": "m_vecAngle1",
		"body" : [ "m_vecAngle1" ],
		"description" : "Closed angle."
	},
	"Vector CBaseDoor::m_vecAngle2": {
		"prefix": "m_vecAngle2",
		"body" : [ "m_vecAngle2" ],
		"description" : "Open angle."
	},
	"Vector CBaseDoor::m_vecFinalDest": {
		"prefix": "m_vecFinalDest",
		"body" : [ "m_vecFinalDest" ],
		"description" : "Final destination."
	},
	"Vector CBaseDoor::m_vecFinalAngle": {
		"prefix": "m_vecFinalAngle",
		"body" : [ "m_vecFinalAngle" ],
		"description" : "Final angle."
	},
	"int CBaseDoor::m_bitsDamageInflict": {
		"prefix": "m_bitsDamageInflict",
		"body" : [ "m_bitsDamageInflict" ],
		"description" : "DMG_ damage type that the door or trigger does."
	},
	"string_t CBaseDoor::m_sMaster": {
		"prefix": "m_sMaster",
		"body" : [ "m_sMaster" ],
		"description" : "This entity's master, if any."
	},
	"CItemInventory@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"const Vector& CBaseEntity::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBaseEntity::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBaseEntity::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBaseEntity::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBaseEntity::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBaseEntity::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBaseEntity::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBaseEntity::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBaseEntity::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBaseEntity::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBaseEntity::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBaseEntity::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBaseEntity::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBaseEntity::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBaseEntity::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBaseEntity::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBaseEntity::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBaseEntity::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBaseEntity::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBaseEntity::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBaseEntity::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBaseEntity::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBaseEntity::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBaseEntity::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBaseEntity::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBaseEntity::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBaseEntity::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBaseEntity::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBaseEntity::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBaseEntity::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBaseEntity::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBaseEntity::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBaseEntity::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBaseEntity::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBaseEntity::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBaseEntity::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBaseEntity::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBaseEntity::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBaseEntity::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBaseEntity::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBaseEntity::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBaseEntity::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBaseEntity::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBaseEntity::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBaseEntity::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CBaseEntity::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CBaseEntity::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBaseEntity::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBaseEntity::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBaseEntity::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBaseEntity::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBaseEntity::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBaseEntity::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBaseEntity::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBaseEntity::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBaseEntity::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBaseEntity::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBaseEntity::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBaseEntity::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBaseEntity::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBaseEntity::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBaseEntity::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBaseEntity::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBaseEntity::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBaseEntity::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBaseEntity::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBaseEntity::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBaseEntity::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBaseEntity::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBaseEntity::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBaseEntity::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBaseEntity::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBaseEntity::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBaseEntity::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBaseEntity::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBaseEntity::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBaseEntity::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBaseEntity::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBaseEntity::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBaseEntity::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBaseEntity::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBaseEntity::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBaseEntity::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBaseEntity::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBaseEntity::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBaseEntity::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBaseEntity::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBaseEntity::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBaseEntity::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBaseEntity::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBaseEntity::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBaseEntity::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBaseEntity::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBaseEntity::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBaseEntity::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBaseEntity::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBaseEntity::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBaseEntity::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBaseEntity::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBaseEntity::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBaseEntity::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBaseEntity::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBaseEntity::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBaseEntity::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"CBaseDelay@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseAnimating@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseToggle@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayerItem@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseMonster@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CCineMonster@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayer@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CGrenade@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CSprite@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayerWeapon@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CPathTrack@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBeam@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CLaser@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseTank@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayerAmmo@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CItem@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseButton@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseDoor@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CGib@ CBaseEntity::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"entvars_t@ CBaseEntity::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBaseEntity::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBaseEntity::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBaseEntity::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBaseEntity::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBaseEntity::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBaseEntity::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBaseEntity::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBaseEntity::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBaseEntity::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBaseEntity::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBaseEntity::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBaseEntity::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBaseEntity::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBaseEntity::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBaseEntity::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"CBaseToggle@ CBaseMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseAnimating@ CBaseMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CBaseMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CBaseMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBaseMonster::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBaseMonster::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBaseMonster::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBaseMonster::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBaseMonster::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBaseMonster::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBaseMonster::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBaseMonster::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBaseMonster::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBaseMonster::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBaseMonster::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBaseMonster::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBaseMonster::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBaseMonster::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBaseMonster::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBaseMonster::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBaseMonster::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBaseMonster::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBaseMonster::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBaseMonster::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBaseMonster::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBaseMonster::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBaseMonster::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBaseMonster::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBaseMonster::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBaseMonster::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBaseMonster::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBaseMonster::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBaseMonster::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBaseMonster::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBaseMonster::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBaseMonster::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBaseMonster::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBaseMonster::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBaseMonster::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBaseMonster::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBaseMonster::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBaseMonster::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBaseMonster::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBaseMonster::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBaseMonster::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBaseMonster::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBaseMonster::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBaseMonster::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBaseMonster::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBaseMonster::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBaseMonster::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBaseMonster::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBaseMonster::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBaseMonster::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBaseMonster::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBaseMonster::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBaseMonster::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBaseMonster::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBaseMonster::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBaseMonster::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBaseMonster::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBaseMonster::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBaseMonster::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBaseMonster::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBaseMonster::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBaseMonster::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBaseMonster::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBaseMonster::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBaseMonster::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBaseMonster::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBaseMonster::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBaseMonster::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBaseMonster::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBaseMonster::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBaseMonster::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBaseMonster::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBaseMonster::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBaseMonster::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBaseMonster::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBaseMonster::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBaseMonster::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBaseMonster::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBaseMonster::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBaseMonster::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBaseMonster::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBaseMonster::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBaseMonster::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBaseMonster::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBaseMonster::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBaseMonster::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBaseMonster::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBaseMonster::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBaseMonster::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBaseMonster::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBaseMonster::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBaseMonster::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBaseMonster::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBaseMonster::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBaseMonster::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBaseMonster::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBaseMonster::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBaseMonster::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBaseMonster::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBaseMonster::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBaseMonster::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBaseMonster::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBaseMonster::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBaseMonster::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBaseMonster::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CBaseMonster::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CBaseMonster::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CBaseMonster::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CBaseMonster::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CBaseMonster::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CBaseMonster::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CBaseMonster::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CBaseMonster::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CBaseMonster::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CBaseMonster::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CBaseMonster::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CBaseMonster::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CBaseMonster::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CBaseMonster::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CBaseMonster::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CBaseMonster::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CBaseMonster::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CBaseMonster::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CBaseMonster::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CBaseMonster::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CBaseMonster::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CBaseMonster::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"void CBaseMonster::LinearMove(Vector vecDest, float flSpeed)": {
		"prefix": "LinearMove",
		"body" : [ "LinearMove( ${1:Vector vecDest}, ${2:float flSpeed} )" ],
		"description" : "Performs linear movement."
	},
	"void CBaseMonster::AngularMove(Vector vecDestAngle, float flSpeed)": {
		"prefix": "AngularMove",
		"body" : [ "AngularMove( ${1:Vector vecDestAngle}, ${2:float flSpeed} )" ],
		"description" : "Performs angular movement."
	},
	"bool CBaseMonster::IsToggleLockedByMaster()": {
		"prefix": "IsToggleLockedByMaster",
		"body" : [ "IsToggleLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master. Separate from IsLockedByMaster due to limitations."
	},
	"InventoryRules@ CBaseMonster::get_m_pInventoryRules() const": {
		"prefix": "get_m_pInventoryRules",
		"body" : [ "get_m_pInventoryRules()" ],
		"description" : "The inventory rules."
	},
	"EHandle& CBaseMonster::m_hOldEnemy(size_t uiIndex)": {
		"prefix": "m_hOldEnemy",
		"body" : [ "m_hOldEnemy( ${1:size_t uiIndex} )" ],
		"description" : "Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."
	},
	"Vector& CBaseMonster::m_vecOldEnemy(size_t uiIndex)": {
		"prefix": "m_vecOldEnemy",
		"body" : [ "m_vecOldEnemy( ${1:size_t uiIndex} )" ],
		"description" : "Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."
	},
	"Waypoint& CBaseMonster::m_Route(size_t uiIndex)": {
		"prefix": "m_Route",
		"body" : [ "m_Route( ${1:size_t uiIndex} )" ],
		"description" : "Positions of movement. Index must be between 0 and ROUTE_SIZE"
	},
	"int8& CBaseMonster::m_rgbTimeBasedDamage(size_t uiIndex)": {
		"prefix": "m_rgbTimeBasedDamage",
		"body" : [ "m_rgbTimeBasedDamage( ${1:size_t uiIndex} )" ],
		"description" : "time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED."
	},
	"void CBaseMonster::MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "MonsterUse",
		"body" : [ "MonsterUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Will make a monster angry at whomever activated it."
	},
	"void CBaseMonster::Look(int iDistance)": {
		"prefix": "Look",
		"body" : [ "Look( ${1:int iDistance} )" ],
		"description" : "Look - Base class monster function to find enemies or. food by sight. iDistance is distance (in units) that the. monster can see. Sets the sight bits of the m_afConditions mask to indicate. which types of entities were sighted. Function also sets the Looker's m_pLink. to the head of a link list that contains all visible ents. (linked via each ent's m_pLink field)"
	},
	"void CBaseMonster::RunAI()": {
		"prefix": "RunAI",
		"body" : [ "RunAI()" ],
		"description" : "Runs this monster's AI."
	},
	"void CBaseMonster::Listen()": {
		"prefix": "Listen",
		"body" : [ "Listen()" ],
		"description" : "Listens for anything that is within audible distance."
	},
	"bool CBaseMonster::ShouldFadeOnDeath()": {
		"prefix": "ShouldFadeOnDeath",
		"body" : [ "ShouldFadeOnDeath()" ],
		"description" : "Returns whether this monster should fade on death."
	},
	"float CBaseMonster::ChangeYaw(int iSpeed)": {
		"prefix": "ChangeYaw",
		"body" : [ "ChangeYaw( ${1:int iSpeed} )" ],
		"description" : "turns a monster towards its ideal_yaw"
	},
	"float CBaseMonster::VecToYaw(Vector vecDir)": {
		"prefix": "VecToYaw",
		"body" : [ "VecToYaw( ${1:Vector vecDir} )" ],
		"description" : "turns a directional vector into a yaw value that points down that vector."
	},
	"float CBaseMonster::FlYawDiff()": {
		"prefix": "FlYawDiff",
		"body" : [ "FlYawDiff()" ],
		"description" : "returns the difference (in degrees) between monster's current yaw and ideal_yaw. Positive result is left turn, negative is right turn."
	},
	"float CBaseMonster::DamageForce(float flDamage)": {
		"prefix": "DamageForce",
		"body" : [ "DamageForce( ${1:float flDamage} )" ],
		"description" : "Returns the amount of force applied to this monster when the given amount of damage is done."
	},
	"void CBaseMonster::SetupFriendly()": {
		"prefix": "SetupFriendly",
		"body" : [ "SetupFriendly()" ],
		"description" : "use this overridden to make some other friendly monsters"
	},
	"void CBaseMonster::MonsterInit()": {
		"prefix": "MonsterInit",
		"body" : [ "MonsterInit()" ],
		"description" : "Initializes the monster"
	},
	"void CBaseMonster::MonsterInitDead()": {
		"prefix": "MonsterInitDead",
		"body" : [ "MonsterInitDead()" ],
		"description" : "Call after animation/pose is set up"
	},
	"void CBaseMonster::BecomeDead(float flSavedHealth)": {
		"prefix": "BecomeDead",
		"body" : [ "BecomeDead( ${1:float flSavedHealth} )" ],
		"description" : "Makes the monster become dead"
	},
	"void CBaseMonster::Revive()": {
		"prefix": "Revive",
		"body" : [ "Revive()" ],
		"description" : "Revives the monster"
	},
	"void CBaseMonster::StartMonster()": {
		"prefix": "StartMonster",
		"body" : [ "StartMonster()" ],
		"description" : "Starts the monster"
	},
	"void CBaseMonster::BestVisibleEnemy()": {
		"prefix": "BestVisibleEnemy",
		"body" : [ "BestVisibleEnemy()" ],
		"description" : "finds best visible enemy for attack"
	},
	"bool CBaseMonster::FInViewCone(CBaseEntity@ pEntity)": {
		"prefix": "FInViewCone",
		"body" : [ "FInViewCone( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "see if pEntity is in monster's view cone"
	},
	"bool CBaseMonster::FInViewCone(const Vector& in vecOrigin)": {
		"prefix": "FInViewCone",
		"body" : [ "FInViewCone( ${1:const Vector& in vecOrigin} )" ],
		"description" : "see if given location is in monster's view cone"
	},
	"int CBaseMonster::CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false)": {
		"prefix": "CheckLocalMove",
		"body" : [ "CheckLocalMove( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd,CBaseEntity@ pTarget}, ${3:float& out flDist}, ${4:Vector& out vecEndPosition}, ${5:bool fOriginalCheck = false} )" ],
		"description" : "finds best visible enemy for attack"
	},
	"void CBaseMonster::Move(float flInterval = 0.1f)": {
		"prefix": "Move",
		"body" : [ "Move( ${1:float flInterval = 0.1f} )" ],
		"description" : "Starts the monster"
	},
	"void CBaseMonster::MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval)": {
		"prefix": "MoveExecute",
		"body" : [ "MoveExecute( ${1:CBaseEntity@ pTargetEnt}, ${2:const Vector& in vecDir}, ${3:float flInterval} )" ],
		"description" : "Starts the monster"
	},
	"bool CBaseMonster::ShouldAdvanceRoute(float flWaypointDist)": {
		"prefix": "ShouldAdvanceRoute",
		"body" : [ "ShouldAdvanceRoute( ${1:float flWaypointDist} )" ],
		"description" : "Returns whether this monster should advance its route"
	},
	"Activity CBaseMonster::GetStoppedActivity()": {
		"prefix": "GetStoppedActivity",
		"body" : [ "GetStoppedActivity()" ],
		"description" : "Gets the stopped activity"
	},
	"void CBaseMonster::Stop()": {
		"prefix": "Stop",
		"body" : [ "Stop()" ],
		"description" : "Stops this monster moving"
	},
	"void CBaseMonster::StopAnimation()": {
		"prefix": "StopAnimation",
		"body" : [ "StopAnimation()" ],
		"description" : "This will stop animation until you call ResetSequenceInfo() at some point in the future"
	},
	"bool CBaseMonster::CheckRangeAttack1(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1",
		"body" : [ "CheckRangeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBaseMonster::CheckRangeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1_Move",
		"body" : [ "CheckRangeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBaseMonster::CheckRangeAttack2(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2",
		"body" : [ "CheckRangeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBaseMonster::CheckRangeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2_Move",
		"body" : [ "CheckRangeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBaseMonster::CheckMeleeAttack1(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1",
		"body" : [ "CheckMeleeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBaseMonster::CheckMeleeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1_Move",
		"body" : [ "CheckMeleeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBaseMonster::CheckMeleeAttack2(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2",
		"body" : [ "CheckMeleeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBaseMonster::CheckMeleeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2_Move",
		"body" : [ "CheckMeleeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBaseMonster::CheckTankUsage()": {
		"prefix": "CheckTankUsage",
		"body" : [ "CheckTankUsage()" ],
		"description" : "Checks whether the monster can use a func_tank. Return true if possible."
	},
	"bool CBaseMonster::FHaveSchedule()": {
		"prefix": "FHaveSchedule",
		"body" : [ "FHaveSchedule()" ],
		"description" : "Returns whether this monster has a schedule."
	},
	"bool CBaseMonster::FScheduleValid()": {
		"prefix": "FScheduleValid",
		"body" : [ "FScheduleValid()" ],
		"description" : "Returns whether this monster's schedule is valid."
	},
	"void CBaseMonster::ClearSchedule()": {
		"prefix": "ClearSchedule",
		"body" : [ "ClearSchedule()" ],
		"description" : "Clears this monster's schedule."
	},
	"bool CBaseMonster::FScheduleDone()": {
		"prefix": "FScheduleDone",
		"body" : [ "FScheduleDone()" ],
		"description" : "Returns whether this monster's schedule is done."
	},
	"void CBaseMonster::ChangeSchedule(Schedule@ pNewSchedule)": {
		"prefix": "ChangeSchedule",
		"body" : [ "ChangeSchedule( ${1:Schedule@ pNewSchedule} )" ],
		"description" : "Changes this monster's schedule."
	},
	"bool CBaseMonster::NextScheduledTask()": {
		"prefix": "NextScheduledTask",
		"body" : [ "NextScheduledTask()" ],
		"description" : "Moves to the next scheduled task."
	},
	"Schedule@ CBaseMonster::ScheduleInList(const string& in szName, array<Schedule@>@ pArray)": {
		"prefix": "ScheduleInList",
		"body" : [ "ScheduleInList( ${1:const string& in szName}, ${2:array<Schedule@>@ pArray} )" ],
		"description" : "Returns the schedule with name szName if it's in the list, NULL otherwise."
	},
	"Schedule@ CBaseMonster::ScheduleFromName(const string& in szName)": {
		"prefix": "ScheduleFromName",
		"body" : [ "ScheduleFromName( ${1:const string& in szName} )" ],
		"description" : "Returns the schedule with name szName if it exists, NULL otherwise."
	},
	"void CBaseMonster::MaintainSchedule()": {
		"prefix": "MaintainSchedule",
		"body" : [ "MaintainSchedule()" ],
		"description" : "Maintains the monster's schedule."
	},
	"void CBaseMonster::StartTask(Task@ pTask)": {
		"prefix": "StartTask",
		"body" : [ "StartTask( ${1:Task@ pTask} )" ],
		"description" : "Starts the given task."
	},
	"void CBaseMonster::RunTask(Task@ pTask)": {
		"prefix": "RunTask",
		"body" : [ "RunTask( ${1:Task@ pTask} )" ],
		"description" : "Runs the given task."
	},
	"Schedule@ CBaseMonster::GetScheduleOfType(int iType)": {
		"prefix": "GetScheduleOfType",
		"body" : [ "GetScheduleOfType( ${1:int iType} )" ],
		"description" : "Gets one of the available schedules of the given type."
	},
	"Schedule@ CBaseMonster::GetSchedule()": {
		"prefix": "GetSchedule",
		"body" : [ "GetSchedule()" ],
		"description" : "Gets the current schedule."
	},
	"void CBaseMonster::ScheduleChange()": {
		"prefix": "ScheduleChange",
		"body" : [ "ScheduleChange()" ],
		"description" : "Called after the monster's schedule changes."
	},
	"bool CBaseMonster::CanPlaySequence(const bool bDisregardState, int iInterruptLevel)": {
		"prefix": "CanPlaySequence",
		"body" : [ "CanPlaySequence( ${1:const bool bDisregardState}, ${2:int iInterruptLevel} )" ],
		"description" : "Returns whether this monster can play its sequence."
	},
	"bool CBaseMonster::CanPlaySentence(const bool bDisregardState)": {
		"prefix": "CanPlaySentence",
		"body" : [ "CanPlaySentence( ${1:const bool bDisregardState} )" ],
		"description" : "Returns whether this monster can play its sentence."
	},
	"void CBaseMonster::PlaySentence(const string& in szSentence, float duration, float volume, float attenuation)": {
		"prefix": "PlaySentence",
		"body" : [ "PlaySentence( ${1:const string& in szSentence}, ${2:float duration}, ${3:float volume}, ${4:float attenuation} )" ],
		"description" : "Plays the given sentence."
	},
	"void CBaseMonster::PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener)": {
		"prefix": "PlayScriptedSentence",
		"body" : [ "PlayScriptedSentence( ${1:const string& in szSentence}, ${2:float duration}, ${3:float volume}, ${4:float attenuation}, ${5:const bool bConcurrent}, ${6:CBaseEntity@ pListener} )" ],
		"description" : "Plays the given scripted sentence."
	},
	"void CBaseMonster::SentenceStop()": {
		"prefix": "SentenceStop",
		"body" : [ "SentenceStop()" ],
		"description" : "Stops playing its current sentence."
	},
	"Task@ CBaseMonster::GetTask()": {
		"prefix": "GetTask",
		"body" : [ "GetTask()" ],
		"description" : "Gets the current task."
	},
	"MONSTERSTATE CBaseMonster::GetIdealState()": {
		"prefix": "GetIdealState",
		"body" : [ "GetIdealState()" ],
		"description" : "Gets the ideal monster state."
	},
	"void CBaseMonster::SetActivity(Activity newActivity)": {
		"prefix": "SetActivity",
		"body" : [ "SetActivity( ${1:Activity newActivity} )" ],
		"description" : "Sets the current activity."
	},
	"void CBaseMonster::SetGaitActivity(Activity newActivity)": {
		"prefix": "SetGaitActivity",
		"body" : [ "SetGaitActivity( ${1:Activity newActivity} )" ],
		"description" : "Sets the current gait activity."
	},
	"void CBaseMonster::SetSequenceByName(const string& in szSequence)": {
		"prefix": "SetSequenceByName",
		"body" : [ "SetSequenceByName( ${1:const string& in szSequence} )" ],
		"description" : "Sets the current sequence by name."
	},
	"void CBaseMonster::SetState(MONSTERSTATE state)": {
		"prefix": "SetState",
		"body" : [ "SetState( ${1:MONSTERSTATE state} )" ],
		"description" : "Sets the current monster state."
	},
	"void CBaseMonster::ReportAIState()": {
		"prefix": "ReportAIState",
		"body" : [ "ReportAIState()" ],
		"description" : "Reports the AI state."
	},
	"void CBaseMonster::CheckAttacks(CBaseEntity@ pTarget, float flDist)": {
		"prefix": "CheckAttacks",
		"body" : [ "CheckAttacks( ${1:CBaseEntity@ pTarget}, ${2:float flDist} )" ],
		"description" : "Check attacks to the given enemy at the given distance."
	},
	"void CBaseMonster::CheckAttacks_Move(CBaseEntity@ pTarget, float flDist)": {
		"prefix": "CheckAttacks_Move",
		"body" : [ "CheckAttacks_Move( ${1:CBaseEntity@ pTarget}, ${2:float flDist} )" ],
		"description" : "Check attacks to the given enemy at the given distance while moving."
	},
	"bool CBaseMonster::CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos)": {
		"prefix": "CheckAttacksFromPosition",
		"body" : [ "CheckAttacksFromPosition( ${1:CBaseEntity@ pTarget}, ${2:float flDist}, ${3:Vector vecPos} )" ],
		"description" : "Check whether attacks are possible from the given position."
	},
	"bool CBaseMonster::CheckEnemy(CBaseEntity@ pEnemy)": {
		"prefix": "CheckEnemy",
		"body" : [ "CheckEnemy( ${1:CBaseEntity@ pEnemy} )" ],
		"description" : "part of the Condition collection process, gets and stores data and conditions pertaining to a monster's enemy. Returns true if Enemy LKP was updated."
	},
	"void CBaseMonster::PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos)": {
		"prefix": "PushEnemy",
		"body" : [ "PushEnemy( ${1:CBaseEntity@ pTarget}, ${2:Vector& in vecLastKnownPos} )" ],
		"description" : "Remember the last few enemies, always remember the player."
	},
	"bool CBaseMonster::PopEnemy()": {
		"prefix": "PopEnemy",
		"body" : [ "PopEnemy()" ],
		"description" : "Try remembering the last few enemies."
	},
	"bool CBaseMonster::FGetNodeRoute(Vector vecDest)": {
		"prefix": "FGetNodeRoute",
		"body" : [ "FGetNodeRoute( ${1:Vector vecDest} )" ],
		"description" : "tries to build an entire node path from. the callers origin to the passed vector. If this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route. true is returned if the operation  succeeds (path is valid) or false if failed (no path  exists )."
	},
	"bool CBaseMonster::TestFGetNodeRoute(Vector vecDest)": {
		"prefix": "TestFGetNodeRoute",
		"body" : [ "TestFGetNodeRoute( ${1:Vector vecDest} )" ],
		"description" : "TEST FGetNodeRoute."
	},
	"void CBaseMonster::TaskComplete()": {
		"prefix": "TaskComplete",
		"body" : [ "TaskComplete()" ],
		"description" : "Sets the task status to complete."
	},
	"void CBaseMonster::MovementComplete()": {
		"prefix": "MovementComplete",
		"body" : [ "MovementComplete()" ],
		"description" : "Called when movement has completed."
	},
	"void CBaseMonster::TaskFail()": {
		"prefix": "TaskFail",
		"body" : [ "TaskFail()" ],
		"description" : "Sets the condition bit for a failed task."
	},
	"void CBaseMonster::TaskBegin()": {
		"prefix": "TaskBegin",
		"body" : [ "TaskBegin()" ],
		"description" : "Sets the task status to running."
	},
	"bool CBaseMonster::TaskIsRunning()": {
		"prefix": "TaskIsRunning",
		"body" : [ "TaskIsRunning()" ],
		"description" : "Returns whether a task is running."
	},
	"bool CBaseMonster::TaskIsComplete()": {
		"prefix": "TaskIsComplete",
		"body" : [ "TaskIsComplete()" ],
		"description" : "Returns whether the task is complete."
	},
	"bool CBaseMonster::MovementIsComplete()": {
		"prefix": "MovementIsComplete",
		"body" : [ "MovementIsComplete()" ],
		"description" : "Returns whether movement is complete."
	},
	"int CBaseMonster::IScheduleFlags()": {
		"prefix": "IScheduleFlags",
		"body" : [ "IScheduleFlags()" ],
		"description" : "Returns an integer with all Conditions. bits that are currently set and also set in the current. schedule's Interrupt mask."
	},
	"void CBaseMonster::MakeIdealYaw(Vector vecTarget)": {
		"prefix": "MakeIdealYaw",
		"body" : [ "MakeIdealYaw( ${1:Vector vecTarget} )" ],
		"description" : "gets a yaw value for the caller that would. face the supplied vector. Value is stuffed into the monster's. ideal_yaw."
	},
	"void CBaseMonster::SetYawSpeed()": {
		"prefix": "SetYawSpeed",
		"body" : [ "SetYawSpeed()" ],
		"description" : "Allows different yaw_speeds for each activity."
	},
	"int CBaseMonster::RouteClassify(int iMoveFlag)": {
		"prefix": "RouteClassify",
		"body" : [ "RouteClassify( ${1:int iMoveFlag} )" ],
		"description" : "Returns the MOVEGOAL for the given move flag."
	},
	"bool CBaseMonster::CheckAttacker(CBaseEntity@ pAttacker)": {
		"prefix": "CheckAttacker",
		"body" : [ "CheckAttacker( ${1:CBaseEntity@ pAttacker} )" ],
		"description" : "Determine if we should ignore damage."
	},
	"void CBaseMonster::SetConditions(int iConditions)": {
		"prefix": "SetConditions",
		"body" : [ "SetConditions( ${1:int iConditions} )" ],
		"description" : "Sets AI conditions."
	},
	"void CBaseMonster::ClearConditions(int iConditions)": {
		"prefix": "ClearConditions",
		"body" : [ "ClearConditions( ${1:int iConditions} )" ],
		"description" : "Clears AI conditions."
	},
	"bool CBaseMonster::HasConditions(int iConditions) const": {
		"prefix": "HasConditions",
		"body" : [ "HasConditions( ${1:int iConditions} )" ],
		"description" : "Returns whether this monster has any of the given AI conditions."
	},
	"bool CBaseMonster::HasAllConditions(int iConditions) const": {
		"prefix": "HasAllConditions",
		"body" : [ "HasAllConditions( ${1:int iConditions} )" ],
		"description" : "Returns whether this monster has all of the given AI conditions."
	},
	"CSound@ CBaseMonster::PBestSound()": {
		"prefix": "PBestSound",
		"body" : [ "PBestSound()" ],
		"description" : "Returns a pointer to the sound the monster should react to."
	},
	"bool CBaseMonster::FShouldEat()": {
		"prefix": "FShouldEat",
		"body" : [ "FShouldEat()" ],
		"description" : "Returns whether this monster should eat."
	},
	"void CBaseMonster::Eat(float flFullDuration)": {
		"prefix": "Eat",
		"body" : [ "Eat( ${1:float flFullDuration} )" ],
		"description" : "Make the monster 'full' for a while."
	},
	"bool CBaseMonster::FCheckAITrigger()": {
		"prefix": "FCheckAITrigger",
		"body" : [ "FCheckAITrigger()" ],
		"description" : "Checks and, if necessary, fires the monster's trigger target."
	},
	"bool CBaseMonster::NoFriendlyFire()": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire()" ],
		"description" : "Returns whether attacking at this time would result in friendly fire"
	},
	"bool CBaseMonster::NoFriendlyFire(Vector vecPos)": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire( ${1:Vector vecPos} )" ],
		"description" : "Returns whether attacking at this time from the given location would result in friendly fire"
	},
	"bool CBaseMonster::NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget)": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire( ${1:Vector vecPos}, ${2:CBaseEntity@ pTarget} )" ],
		"description" : "Returns whether attacking the given target at this time from the given location would result in friendly fire"
	},
	"bool CBaseMonster::NoFriendlyFireToPos(Vector vecPos)": {
		"prefix": "NoFriendlyFireToPos",
		"body" : [ "NoFriendlyFireToPos( ${1:Vector vecPos} )" ],
		"description" : "Returns whether attacking the target location at this time would result in friendly fire"
	},
	"bool CBaseMonster::GetEnemy()": {
		"prefix": "GetEnemy",
		"body" : [ "GetEnemy()" ],
		"description" : "Tries to find the best suitable enemy for this monster."
	},
	"void CBaseMonster::GibMonster()": {
		"prefix": "GibMonster",
		"body" : [ "GibMonster()" ],
		"description" : "Gibs the monster."
	},
	"bool CBaseMonster::ShouldGibMonster(int iGib)": {
		"prefix": "ShouldGibMonster",
		"body" : [ "ShouldGibMonster( ${1:int iGib} )" ],
		"description" : "Returns whether the monster should be gibbed given the gib type. See GIB enum."
	},
	"void CBaseMonster::CallGibMonster()": {
		"prefix": "CallGibMonster",
		"body" : [ "CallGibMonster()" ],
		"description" : "Determines whether to gib or fade this monster, and acts accordingly."
	},
	"bool CBaseMonster::HasHumanGibs()": {
		"prefix": "HasHumanGibs",
		"body" : [ "HasHumanGibs()" ],
		"description" : "Returns whether this monster has human gibs."
	},
	"bool CBaseMonster::HasAlienGibs()": {
		"prefix": "HasAlienGibs",
		"body" : [ "HasAlienGibs()" ],
		"description" : "Returns whether this monster has alien gibs."
	},
	"void CBaseMonster::FadeMonster()": {
		"prefix": "FadeMonster",
		"body" : [ "FadeMonster()" ],
		"description" : "Fades this monster. Note: does not kill the monster."
	},
	"Vector CBaseMonster::ShootAtEnemy(const Vector& in vecShootOrigin)": {
		"prefix": "ShootAtEnemy",
		"body" : [ "ShootAtEnemy( ${1:const Vector& in vecShootOrigin} )" ],
		"description" : "Shoots at the specified location."
	},
	"void CBaseMonster::DeathSound()": {
		"prefix": "DeathSound",
		"body" : [ "DeathSound()" ],
		"description" : "Plays this monster's death sound."
	},
	"void CBaseMonster::AlertSound()": {
		"prefix": "AlertSound",
		"body" : [ "AlertSound()" ],
		"description" : "Plays this monster's alert sound."
	},
	"void CBaseMonster::IdleSound()": {
		"prefix": "IdleSound",
		"body" : [ "IdleSound()" ],
		"description" : "Plays this monster's idle sound."
	},
	"void CBaseMonster::PainSound()": {
		"prefix": "PainSound",
		"body" : [ "PainSound()" ],
		"description" : "Plays this monster's pain sound."
	},
	"void CBaseMonster::StartPlayerFollowing(CBaseEntity@ pLeader, bool bSilent = false)": {
		"prefix": "StartPlayerFollowing",
		"body" : [ "StartPlayerFollowing( ${1:CBaseEntity@ pLeader}, ${2:bool bSilent = false} )" ],
		"description" : "Starts following its target."
	},
	"void CBaseMonster::StopPlayerFollowing(const bool clearSchedule, bool bSilent = false)": {
		"prefix": "StopPlayerFollowing",
		"body" : [ "StopPlayerFollowing( ${1:const bool clearSchedule}, ${2:bool bSilent = false} )" ],
		"description" : "Stops following its target."
	},
	"void CBaseMonster::Remember(int iMemory)": {
		"prefix": "Remember",
		"body" : [ "Remember( ${1:int iMemory} )" ],
		"description" : "Makes this monster remember the given memories."
	},
	"void CBaseMonster::Forget(int iMemory)": {
		"prefix": "Forget",
		"body" : [ "Forget( ${1:int iMemory} )" ],
		"description" : "Makes this monster forget the given memories."
	},
	"bool CBaseMonster::HasMemory(int iMemory) const": {
		"prefix": "HasMemory",
		"body" : [ "HasMemory( ${1:int iMemory} )" ],
		"description" : "Returns whether this monster remembers any of the given memories."
	},
	"bool CBaseMonster::HasAllMemories(int iMemory) const": {
		"prefix": "HasAllMemories",
		"body" : [ "HasAllMemories( ${1:int iMemory} )" ],
		"description" : "Returns whether this monster remembers all of the given memories."
	},
	"bool CBaseMonster::ExitScriptedSequence()": {
		"prefix": "ExitScriptedSequence",
		"body" : [ "ExitScriptedSequence()" ],
		"description" : "Exits the scripted sequence this monster is currently in, if any."
	},
	"bool CBaseMonster::CineCleanup()": {
		"prefix": "CineCleanup",
		"body" : [ "CineCleanup()" ],
		"description" : "Cleans up after a cinematic event."
	},
	"CBaseEntity@ CBaseMonster::DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng)": {
		"prefix": "DropItem",
		"body" : [ "DropItem( ${1:const string& in szItemName}, ${2:const Vector& in vecPos}, ${3:const Vector& in vecAng} )" ],
		"description" : "Drops the given item from the given position at the given angle."
	},
	"void CBaseMonster::ShockGlowEffect(bool fMode)": {
		"prefix": "ShockGlowEffect",
		"body" : [ "ShockGlowEffect( ${1:bool fMode} )" ],
		"description" : "Turns the shock glow effect on or off."
	},
	"void CBaseMonster::FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)": {
		"prefix": "FollowerPlayerUse",
		"body" : [ "FollowerPlayerUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue} )" ],
		"description" : "Use method for following players (set only if friendly)"
	},
	"bool CBaseMonster::IsPlayerFollowing()": {
		"prefix": "IsPlayerFollowing",
		"body" : [ "IsPlayerFollowing()" ],
		"description" : "Returns whether this monster is following a player."
	},
	"bool CBaseMonster::CanPlayerFollow()": {
		"prefix": "CanPlayerFollow",
		"body" : [ "CanPlayerFollow()" ],
		"description" : "Returns whether this monster can follow a player."
	},
	"void CBaseMonster::StartPlayerFollowing(CBaseEntity@ pLeader)": {
		"prefix": "StartPlayerFollowing",
		"body" : [ "StartPlayerFollowing( ${1:CBaseEntity@ pLeader} )" ],
		"description" : "Starts following a given player."
	},
	"void CBaseMonster::StopPlayerFollowing(const bool bClearSchedule)": {
		"prefix": "StopPlayerFollowing",
		"body" : [ "StopPlayerFollowing( ${1:const bool bClearSchedule} )" ],
		"description" : "Stops following a player."
	},
	"string CBaseMonster::m_szTextureName()": {
		"prefix": "m_szTextureName",
		"body" : [ "m_szTextureName()" ],
		"description" : "Current texture name we're standing on."
	},
	"void CBaseMonster::MedicCallSound(float flDistance = 0.0f)": {
		"prefix": "MedicCallSound",
		"body" : [ "MedicCallSound( ${1:float flDistance = 0.0f} )" ],
		"description" : "Medic call sound."
	},
	"InventoryList@ CBaseMonster::get_m_pInventory() const": {
		"prefix": "get_m_pInventory",
		"body" : [ "get_m_pInventory()" ],
		"description" : "The inventory items this monster has"
	},
	"void CBaseMonster::ClearEnemyList()": {
		"prefix": "ClearEnemyList",
		"body" : [ "ClearEnemyList()" ],
		"description" : "Clears this monster's list of enemies"
	},
	"void CBaseMonster::ApplyEffects()": {
		"prefix": "ApplyEffects",
		"body" : [ "ApplyEffects()" ],
		"description" : "Re-calculate compounded effect modifiers and apply to the monster"
	},
	"void CBaseMonster::ResetEffects()": {
		"prefix": "ResetEffects",
		"body" : [ "ResetEffects()" ],
		"description" : "Reset all effect modifiers"
	},
	"CCineMonster@ CBaseMonster::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayer@ CBaseMonster::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CGrenade@ CBaseMonster::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"entvars_t@ CBaseMonster::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBaseMonster::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBaseMonster::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBaseMonster::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBaseMonster::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBaseMonster::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBaseMonster::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBaseMonster::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBaseMonster::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBaseMonster::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBaseMonster::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBaseMonster::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBaseMonster::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBaseMonster::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBaseMonster::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBaseMonster::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBaseMonster::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBaseMonster::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CBaseMonster::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CBaseMonster::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CBaseMonster::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CBaseMonster::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CBaseMonster::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CBaseMonster::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"TOGGLE_STATE CBaseMonster::m_toggle_state": {
		"prefix": "m_toggle_state",
		"body" : [ "m_toggle_state" ],
		"description" : "Current toggle state."
	},
	"float CBaseMonster::m_flMoveDistance": {
		"prefix": "m_flMoveDistance",
		"body" : [ "m_flMoveDistance" ],
		"description" : "How far a door should slide or rotate."
	},
	"float CBaseMonster::m_flWait": {
		"prefix": "m_flWait",
		"body" : [ "m_flWait" ],
		"description" : "How long to wait before resetting."
	},
	"float CBaseMonster::m_flLip": {
		"prefix": "m_flLip",
		"body" : [ "m_flLip" ],
		"description" : "How much to stick out of a wall. Will recede further into walls if negative."
	},
	"float CBaseMonster::m_flTWidth": {
		"prefix": "m_flTWidth",
		"body" : [ "m_flTWidth" ],
		"description" : "For plats."
	},
	"float CBaseMonster::m_flTLength": {
		"prefix": "m_flTLength",
		"body" : [ "m_flTLength" ],
		"description" : "For plats."
	},
	"int CBaseMonster::m_cTriggersLeft": {
		"prefix": "m_cTriggersLeft",
		"body" : [ "m_cTriggersLeft" ],
		"description" : "Trigger_counter only: # of activations remaining."
	},
	"float CBaseMonster::m_flHeight": {
		"prefix": "m_flHeight",
		"body" : [ "m_flHeight" ],
		"description" : "Height."
	},
	"EHandle CBaseMonster::m_hActivator": {
		"prefix": "m_hActivator",
		"body" : [ "m_hActivator" ],
		"description" : "Handle to the activator."
	},
	"Vector CBaseMonster::m_vecPosition1": {
		"prefix": "m_vecPosition1",
		"body" : [ "m_vecPosition1" ],
		"description" : "Closed position."
	},
	"Vector CBaseMonster::m_vecPosition2": {
		"prefix": "m_vecPosition2",
		"body" : [ "m_vecPosition2" ],
		"description" : "Open position."
	},
	"Vector CBaseMonster::m_vecAngle1": {
		"prefix": "m_vecAngle1",
		"body" : [ "m_vecAngle1" ],
		"description" : "Closed angle."
	},
	"Vector CBaseMonster::m_vecAngle2": {
		"prefix": "m_vecAngle2",
		"body" : [ "m_vecAngle2" ],
		"description" : "Open angle."
	},
	"Vector CBaseMonster::m_vecFinalDest": {
		"prefix": "m_vecFinalDest",
		"body" : [ "m_vecFinalDest" ],
		"description" : "Final destination."
	},
	"Vector CBaseMonster::m_vecFinalAngle": {
		"prefix": "m_vecFinalAngle",
		"body" : [ "m_vecFinalAngle" ],
		"description" : "Final angle."
	},
	"int CBaseMonster::m_bitsDamageInflict": {
		"prefix": "m_bitsDamageInflict",
		"body" : [ "m_bitsDamageInflict" ],
		"description" : "DMG_ damage type that the door or trigger does."
	},
	"string_t CBaseMonster::m_sMaster": {
		"prefix": "m_sMaster",
		"body" : [ "m_sMaster" ],
		"description" : "This entity's master, if any."
	},
	"EHandle CBaseMonster::m_hEnemy": {
		"prefix": "m_hEnemy",
		"body" : [ "m_hEnemy" ],
		"description" : "the entity that the monster is fighting."
	},
	"EHandle CBaseMonster::m_hTargetEnt": {
		"prefix": "m_hTargetEnt",
		"body" : [ "m_hTargetEnt" ],
		"description" : "the entity that the monster is trying to reach."
	},
	"EHandle CBaseMonster::m_hTargetTank": {
		"prefix": "m_hTargetTank",
		"body" : [ "m_hTargetTank" ],
		"description" : "Target tank to control."
	},
	"float CBaseMonster::m_flFieldOfView": {
		"prefix": "m_flFieldOfView",
		"body" : [ "m_flFieldOfView" ],
		"description" : "width of monster's field of view (dot product)."
	},
	"float CBaseMonster::m_flWaitFinished": {
		"prefix": "m_flWaitFinished",
		"body" : [ "m_flWaitFinished" ],
		"description" : "if we're told to wait, this is the time that the wait will be over."
	},
	"float CBaseMonster::m_flMoveWaitFinished": {
		"prefix": "m_flMoveWaitFinished",
		"body" : [ "m_flMoveWaitFinished" ],
		"description" : "if we're told to wait before moving, this is the time that the wait will be over."
	},
	"Activity CBaseMonster::m_Activity": {
		"prefix": "m_Activity",
		"body" : [ "m_Activity" ],
		"description" : "what the monster is doing (animation)."
	},
	"Activity CBaseMonster::m_IdealActivity": {
		"prefix": "m_IdealActivity",
		"body" : [ "m_IdealActivity" ],
		"description" : "monster should switch to this activity."
	},
	"Activity CBaseMonster::m_GaitActivity": {
		"prefix": "m_GaitActivity",
		"body" : [ "m_GaitActivity" ],
		"description" : "gaitsequence."
	},
	"int CBaseMonster::m_LastHitGroup": {
		"prefix": "m_LastHitGroup",
		"body" : [ "m_LastHitGroup" ],
		"description" : "the last body region that took damage."
	},
	"MONSTERSTATE CBaseMonster::m_MonsterState": {
		"prefix": "m_MonsterState",
		"body" : [ "m_MonsterState" ],
		"description" : "monster's current state."
	},
	"MONSTERSTATE CBaseMonster::m_IdealMonsterState": {
		"prefix": "m_IdealMonsterState",
		"body" : [ "m_IdealMonsterState" ],
		"description" : "monster should change to this state."
	},
	"int CBaseMonster::m_iTaskStatus": {
		"prefix": "m_iTaskStatus",
		"body" : [ "m_iTaskStatus" ],
		"description" : "Task status."
	},
	"Schedule@ CBaseMonster::m_pSchedule": {
		"prefix": "m_pSchedule",
		"body" : [ "m_pSchedule" ],
		"description" : "Current schedule."
	},
	"Schedule@ CBaseMonster::m_pScheduleSaved": {
		"prefix": "m_pScheduleSaved",
		"body" : [ "m_pScheduleSaved" ],
		"description" : "For land_on_ground schedules (remember last schedule and continue)."
	},
	"int CBaseMonster::m_iScheduleIndex": {
		"prefix": "m_iScheduleIndex",
		"body" : [ "m_iScheduleIndex" ],
		"description" : "Schedule index."
	},
	"int CBaseMonster::m_movementGoal": {
		"prefix": "m_movementGoal",
		"body" : [ "m_movementGoal" ],
		"description" : "Goal that defines route."
	},
	"int CBaseMonster::m_iRouteIndex": {
		"prefix": "m_iRouteIndex",
		"body" : [ "m_iRouteIndex" ],
		"description" : "Index into m_Route[]."
	},
	"float CBaseMonster::m_moveWaitTime": {
		"prefix": "m_moveWaitTime",
		"body" : [ "m_moveWaitTime" ],
		"description" : "How long I should wait for something to move."
	},
	"float CBaseMonster::m_moveradius": {
		"prefix": "m_moveradius",
		"body" : [ "m_moveradius" ],
		"description" : "Minimum radius."
	},
	"Vector CBaseMonster::m_vecMoveGoal": {
		"prefix": "m_vecMoveGoal",
		"body" : [ "m_vecMoveGoal" ],
		"description" : "Kept around for node graph moves, so we know our ultimate goal."
	},
	"Activity CBaseMonster::m_movementActivity": {
		"prefix": "m_movementActivity",
		"body" : [ "m_movementActivity" ],
		"description" : "When moving, set this activity."
	},
	"int CBaseMonster::m_iAudibleList": {
		"prefix": "m_iAudibleList",
		"body" : [ "m_iAudibleList" ],
		"description" : "first index of a linked list of sounds that the monster can hear."
	},
	"int CBaseMonster::m_afSoundTypes": {
		"prefix": "m_afSoundTypes",
		"body" : [ "m_afSoundTypes" ],
		"description" : "Sound types that can be heard."
	},
	"Vector CBaseMonster::m_vecLastPosition": {
		"prefix": "m_vecLastPosition",
		"body" : [ "m_vecLastPosition" ],
		"description" : "monster sometimes wants to return to where it started after an operation.."
	},
	"int CBaseMonster::m_iHintNode": {
		"prefix": "m_iHintNode",
		"body" : [ "m_iHintNode" ],
		"description" : "this is the hint node that the monster is moving towards or performing active idle on.."
	},
	"int CBaseMonster::m_afMemory": {
		"prefix": "m_afMemory",
		"body" : [ "m_afMemory" ],
		"description" : "Monster memory."
	},
	"int CBaseMonster::m_bloodColor": {
		"prefix": "m_bloodColor",
		"body" : [ "m_bloodColor" ],
		"description" : "color of blood particles."
	},
	"int CBaseMonster::m_iMaxHealth": {
		"prefix": "m_iMaxHealth",
		"body" : [ "m_iMaxHealth" ],
		"description" : "keeps track of monster's maximum health value (for re-healing, etc)."
	},
	"Vector CBaseMonster::m_vecEnemyLKP": {
		"prefix": "m_vecEnemyLKP",
		"body" : [ "m_vecEnemyLKP" ],
		"description" : "last known position of enemy. (enemy's origin)."
	},
	"int CBaseMonster::m_cAmmoLoaded": {
		"prefix": "m_cAmmoLoaded",
		"body" : [ "m_cAmmoLoaded" ],
		"description" : "how much ammo is in the weapon (used to trigger reload anim sequences)."
	},
	"int CBaseMonster::m_afCapability": {
		"prefix": "m_afCapability",
		"body" : [ "m_afCapability" ],
		"description" : "tells us what a monster can/can't do."
	},
	"int CBaseMonster::m_afMoveShootCap": {
		"prefix": "m_afMoveShootCap",
		"body" : [ "m_afMoveShootCap" ],
		"description" : "tells us what a monster can/can't do, while moving."
	},
	"float CBaseMonster::m_flNextAttack": {
		"prefix": "m_flNextAttack",
		"body" : [ "m_flNextAttack" ],
		"description" : "cannot attack again until this time."
	},
	"int CBaseMonster::m_bitsDamageType": {
		"prefix": "m_bitsDamageType",
		"body" : [ "m_bitsDamageType" ],
		"description" : "what types of damage has monster (player) taken."
	},
	"float CBaseMonster::m_lastDamageAmount": {
		"prefix": "m_lastDamageAmount",
		"body" : [ "m_lastDamageAmount" ],
		"description" : "how much damage did monster (player) last take."
	},
	"float CBaseMonster::m_tbdPrev": {
		"prefix": "m_tbdPrev",
		"body" : [ "m_tbdPrev" ],
		"description" : "Time-based damage timer."
	},
	"entvars_t@ CBaseMonster::pevTimeBasedInflictor": {
		"prefix": "pevTimeBasedInflictor",
		"body" : [ "pevTimeBasedInflictor" ],
		"description" : "Time based damage inflictor."
	},
	"int CBaseMonster::m_failSchedule": {
		"prefix": "m_failSchedule",
		"body" : [ "m_failSchedule" ],
		"description" : "Schedule type to choose if current schedule fails."
	},
	"float CBaseMonster::m_flHungryTime": {
		"prefix": "m_flHungryTime",
		"body" : [ "m_flHungryTime" ],
		"description" : "Time based damage inflictor."
	},
	"float CBaseMonster::m_flDistTooFar": {
		"prefix": "m_flDistTooFar",
		"body" : [ "m_flDistTooFar" ],
		"description" : "if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy."
	},
	"float CBaseMonster::m_flDistLook": {
		"prefix": "m_flDistLook",
		"body" : [ "m_flDistLook" ],
		"description" : "distance monster sees (Default 2048)."
	},
	"int CBaseMonster::m_iTriggerCondition": {
		"prefix": "m_iTriggerCondition",
		"body" : [ "m_iTriggerCondition" ],
		"description" : "for scripted AI, this is the condition that will cause the activation of the monster's TriggerTarget."
	},
	"string_t CBaseMonster::m_iszTriggerTarget": {
		"prefix": "m_iszTriggerTarget",
		"body" : [ "m_iszTriggerTarget" ],
		"description" : "Name of target that should be fired."
	},
	"Vector CBaseMonster::m_HackedGunPos": {
		"prefix": "m_HackedGunPos",
		"body" : [ "m_HackedGunPos" ],
		"description" : "HACK until we can query end of gun."
	},
	"SCRIPTSTATE CBaseMonster::m_scriptState": {
		"prefix": "m_scriptState",
		"body" : [ "m_scriptState" ],
		"description" : "internal cinematic state."
	},
	"EHandle CBaseMonster::m_hCine": {
		"prefix": "m_hCine",
		"body" : [ "m_hCine" ],
		"description" : "Cinematic entity."
	},
	"EHandle CBaseMonster::m_hCineBlocker": {
		"prefix": "m_hCineBlocker",
		"body" : [ "m_hCineBlocker" ],
		"description" : "Entity that is blocking cinematic execution."
	},
	"float CBaseMonster::m_useTime": {
		"prefix": "m_useTime",
		"body" : [ "m_useTime" ],
		"description" : "Don't allow +USE until this time."
	},
	"string_t CBaseMonster::m_FormattedName": {
		"prefix": "m_FormattedName",
		"body" : [ "m_FormattedName" ],
		"description" : "The formatted name. For better name outputs. E.g. \"Alien Slave\" rather than \"alien_slave\"."
	},
	"int8 CBaseMonster::m_chTextureType": {
		"prefix": "m_chTextureType",
		"body" : [ "m_chTextureType" ],
		"description" : "Current texture type. See TextureType enum."
	},
	"bool CBaseMonster::m_fCanFearCreatures": {
		"prefix": "m_fCanFearCreatures",
		"body" : [ "m_fCanFearCreatures" ],
		"description" : "Whether this monster can fear creatures."
	},
	"float CBaseMonster::m_flAutomaticAttackTime": {
		"prefix": "m_flAutomaticAttackTime",
		"body" : [ "m_flAutomaticAttackTime" ],
		"description" : "How long an npc will attempt to fire full auto."
	},
	"float CBaseMonster::m_flFallVelocity": {
		"prefix": "m_flFallVelocity",
		"body" : [ "m_flFallVelocity" ],
		"description" : "Current fall speed."
	},
	"EHandle CBaseMonster::m_hGuardEnt": {
		"prefix": "m_hGuardEnt",
		"body" : [ "m_hGuardEnt" ],
		"description" : "Monster will guard this entity and turn down follow requests."
	},
	"string_t CBaseMonster::m_iszGuardEntName": {
		"prefix": "m_iszGuardEntName",
		"body" : [ "m_iszGuardEntName" ],
		"description" : "Guard entity name."
	},
	"Vector CBaseMonster::m_vecEffectGlowColor": {
		"prefix": "m_vecEffectGlowColor",
		"body" : [ "m_vecEffectGlowColor" ],
		"description" : "Glow shell."
	},
	"int CBaseMonster::m_iEffectBlockWeapons": {
		"prefix": "m_iEffectBlockWeapons",
		"body" : [ "m_iEffectBlockWeapons" ],
		"description" : "Monster can't use weapons."
	},
	"int CBaseMonster::m_iEffectInvulnerable": {
		"prefix": "m_iEffectInvulnerable",
		"body" : [ "m_iEffectInvulnerable" ],
		"description" : "is invulnerable (god mode)"
	},
	"int CBaseMonster::m_iEffectInvisible": {
		"prefix": "m_iEffectInvisible",
		"body" : [ "m_iEffectInvisible" ],
		"description" : "is invisible (render + non-targetable)"
	},
	"int CBaseMonster::m_iEffectNonSolid": {
		"prefix": "m_iEffectNonSolid",
		"body" : [ "m_iEffectNonSolid" ],
		"description" : "is non-solid"
	},
	"float CBaseMonster::m_flEffectRespiration": {
		"prefix": "m_flEffectRespiration",
		"body" : [ "m_flEffectRespiration" ],
		"description" : "Extra/less breathing time underwater in seconds"
	},
	"float CBaseMonster::m_flEffectGravity": {
		"prefix": "m_flEffectGravity",
		"body" : [ "m_flEffectGravity" ],
		"description" : "Gravity modifier (%)"
	},
	"float CBaseMonster::m_flEffectFriction": {
		"prefix": "m_flEffectFriction",
		"body" : [ "m_flEffectFriction" ],
		"description" : "Movement friction modifier (%)"
	},
	"float CBaseMonster::m_flEffectSpeed": {
		"prefix": "m_flEffectSpeed",
		"body" : [ "m_flEffectSpeed" ],
		"description" : "Movement speed modifier (%)"
	},
	"float CBaseMonster::m_flEffectDamage": {
		"prefix": "m_flEffectDamage",
		"body" : [ "m_flEffectDamage" ],
		"description" : "Damage modifier (%)"
	},
	"CBaseMonster@ CBasePlayer::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseToggle@ CBasePlayer::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseAnimating@ CBasePlayer::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CBasePlayer::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CBasePlayer::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBasePlayer::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBasePlayer::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBasePlayer::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBasePlayer::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBasePlayer::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBasePlayer::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBasePlayer::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBasePlayer::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBasePlayer::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBasePlayer::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBasePlayer::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBasePlayer::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBasePlayer::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBasePlayer::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBasePlayer::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBasePlayer::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBasePlayer::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBasePlayer::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBasePlayer::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBasePlayer::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBasePlayer::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBasePlayer::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBasePlayer::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBasePlayer::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBasePlayer::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBasePlayer::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBasePlayer::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBasePlayer::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBasePlayer::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBasePlayer::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBasePlayer::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBasePlayer::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBasePlayer::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBasePlayer::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBasePlayer::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBasePlayer::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBasePlayer::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBasePlayer::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBasePlayer::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBasePlayer::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBasePlayer::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBasePlayer::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBasePlayer::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBasePlayer::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBasePlayer::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBasePlayer::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBasePlayer::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBasePlayer::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBasePlayer::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBasePlayer::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBasePlayer::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBasePlayer::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBasePlayer::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBasePlayer::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBasePlayer::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBasePlayer::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBasePlayer::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBasePlayer::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBasePlayer::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBasePlayer::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBasePlayer::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBasePlayer::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBasePlayer::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBasePlayer::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBasePlayer::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBasePlayer::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBasePlayer::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBasePlayer::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBasePlayer::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBasePlayer::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBasePlayer::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBasePlayer::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBasePlayer::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBasePlayer::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBasePlayer::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBasePlayer::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBasePlayer::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBasePlayer::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBasePlayer::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBasePlayer::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBasePlayer::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBasePlayer::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBasePlayer::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBasePlayer::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBasePlayer::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBasePlayer::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBasePlayer::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBasePlayer::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBasePlayer::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBasePlayer::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBasePlayer::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBasePlayer::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBasePlayer::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBasePlayer::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBasePlayer::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBasePlayer::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBasePlayer::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBasePlayer::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBasePlayer::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBasePlayer::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBasePlayer::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBasePlayer::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBasePlayer::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBasePlayer::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBasePlayer::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CBasePlayer::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CBasePlayer::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CBasePlayer::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CBasePlayer::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CBasePlayer::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CBasePlayer::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CBasePlayer::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CBasePlayer::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CBasePlayer::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CBasePlayer::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CBasePlayer::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CBasePlayer::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CBasePlayer::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CBasePlayer::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CBasePlayer::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CBasePlayer::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CBasePlayer::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CBasePlayer::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CBasePlayer::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CBasePlayer::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CBasePlayer::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CBasePlayer::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"void CBasePlayer::LinearMove(Vector vecDest, float flSpeed)": {
		"prefix": "LinearMove",
		"body" : [ "LinearMove( ${1:Vector vecDest}, ${2:float flSpeed} )" ],
		"description" : "Performs linear movement."
	},
	"void CBasePlayer::AngularMove(Vector vecDestAngle, float flSpeed)": {
		"prefix": "AngularMove",
		"body" : [ "AngularMove( ${1:Vector vecDestAngle}, ${2:float flSpeed} )" ],
		"description" : "Performs angular movement."
	},
	"bool CBasePlayer::IsToggleLockedByMaster()": {
		"prefix": "IsToggleLockedByMaster",
		"body" : [ "IsToggleLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master. Separate from IsLockedByMaster due to limitations."
	},
	"InventoryRules@ CBasePlayer::get_m_pInventoryRules() const": {
		"prefix": "get_m_pInventoryRules",
		"body" : [ "get_m_pInventoryRules()" ],
		"description" : "The inventory rules."
	},
	"EHandle& CBasePlayer::m_hOldEnemy(size_t uiIndex)": {
		"prefix": "m_hOldEnemy",
		"body" : [ "m_hOldEnemy( ${1:size_t uiIndex} )" ],
		"description" : "Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."
	},
	"Vector& CBasePlayer::m_vecOldEnemy(size_t uiIndex)": {
		"prefix": "m_vecOldEnemy",
		"body" : [ "m_vecOldEnemy( ${1:size_t uiIndex} )" ],
		"description" : "Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."
	},
	"Waypoint& CBasePlayer::m_Route(size_t uiIndex)": {
		"prefix": "m_Route",
		"body" : [ "m_Route( ${1:size_t uiIndex} )" ],
		"description" : "Positions of movement. Index must be between 0 and ROUTE_SIZE"
	},
	"int8& CBasePlayer::m_rgbTimeBasedDamage(size_t uiIndex)": {
		"prefix": "m_rgbTimeBasedDamage",
		"body" : [ "m_rgbTimeBasedDamage( ${1:size_t uiIndex} )" ],
		"description" : "time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED."
	},
	"void CBasePlayer::MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "MonsterUse",
		"body" : [ "MonsterUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Will make a monster angry at whomever activated it."
	},
	"void CBasePlayer::Look(int iDistance)": {
		"prefix": "Look",
		"body" : [ "Look( ${1:int iDistance} )" ],
		"description" : "Look - Base class monster function to find enemies or. food by sight. iDistance is distance (in units) that the. monster can see. Sets the sight bits of the m_afConditions mask to indicate. which types of entities were sighted. Function also sets the Looker's m_pLink. to the head of a link list that contains all visible ents. (linked via each ent's m_pLink field)"
	},
	"void CBasePlayer::RunAI()": {
		"prefix": "RunAI",
		"body" : [ "RunAI()" ],
		"description" : "Runs this monster's AI."
	},
	"void CBasePlayer::Listen()": {
		"prefix": "Listen",
		"body" : [ "Listen()" ],
		"description" : "Listens for anything that is within audible distance."
	},
	"bool CBasePlayer::ShouldFadeOnDeath()": {
		"prefix": "ShouldFadeOnDeath",
		"body" : [ "ShouldFadeOnDeath()" ],
		"description" : "Returns whether this monster should fade on death."
	},
	"float CBasePlayer::ChangeYaw(int iSpeed)": {
		"prefix": "ChangeYaw",
		"body" : [ "ChangeYaw( ${1:int iSpeed} )" ],
		"description" : "turns a monster towards its ideal_yaw"
	},
	"float CBasePlayer::VecToYaw(Vector vecDir)": {
		"prefix": "VecToYaw",
		"body" : [ "VecToYaw( ${1:Vector vecDir} )" ],
		"description" : "turns a directional vector into a yaw value that points down that vector."
	},
	"float CBasePlayer::FlYawDiff()": {
		"prefix": "FlYawDiff",
		"body" : [ "FlYawDiff()" ],
		"description" : "returns the difference (in degrees) between monster's current yaw and ideal_yaw. Positive result is left turn, negative is right turn."
	},
	"float CBasePlayer::DamageForce(float flDamage)": {
		"prefix": "DamageForce",
		"body" : [ "DamageForce( ${1:float flDamage} )" ],
		"description" : "Returns the amount of force applied to this monster when the given amount of damage is done."
	},
	"void CBasePlayer::SetupFriendly()": {
		"prefix": "SetupFriendly",
		"body" : [ "SetupFriendly()" ],
		"description" : "use this overridden to make some other friendly monsters"
	},
	"void CBasePlayer::MonsterInit()": {
		"prefix": "MonsterInit",
		"body" : [ "MonsterInit()" ],
		"description" : "Initializes the monster"
	},
	"void CBasePlayer::MonsterInitDead()": {
		"prefix": "MonsterInitDead",
		"body" : [ "MonsterInitDead()" ],
		"description" : "Call after animation/pose is set up"
	},
	"void CBasePlayer::BecomeDead(float flSavedHealth)": {
		"prefix": "BecomeDead",
		"body" : [ "BecomeDead( ${1:float flSavedHealth} )" ],
		"description" : "Makes the monster become dead"
	},
	"void CBasePlayer::Revive()": {
		"prefix": "Revive",
		"body" : [ "Revive()" ],
		"description" : "Revives the monster"
	},
	"void CBasePlayer::StartMonster()": {
		"prefix": "StartMonster",
		"body" : [ "StartMonster()" ],
		"description" : "Starts the monster"
	},
	"void CBasePlayer::BestVisibleEnemy()": {
		"prefix": "BestVisibleEnemy",
		"body" : [ "BestVisibleEnemy()" ],
		"description" : "finds best visible enemy for attack"
	},
	"bool CBasePlayer::FInViewCone(CBaseEntity@ pEntity)": {
		"prefix": "FInViewCone",
		"body" : [ "FInViewCone( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "see if pEntity is in monster's view cone"
	},
	"bool CBasePlayer::FInViewCone(const Vector& in vecOrigin)": {
		"prefix": "FInViewCone",
		"body" : [ "FInViewCone( ${1:const Vector& in vecOrigin} )" ],
		"description" : "see if given location is in monster's view cone"
	},
	"int CBasePlayer::CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false)": {
		"prefix": "CheckLocalMove",
		"body" : [ "CheckLocalMove( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd,CBaseEntity@ pTarget}, ${3:float& out flDist}, ${4:Vector& out vecEndPosition}, ${5:bool fOriginalCheck = false} )" ],
		"description" : "finds best visible enemy for attack"
	},
	"void CBasePlayer::Move(float flInterval = 0.1f)": {
		"prefix": "Move",
		"body" : [ "Move( ${1:float flInterval = 0.1f} )" ],
		"description" : "Starts the monster"
	},
	"void CBasePlayer::MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval)": {
		"prefix": "MoveExecute",
		"body" : [ "MoveExecute( ${1:CBaseEntity@ pTargetEnt}, ${2:const Vector& in vecDir}, ${3:float flInterval} )" ],
		"description" : "Starts the monster"
	},
	"bool CBasePlayer::ShouldAdvanceRoute(float flWaypointDist)": {
		"prefix": "ShouldAdvanceRoute",
		"body" : [ "ShouldAdvanceRoute( ${1:float flWaypointDist} )" ],
		"description" : "Returns whether this monster should advance its route"
	},
	"Activity CBasePlayer::GetStoppedActivity()": {
		"prefix": "GetStoppedActivity",
		"body" : [ "GetStoppedActivity()" ],
		"description" : "Gets the stopped activity"
	},
	"void CBasePlayer::Stop()": {
		"prefix": "Stop",
		"body" : [ "Stop()" ],
		"description" : "Stops this monster moving"
	},
	"void CBasePlayer::StopAnimation()": {
		"prefix": "StopAnimation",
		"body" : [ "StopAnimation()" ],
		"description" : "This will stop animation until you call ResetSequenceInfo() at some point in the future"
	},
	"bool CBasePlayer::CheckRangeAttack1(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1",
		"body" : [ "CheckRangeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBasePlayer::CheckRangeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1_Move",
		"body" : [ "CheckRangeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBasePlayer::CheckRangeAttack2(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2",
		"body" : [ "CheckRangeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBasePlayer::CheckRangeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2_Move",
		"body" : [ "CheckRangeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBasePlayer::CheckMeleeAttack1(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1",
		"body" : [ "CheckMeleeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBasePlayer::CheckMeleeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1_Move",
		"body" : [ "CheckMeleeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBasePlayer::CheckMeleeAttack2(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2",
		"body" : [ "CheckMeleeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBasePlayer::CheckMeleeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2_Move",
		"body" : [ "CheckMeleeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CBasePlayer::CheckTankUsage()": {
		"prefix": "CheckTankUsage",
		"body" : [ "CheckTankUsage()" ],
		"description" : "Checks whether the monster can use a func_tank. Return true if possible."
	},
	"bool CBasePlayer::FHaveSchedule()": {
		"prefix": "FHaveSchedule",
		"body" : [ "FHaveSchedule()" ],
		"description" : "Returns whether this monster has a schedule."
	},
	"bool CBasePlayer::FScheduleValid()": {
		"prefix": "FScheduleValid",
		"body" : [ "FScheduleValid()" ],
		"description" : "Returns whether this monster's schedule is valid."
	},
	"void CBasePlayer::ClearSchedule()": {
		"prefix": "ClearSchedule",
		"body" : [ "ClearSchedule()" ],
		"description" : "Clears this monster's schedule."
	},
	"bool CBasePlayer::FScheduleDone()": {
		"prefix": "FScheduleDone",
		"body" : [ "FScheduleDone()" ],
		"description" : "Returns whether this monster's schedule is done."
	},
	"void CBasePlayer::ChangeSchedule(Schedule@ pNewSchedule)": {
		"prefix": "ChangeSchedule",
		"body" : [ "ChangeSchedule( ${1:Schedule@ pNewSchedule} )" ],
		"description" : "Changes this monster's schedule."
	},
	"bool CBasePlayer::NextScheduledTask()": {
		"prefix": "NextScheduledTask",
		"body" : [ "NextScheduledTask()" ],
		"description" : "Moves to the next scheduled task."
	},
	"Schedule@ CBasePlayer::ScheduleInList(const string& in szName, array<Schedule@>@ pArray)": {
		"prefix": "ScheduleInList",
		"body" : [ "ScheduleInList( ${1:const string& in szName}, ${2:array<Schedule@>@ pArray} )" ],
		"description" : "Returns the schedule with name szName if it's in the list, NULL otherwise."
	},
	"Schedule@ CBasePlayer::ScheduleFromName(const string& in szName)": {
		"prefix": "ScheduleFromName",
		"body" : [ "ScheduleFromName( ${1:const string& in szName} )" ],
		"description" : "Returns the schedule with name szName if it exists, NULL otherwise."
	},
	"void CBasePlayer::MaintainSchedule()": {
		"prefix": "MaintainSchedule",
		"body" : [ "MaintainSchedule()" ],
		"description" : "Maintains the monster's schedule."
	},
	"void CBasePlayer::StartTask(Task@ pTask)": {
		"prefix": "StartTask",
		"body" : [ "StartTask( ${1:Task@ pTask} )" ],
		"description" : "Starts the given task."
	},
	"void CBasePlayer::RunTask(Task@ pTask)": {
		"prefix": "RunTask",
		"body" : [ "RunTask( ${1:Task@ pTask} )" ],
		"description" : "Runs the given task."
	},
	"Schedule@ CBasePlayer::GetScheduleOfType(int iType)": {
		"prefix": "GetScheduleOfType",
		"body" : [ "GetScheduleOfType( ${1:int iType} )" ],
		"description" : "Gets one of the available schedules of the given type."
	},
	"Schedule@ CBasePlayer::GetSchedule()": {
		"prefix": "GetSchedule",
		"body" : [ "GetSchedule()" ],
		"description" : "Gets the current schedule."
	},
	"void CBasePlayer::ScheduleChange()": {
		"prefix": "ScheduleChange",
		"body" : [ "ScheduleChange()" ],
		"description" : "Called after the monster's schedule changes."
	},
	"bool CBasePlayer::CanPlaySequence(const bool bDisregardState, int iInterruptLevel)": {
		"prefix": "CanPlaySequence",
		"body" : [ "CanPlaySequence( ${1:const bool bDisregardState}, ${2:int iInterruptLevel} )" ],
		"description" : "Returns whether this monster can play its sequence."
	},
	"bool CBasePlayer::CanPlaySentence(const bool bDisregardState)": {
		"prefix": "CanPlaySentence",
		"body" : [ "CanPlaySentence( ${1:const bool bDisregardState} )" ],
		"description" : "Returns whether this monster can play its sentence."
	},
	"void CBasePlayer::PlaySentence(const string& in szSentence, float duration, float volume, float attenuation)": {
		"prefix": "PlaySentence",
		"body" : [ "PlaySentence( ${1:const string& in szSentence}, ${2:float duration}, ${3:float volume}, ${4:float attenuation} )" ],
		"description" : "Plays the given sentence."
	},
	"void CBasePlayer::PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener)": {
		"prefix": "PlayScriptedSentence",
		"body" : [ "PlayScriptedSentence( ${1:const string& in szSentence}, ${2:float duration}, ${3:float volume}, ${4:float attenuation}, ${5:const bool bConcurrent}, ${6:CBaseEntity@ pListener} )" ],
		"description" : "Plays the given scripted sentence."
	},
	"void CBasePlayer::SentenceStop()": {
		"prefix": "SentenceStop",
		"body" : [ "SentenceStop()" ],
		"description" : "Stops playing its current sentence."
	},
	"Task@ CBasePlayer::GetTask()": {
		"prefix": "GetTask",
		"body" : [ "GetTask()" ],
		"description" : "Gets the current task."
	},
	"MONSTERSTATE CBasePlayer::GetIdealState()": {
		"prefix": "GetIdealState",
		"body" : [ "GetIdealState()" ],
		"description" : "Gets the ideal monster state."
	},
	"void CBasePlayer::SetActivity(Activity newActivity)": {
		"prefix": "SetActivity",
		"body" : [ "SetActivity( ${1:Activity newActivity} )" ],
		"description" : "Sets the current activity."
	},
	"void CBasePlayer::SetGaitActivity(Activity newActivity)": {
		"prefix": "SetGaitActivity",
		"body" : [ "SetGaitActivity( ${1:Activity newActivity} )" ],
		"description" : "Sets the current gait activity."
	},
	"void CBasePlayer::SetSequenceByName(const string& in szSequence)": {
		"prefix": "SetSequenceByName",
		"body" : [ "SetSequenceByName( ${1:const string& in szSequence} )" ],
		"description" : "Sets the current sequence by name."
	},
	"void CBasePlayer::SetState(MONSTERSTATE state)": {
		"prefix": "SetState",
		"body" : [ "SetState( ${1:MONSTERSTATE state} )" ],
		"description" : "Sets the current monster state."
	},
	"void CBasePlayer::ReportAIState()": {
		"prefix": "ReportAIState",
		"body" : [ "ReportAIState()" ],
		"description" : "Reports the AI state."
	},
	"void CBasePlayer::CheckAttacks(CBaseEntity@ pTarget, float flDist)": {
		"prefix": "CheckAttacks",
		"body" : [ "CheckAttacks( ${1:CBaseEntity@ pTarget}, ${2:float flDist} )" ],
		"description" : "Check attacks to the given enemy at the given distance."
	},
	"void CBasePlayer::CheckAttacks_Move(CBaseEntity@ pTarget, float flDist)": {
		"prefix": "CheckAttacks_Move",
		"body" : [ "CheckAttacks_Move( ${1:CBaseEntity@ pTarget}, ${2:float flDist} )" ],
		"description" : "Check attacks to the given enemy at the given distance while moving."
	},
	"bool CBasePlayer::CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos)": {
		"prefix": "CheckAttacksFromPosition",
		"body" : [ "CheckAttacksFromPosition( ${1:CBaseEntity@ pTarget}, ${2:float flDist}, ${3:Vector vecPos} )" ],
		"description" : "Check whether attacks are possible from the given position."
	},
	"bool CBasePlayer::CheckEnemy(CBaseEntity@ pEnemy)": {
		"prefix": "CheckEnemy",
		"body" : [ "CheckEnemy( ${1:CBaseEntity@ pEnemy} )" ],
		"description" : "part of the Condition collection process, gets and stores data and conditions pertaining to a monster's enemy. Returns true if Enemy LKP was updated."
	},
	"void CBasePlayer::PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos)": {
		"prefix": "PushEnemy",
		"body" : [ "PushEnemy( ${1:CBaseEntity@ pTarget}, ${2:Vector& in vecLastKnownPos} )" ],
		"description" : "Remember the last few enemies, always remember the player."
	},
	"bool CBasePlayer::PopEnemy()": {
		"prefix": "PopEnemy",
		"body" : [ "PopEnemy()" ],
		"description" : "Try remembering the last few enemies."
	},
	"bool CBasePlayer::FGetNodeRoute(Vector vecDest)": {
		"prefix": "FGetNodeRoute",
		"body" : [ "FGetNodeRoute( ${1:Vector vecDest} )" ],
		"description" : "tries to build an entire node path from. the callers origin to the passed vector. If this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route. true is returned if the operation  succeeds (path is valid) or false if failed (no path  exists )."
	},
	"bool CBasePlayer::TestFGetNodeRoute(Vector vecDest)": {
		"prefix": "TestFGetNodeRoute",
		"body" : [ "TestFGetNodeRoute( ${1:Vector vecDest} )" ],
		"description" : "TEST FGetNodeRoute."
	},
	"void CBasePlayer::TaskComplete()": {
		"prefix": "TaskComplete",
		"body" : [ "TaskComplete()" ],
		"description" : "Sets the task status to complete."
	},
	"void CBasePlayer::MovementComplete()": {
		"prefix": "MovementComplete",
		"body" : [ "MovementComplete()" ],
		"description" : "Called when movement has completed."
	},
	"void CBasePlayer::TaskFail()": {
		"prefix": "TaskFail",
		"body" : [ "TaskFail()" ],
		"description" : "Sets the condition bit for a failed task."
	},
	"void CBasePlayer::TaskBegin()": {
		"prefix": "TaskBegin",
		"body" : [ "TaskBegin()" ],
		"description" : "Sets the task status to running."
	},
	"bool CBasePlayer::TaskIsRunning()": {
		"prefix": "TaskIsRunning",
		"body" : [ "TaskIsRunning()" ],
		"description" : "Returns whether a task is running."
	},
	"bool CBasePlayer::TaskIsComplete()": {
		"prefix": "TaskIsComplete",
		"body" : [ "TaskIsComplete()" ],
		"description" : "Returns whether the task is complete."
	},
	"bool CBasePlayer::MovementIsComplete()": {
		"prefix": "MovementIsComplete",
		"body" : [ "MovementIsComplete()" ],
		"description" : "Returns whether movement is complete."
	},
	"int CBasePlayer::IScheduleFlags()": {
		"prefix": "IScheduleFlags",
		"body" : [ "IScheduleFlags()" ],
		"description" : "Returns an integer with all Conditions. bits that are currently set and also set in the current. schedule's Interrupt mask."
	},
	"void CBasePlayer::MakeIdealYaw(Vector vecTarget)": {
		"prefix": "MakeIdealYaw",
		"body" : [ "MakeIdealYaw( ${1:Vector vecTarget} )" ],
		"description" : "gets a yaw value for the caller that would. face the supplied vector. Value is stuffed into the monster's. ideal_yaw."
	},
	"void CBasePlayer::SetYawSpeed()": {
		"prefix": "SetYawSpeed",
		"body" : [ "SetYawSpeed()" ],
		"description" : "Allows different yaw_speeds for each activity."
	},
	"int CBasePlayer::RouteClassify(int iMoveFlag)": {
		"prefix": "RouteClassify",
		"body" : [ "RouteClassify( ${1:int iMoveFlag} )" ],
		"description" : "Returns the MOVEGOAL for the given move flag."
	},
	"bool CBasePlayer::CheckAttacker(CBaseEntity@ pAttacker)": {
		"prefix": "CheckAttacker",
		"body" : [ "CheckAttacker( ${1:CBaseEntity@ pAttacker} )" ],
		"description" : "Determine if we should ignore damage."
	},
	"void CBasePlayer::SetConditions(int iConditions)": {
		"prefix": "SetConditions",
		"body" : [ "SetConditions( ${1:int iConditions} )" ],
		"description" : "Sets AI conditions."
	},
	"void CBasePlayer::ClearConditions(int iConditions)": {
		"prefix": "ClearConditions",
		"body" : [ "ClearConditions( ${1:int iConditions} )" ],
		"description" : "Clears AI conditions."
	},
	"bool CBasePlayer::HasConditions(int iConditions) const": {
		"prefix": "HasConditions",
		"body" : [ "HasConditions( ${1:int iConditions} )" ],
		"description" : "Returns whether this monster has any of the given AI conditions."
	},
	"bool CBasePlayer::HasAllConditions(int iConditions) const": {
		"prefix": "HasAllConditions",
		"body" : [ "HasAllConditions( ${1:int iConditions} )" ],
		"description" : "Returns whether this monster has all of the given AI conditions."
	},
	"CSound@ CBasePlayer::PBestSound()": {
		"prefix": "PBestSound",
		"body" : [ "PBestSound()" ],
		"description" : "Returns a pointer to the sound the monster should react to."
	},
	"bool CBasePlayer::FShouldEat()": {
		"prefix": "FShouldEat",
		"body" : [ "FShouldEat()" ],
		"description" : "Returns whether this monster should eat."
	},
	"void CBasePlayer::Eat(float flFullDuration)": {
		"prefix": "Eat",
		"body" : [ "Eat( ${1:float flFullDuration} )" ],
		"description" : "Make the monster 'full' for a while."
	},
	"bool CBasePlayer::FCheckAITrigger()": {
		"prefix": "FCheckAITrigger",
		"body" : [ "FCheckAITrigger()" ],
		"description" : "Checks and, if necessary, fires the monster's trigger target."
	},
	"bool CBasePlayer::NoFriendlyFire()": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire()" ],
		"description" : "Returns whether attacking at this time would result in friendly fire"
	},
	"bool CBasePlayer::NoFriendlyFire(Vector vecPos)": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire( ${1:Vector vecPos} )" ],
		"description" : "Returns whether attacking at this time from the given location would result in friendly fire"
	},
	"bool CBasePlayer::NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget)": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire( ${1:Vector vecPos}, ${2:CBaseEntity@ pTarget} )" ],
		"description" : "Returns whether attacking the given target at this time from the given location would result in friendly fire"
	},
	"bool CBasePlayer::NoFriendlyFireToPos(Vector vecPos)": {
		"prefix": "NoFriendlyFireToPos",
		"body" : [ "NoFriendlyFireToPos( ${1:Vector vecPos} )" ],
		"description" : "Returns whether attacking the target location at this time would result in friendly fire"
	},
	"bool CBasePlayer::GetEnemy()": {
		"prefix": "GetEnemy",
		"body" : [ "GetEnemy()" ],
		"description" : "Tries to find the best suitable enemy for this monster."
	},
	"void CBasePlayer::GibMonster()": {
		"prefix": "GibMonster",
		"body" : [ "GibMonster()" ],
		"description" : "Gibs the monster."
	},
	"bool CBasePlayer::ShouldGibMonster(int iGib)": {
		"prefix": "ShouldGibMonster",
		"body" : [ "ShouldGibMonster( ${1:int iGib} )" ],
		"description" : "Returns whether the monster should be gibbed given the gib type. See GIB enum."
	},
	"void CBasePlayer::CallGibMonster()": {
		"prefix": "CallGibMonster",
		"body" : [ "CallGibMonster()" ],
		"description" : "Determines whether to gib or fade this monster, and acts accordingly."
	},
	"bool CBasePlayer::HasHumanGibs()": {
		"prefix": "HasHumanGibs",
		"body" : [ "HasHumanGibs()" ],
		"description" : "Returns whether this monster has human gibs."
	},
	"bool CBasePlayer::HasAlienGibs()": {
		"prefix": "HasAlienGibs",
		"body" : [ "HasAlienGibs()" ],
		"description" : "Returns whether this monster has alien gibs."
	},
	"void CBasePlayer::FadeMonster()": {
		"prefix": "FadeMonster",
		"body" : [ "FadeMonster()" ],
		"description" : "Fades this monster. Note: does not kill the monster."
	},
	"Vector CBasePlayer::ShootAtEnemy(const Vector& in vecShootOrigin)": {
		"prefix": "ShootAtEnemy",
		"body" : [ "ShootAtEnemy( ${1:const Vector& in vecShootOrigin} )" ],
		"description" : "Shoots at the specified location."
	},
	"void CBasePlayer::DeathSound()": {
		"prefix": "DeathSound",
		"body" : [ "DeathSound()" ],
		"description" : "Plays this monster's death sound."
	},
	"void CBasePlayer::AlertSound()": {
		"prefix": "AlertSound",
		"body" : [ "AlertSound()" ],
		"description" : "Plays this monster's alert sound."
	},
	"void CBasePlayer::IdleSound()": {
		"prefix": "IdleSound",
		"body" : [ "IdleSound()" ],
		"description" : "Plays this monster's idle sound."
	},
	"void CBasePlayer::PainSound()": {
		"prefix": "PainSound",
		"body" : [ "PainSound()" ],
		"description" : "Plays this monster's pain sound."
	},
	"void CBasePlayer::StartPlayerFollowing(CBaseEntity@ pLeader, bool bSilent = false)": {
		"prefix": "StartPlayerFollowing",
		"body" : [ "StartPlayerFollowing( ${1:CBaseEntity@ pLeader}, ${2:bool bSilent = false} )" ],
		"description" : "Starts following its target."
	},
	"void CBasePlayer::StopPlayerFollowing(const bool clearSchedule, bool bSilent = false)": {
		"prefix": "StopPlayerFollowing",
		"body" : [ "StopPlayerFollowing( ${1:const bool clearSchedule}, ${2:bool bSilent = false} )" ],
		"description" : "Stops following its target."
	},
	"void CBasePlayer::Remember(int iMemory)": {
		"prefix": "Remember",
		"body" : [ "Remember( ${1:int iMemory} )" ],
		"description" : "Makes this monster remember the given memories."
	},
	"void CBasePlayer::Forget(int iMemory)": {
		"prefix": "Forget",
		"body" : [ "Forget( ${1:int iMemory} )" ],
		"description" : "Makes this monster forget the given memories."
	},
	"bool CBasePlayer::HasMemory(int iMemory) const": {
		"prefix": "HasMemory",
		"body" : [ "HasMemory( ${1:int iMemory} )" ],
		"description" : "Returns whether this monster remembers any of the given memories."
	},
	"bool CBasePlayer::HasAllMemories(int iMemory) const": {
		"prefix": "HasAllMemories",
		"body" : [ "HasAllMemories( ${1:int iMemory} )" ],
		"description" : "Returns whether this monster remembers all of the given memories."
	},
	"bool CBasePlayer::ExitScriptedSequence()": {
		"prefix": "ExitScriptedSequence",
		"body" : [ "ExitScriptedSequence()" ],
		"description" : "Exits the scripted sequence this monster is currently in, if any."
	},
	"bool CBasePlayer::CineCleanup()": {
		"prefix": "CineCleanup",
		"body" : [ "CineCleanup()" ],
		"description" : "Cleans up after a cinematic event."
	},
	"CBaseEntity@ CBasePlayer::DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng)": {
		"prefix": "DropItem",
		"body" : [ "DropItem( ${1:const string& in szItemName}, ${2:const Vector& in vecPos}, ${3:const Vector& in vecAng} )" ],
		"description" : "Drops the given item from the given position at the given angle."
	},
	"void CBasePlayer::ShockGlowEffect(bool fMode)": {
		"prefix": "ShockGlowEffect",
		"body" : [ "ShockGlowEffect( ${1:bool fMode} )" ],
		"description" : "Turns the shock glow effect on or off."
	},
	"void CBasePlayer::FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)": {
		"prefix": "FollowerPlayerUse",
		"body" : [ "FollowerPlayerUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue} )" ],
		"description" : "Use method for following players (set only if friendly)"
	},
	"bool CBasePlayer::IsPlayerFollowing()": {
		"prefix": "IsPlayerFollowing",
		"body" : [ "IsPlayerFollowing()" ],
		"description" : "Returns whether this monster is following a player."
	},
	"bool CBasePlayer::CanPlayerFollow()": {
		"prefix": "CanPlayerFollow",
		"body" : [ "CanPlayerFollow()" ],
		"description" : "Returns whether this monster can follow a player."
	},
	"void CBasePlayer::StartPlayerFollowing(CBaseEntity@ pLeader)": {
		"prefix": "StartPlayerFollowing",
		"body" : [ "StartPlayerFollowing( ${1:CBaseEntity@ pLeader} )" ],
		"description" : "Starts following a given player."
	},
	"void CBasePlayer::StopPlayerFollowing(const bool bClearSchedule)": {
		"prefix": "StopPlayerFollowing",
		"body" : [ "StopPlayerFollowing( ${1:const bool bClearSchedule} )" ],
		"description" : "Stops following a player."
	},
	"string CBasePlayer::m_szTextureName()": {
		"prefix": "m_szTextureName",
		"body" : [ "m_szTextureName()" ],
		"description" : "Current texture name we're standing on."
	},
	"void CBasePlayer::MedicCallSound(float flDistance = 0.0f)": {
		"prefix": "MedicCallSound",
		"body" : [ "MedicCallSound( ${1:float flDistance = 0.0f} )" ],
		"description" : "Medic call sound."
	},
	"InventoryList@ CBasePlayer::get_m_pInventory() const": {
		"prefix": "get_m_pInventory",
		"body" : [ "get_m_pInventory()" ],
		"description" : "The inventory items this monster has"
	},
	"void CBasePlayer::ClearEnemyList()": {
		"prefix": "ClearEnemyList",
		"body" : [ "ClearEnemyList()" ],
		"description" : "Clears this monster's list of enemies"
	},
	"void CBasePlayer::ApplyEffects()": {
		"prefix": "ApplyEffects",
		"body" : [ "ApplyEffects()" ],
		"description" : "Re-calculate compounded effect modifiers and apply to the monster"
	},
	"void CBasePlayer::ResetEffects()": {
		"prefix": "ResetEffects",
		"body" : [ "ResetEffects()" ],
		"description" : "Reset all effect modifiers"
	},
	"CBasePlayerItem@ CBasePlayer::m_rgpPlayerItems(size_t uiIndex)": {
		"prefix": "m_rgpPlayerItems",
		"body" : [ "m_rgpPlayerItems( ${1:size_t uiIndex} )" ],
		"description" : "Get player weapons. Index must be between 0 and MAX_ITEM_TYPES."
	},
	"int CBasePlayer::m_rgAmmo(size_t uiIndex)": {
		"prefix": "m_rgAmmo",
		"body" : [ "m_rgAmmo( ${1:size_t uiIndex} )" ],
		"description" : "Get player ammo amount."
	},
	"void CBasePlayer::m_rgAmmo(size_t uiIndex, int iValue)": {
		"prefix": "m_rgAmmo",
		"body" : [ "m_rgAmmo( ${1:size_t uiIndex}, ${2:int iValue} )" ],
		"description" : "Set player ammo amount."
	},
	"void CBasePlayer::Jump()": {
		"prefix": "Jump",
		"body" : [ "Jump()" ],
		"description" : "Makes the player jump."
	},
	"void CBasePlayer::Duck()": {
		"prefix": "Duck",
		"body" : [ "Duck()" ],
		"description" : "Makes the player duck."
	},
	"bool CBasePlayer::IsConnected() const": {
		"prefix": "IsConnected",
		"body" : [ "IsConnected()" ],
		"description" : "Returns whether this player is connected."
	},
	"void CBasePlayer::PackDeadPlayerItems()": {
		"prefix": "PackDeadPlayerItems",
		"body" : [ "PackDeadPlayerItems()" ],
		"description" : "Packs player weapons into a weapon box if possible."
	},
	"void CBasePlayer::RemoveAllItems(const bool fRemoveSuit)": {
		"prefix": "RemoveAllItems",
		"body" : [ "RemoveAllItems( ${1:const bool fRemoveSuit} )" ],
		"description" : "Removes all items from the player's inventory."
	},
	"bool CBasePlayer::SwitchWeapon(CBasePlayerItem@ pWeapon)": {
		"prefix": "SwitchWeapon",
		"body" : [ "SwitchWeapon( ${1:CBasePlayerItem@ pWeapon} )" ],
		"description" : "Switches weapons to the given item."
	},
	"void CBasePlayer::HolsterWeapon()": {
		"prefix": "HolsterWeapon",
		"body" : [ "HolsterWeapon()" ],
		"description" : "Holster weapon."
	},
	"void CBasePlayer::DeployWeapon()": {
		"prefix": "DeployWeapon",
		"body" : [ "DeployWeapon()" ],
		"description" : "Deploy weapon."
	},
	"void CBasePlayer::BlockWeapons(CBaseEntity@ pSetter)": {
		"prefix": "BlockWeapons",
		"body" : [ "BlockWeapons( ${1:CBaseEntity@ pSetter} )" ],
		"description" : "Hides active weapon and blocks weapon selection."
	},
	"void CBasePlayer::UnblockWeapons(CBaseEntity@ pSetter)": {
		"prefix": "UnblockWeapons",
		"body" : [ "UnblockWeapons( ${1:CBaseEntity@ pSetter} )" ],
		"description" : "Shows active weapon and unblocks weapon selection."
	},
	"bool CBasePlayer::GetWeaponsBlocked()": {
		"prefix": "GetWeaponsBlocked",
		"body" : [ "GetWeaponsBlocked()" ],
		"description" : "Returns whether the weapons are currently blocked."
	},
	"void CBasePlayer::SetItemPickupTimes(float flTime)": {
		"prefix": "SetItemPickupTimes",
		"body" : [ "SetItemPickupTimes( ${1:float flTime} )" ],
		"description" : "Sets all item pickup times the given absolute time."
	},
	"bool CBasePlayer::IsOnLadder() const": {
		"prefix": "IsOnLadder",
		"body" : [ "IsOnLadder()" ],
		"description" : "Returns whether the player is on a ladder."
	},
	"bool CBasePlayer::FlashlightIsOn() const": {
		"prefix": "FlashlightIsOn",
		"body" : [ "FlashlightIsOn()" ],
		"description" : "Returns whether the flashlight is on."
	},
	"void CBasePlayer::FlashlightTurnOn()": {
		"prefix": "FlashlightTurnOn",
		"body" : [ "FlashlightTurnOn()" ],
		"description" : "Turns on the flashlight."
	},
	"void CBasePlayer::FlashlightTurnOff()": {
		"prefix": "FlashlightTurnOff",
		"body" : [ "FlashlightTurnOff()" ],
		"description" : "Turns off the flashlight."
	},
	"void CBasePlayer::SetAnimation(PLAYER_ANIM anim, int mode = 0)": {
		"prefix": "SetAnimation",
		"body" : [ "SetAnimation( ${1:PLAYER_ANIM anim}, ${2:int mode = 0} )" ],
		"description" : "Set the player's animation."
	},
	"string CBasePlayer::get_m_szAnimExtension() const": {
		"prefix": "get_m_szAnimExtension",
		"body" : [ "get_m_szAnimExtension()" ],
		"description" : "Gets the current animation extension."
	},
	"void CBasePlayer::set_m_szAnimExtension(const string& in szAnimExtension)": {
		"prefix": "set_m_szAnimExtension",
		"body" : [ "set_m_szAnimExtension( ${1:const string& in szAnimExtension} )" ],
		"description" : "Sets the current animation extension."
	},
	"void CBasePlayer::CheatImpulseCommands(int iImpulse)": {
		"prefix": "CheatImpulseCommands",
		"body" : [ "CheatImpulseCommands( ${1:int iImpulse} )" ],
		"description" : "Triggers the given impulse command."
	},
	"void CBasePlayer::StartDeathCam()": {
		"prefix": "StartDeathCam",
		"body" : [ "StartDeathCam()" ],
		"description" : "Starts the death camera."
	},
	"bool CBasePlayer::CanSpawn()": {
		"prefix": "CanSpawn",
		"body" : [ "CanSpawn()" ],
		"description" : "Returns whether this player can spawn."
	},
	"void CBasePlayer::StartPlayerDeathView(const Vector& in vecPosition, const Vector& in vecViewAngle)": {
		"prefix": "StartPlayerDeathView",
		"body" : [ "StartPlayerDeathView( ${1:const Vector& in vecPosition}, ${2:const Vector& in vecViewAngle} )" ],
		"description" : "Sets the player's view to that of a dead person."
	},
	"void CBasePlayer::ShowForcedRespawnMessage(int iSeconds)": {
		"prefix": "ShowForcedRespawnMessage",
		"body" : [ "ShowForcedRespawnMessage( ${1:int iSeconds} )" ],
		"description" : "Shows the forced respawn message."
	},
	"Observer@ CBasePlayer::GetObserver()": {
		"prefix": "GetObserver",
		"body" : [ "GetObserver()" ],
		"description" : "Gets the Observer instance that represents this player."
	},
	"CBaseEntity@ CBasePlayer::DropItem(const string& in szItemName)": {
		"prefix": "DropItem",
		"body" : [ "DropItem( ${1:const string& in szItemName} )" ],
		"description" : "Drops the given item, or if no name, the current weapon."
	},
	"CBasePlayerItem@ CBasePlayer::DropAmmo(const string& in szItemName)": {
		"prefix": "DropAmmo",
		"body" : [ "DropAmmo( ${1:const string& in szItemName} )" ],
		"description" : "Drops ammo used by the named item."
	},
	"bool CBasePlayer::HasPlayerItem(CBasePlayerItem@ pCheckItem)": {
		"prefix": "HasPlayerItem",
		"body" : [ "HasPlayerItem( ${1:CBasePlayerItem@ pCheckItem} )" ],
		"description" : "Returns whether this player has the given item."
	},
	"CBasePlayerItem@ CBasePlayer::HasNamedPlayerItem(const string& in szItemName)": {
		"prefix": "HasNamedPlayerItem",
		"body" : [ "HasNamedPlayerItem( ${1:const string& in szItemName} )" ],
		"description" : "Returns the given item, or null if this player has no item by that name."
	},
	"bool CBasePlayer::HasWeapons() const": {
		"prefix": "HasWeapons",
		"body" : [ "HasWeapons()" ],
		"description" : "Returns whether this player has any weapons."
	},
	"void CBasePlayer::SelectPrevItem(int iItem)": {
		"prefix": "SelectPrevItem",
		"body" : [ "SelectPrevItem( ${1:int iItem} )" ],
		"description" : "Selects the previous item relative to the given item."
	},
	"void CBasePlayer::SelectNextItem()": {
		"prefix": "SelectNextItem",
		"body" : [ "SelectNextItem()" ],
		"description" : "Selects the next item relative to the given item."
	},
	"void CBasePlayer::SelectLastItem()": {
		"prefix": "SelectLastItem",
		"body" : [ "SelectLastItem()" ],
		"description" : "Selects the last active item."
	},
	"void CBasePlayer::SelectItem(const string& in szItemName)": {
		"prefix": "SelectItem",
		"body" : [ "SelectItem( ${1:const string& in szItemName} )" ],
		"description" : "Selects the item with the given name."
	},
	"void CBasePlayer::GiveNamedItem(const string& in szName, int iFlags = 0, int iAmmoCount = 0)": {
		"prefix": "GiveNamedItem",
		"body" : [ "GiveNamedItem( ${1:const string& in szName}, ${2:int iFlags = 0}, ${3:int iAmmoCount = 0} )" ],
		"description" : "Gives this player the item with the given name. Flags are spawnflags passed to the item."
	},
	"void CBasePlayer::EnableControl(const bool bControl)": {
		"prefix": "EnableControl",
		"body" : [ "EnableControl( ${1:const bool bControl} )" ],
		"description" : "Sets whether the player has control."
	},
	"void CBasePlayer::PlayerUse()": {
		"prefix": "PlayerUse",
		"body" : [ "PlayerUse()" ],
		"description" : "Triggers the player's use behavior."
	},
	"void CBasePlayer::CheckSuitUpdate()": {
		"prefix": "CheckSuitUpdate",
		"body" : [ "CheckSuitUpdate()" ],
		"description" : "Check for suit update messages."
	},
	"void CBasePlayer::SetSuitUpdate(const string& in szName, const bool bGroup, int iNoRepeat)": {
		"prefix": "SetSuitUpdate",
		"body" : [ "SetSuitUpdate( ${1:const string& in szName}, ${2:const bool bGroup}, ${3:int iNoRepeat} )" ],
		"description" : "Set a suit update."
	},
	"int CBasePlayer::AmmoInventory(int iAmmoIndex)": {
		"prefix": "AmmoInventory",
		"body" : [ "AmmoInventory( ${1:int iAmmoIndex} )" ],
		"description" : "Returns the amount of ammo currently in inventory of the given ammo index."
	},
	"Vector CBasePlayer::GetAutoaimVector(float flDelta)": {
		"prefix": "GetAutoaimVector",
		"body" : [ "GetAutoaimVector( ${1:float flDelta} )" ],
		"description" : "Gets the autoaim vector for the given delta."
	},
	"int CBasePlayer::GetMaxAmmo(size_t uiIndex) const": {
		"prefix": "GetMaxAmmo",
		"body" : [ "GetMaxAmmo( ${1:size_t uiIndex} )" ],
		"description" : "Gets the maximum ammo setting for this player for the ammo at the given index. Returns -1 if no ammo setting is present."
	},
	"int CBasePlayer::GetMaxAmmo(const string& in szName) const": {
		"prefix": "GetMaxAmmo",
		"body" : [ "GetMaxAmmo( ${1:const string& in szName} )" ],
		"description" : "Gets the maximum ammo setting for this player for the given ammo type. Returns -1 if no ammo setting is present."
	},
	"void CBasePlayer::SetMaxAmmo(size_t uiIndex, int iMaxAmmo)": {
		"prefix": "SetMaxAmmo",
		"body" : [ "SetMaxAmmo( ${1:size_t uiIndex}, ${2:int iMaxAmmo} )" ],
		"description" : "Sets the maximum ammo setting for this player for the ammo at the given index. Value must be >= 0."
	},
	"void CBasePlayer::SetMaxAmmo(const string& in szName, int iMaxAmmo)": {
		"prefix": "SetMaxAmmo",
		"body" : [ "SetMaxAmmo( ${1:const string& in szName}, ${2:int iMaxAmmo} )" ],
		"description" : "Sets the maximum ammo setting for this player for the given ammo type. Value must be >= 0."
	},
	"void CBasePlayer::ResetMaxAmmoToDefault(size_t uiIndex)": {
		"prefix": "ResetMaxAmmoToDefault",
		"body" : [ "ResetMaxAmmoToDefault( ${1:size_t uiIndex} )" ],
		"description" : "Resets the ammo setting for this player at the given index to its default value."
	},
	"void CBasePlayer::ResetMaxAmmoToDefault(const string& in szName)": {
		"prefix": "ResetMaxAmmoToDefault",
		"body" : [ "ResetMaxAmmoToDefault( ${1:const string& in szName} )" ],
		"description" : "Resets the ammo setting for this player for the given ammo type to its default value."
	},
	"void CBasePlayer::ResetAllMaxAmmoToDefault()": {
		"prefix": "ResetAllMaxAmmoToDefault",
		"body" : [ "ResetAllMaxAmmoToDefault()" ],
		"description" : "Resets the ammo settings for this player for all ammo to their default values."
	},
	"void CBasePlayer::RemoveExcessAmmo(size_t uiIndex)": {
		"prefix": "RemoveExcessAmmo",
		"body" : [ "RemoveExcessAmmo( ${1:size_t uiIndex} )" ],
		"description" : "Clamps this player's ammo at the given inex to the range 0 - MAX_AMMO."
	},
	"void CBasePlayer::RemoveExcessAmmo(const string& in szName)": {
		"prefix": "RemoveExcessAmmo",
		"body" : [ "RemoveExcessAmmo( ${1:const string& in szName} )" ],
		"description" : "Clamps this player's ammo of the given type to the range 0 - MAX_AMMO."
	},
	"void CBasePlayer::RemoveAllExcessAmmo()": {
		"prefix": "RemoveAllExcessAmmo",
		"body" : [ "RemoveAllExcessAmmo()" ],
		"description" : "Clamps all the player's ammo to their maximum amounts."
	},
	"bool CBasePlayer::HasSuit()": {
		"prefix": "HasSuit",
		"body" : [ "HasSuit()" ],
		"description" : "Returns whether the player has an HEV suit."
	},
	"void CBasePlayer::SetHasSuit(bool fHasSuit)": {
		"prefix": "SetHasSuit",
		"body" : [ "SetHasSuit( ${1:bool fHasSuit} )" ],
		"description" : "Sets whether the player has an HEV suit."
	},
	"void CBasePlayer::SetViewMode(PlayerViewMode viewMode)": {
		"prefix": "SetViewMode",
		"body" : [ "SetViewMode( ${1:PlayerViewMode viewMode} )" ],
		"description" : "Sets the player's view mode"
	},
	"void CBasePlayer::ShowOverheadSprite(const string& in szSpriteName, const float flZOffset, const float flLifeTime)": {
		"prefix": "ShowOverheadSprite",
		"body" : [ "ShowOverheadSprite( ${1:const string& in szSpriteName}, ${2:const float flZOffset}, ${3:const float flLifeTime} )" ],
		"description" : "Creates a sprite above the player's head"
	},
	"void CBasePlayer::SetVModelPos(const Vector& in vecPos)": {
		"prefix": "SetVModelPos",
		"body" : [ "SetVModelPos( ${1:const Vector& in vecPos} )" ],
		"description" : "Set custom viewmodel position."
	},
	"void CBasePlayer::ResetVModelPos()": {
		"prefix": "ResetVModelPos",
		"body" : [ "ResetVModelPos()" ],
		"description" : "Reset viewmodel position."
	},
	"void CBasePlayer::SetMaxSpeed(int Speed)": {
		"prefix": "SetMaxSpeed",
		"body" : [ "SetMaxSpeed( ${1:int Speed} )" ],
		"description" : "Set player persistent max speed. default: sv_maxspeed"
	},
	"void CBasePlayer::SetMaxSpeedOverride(int Speed)": {
		"prefix": "SetMaxSpeedOverride",
		"body" : [ "SetMaxSpeedOverride( ${1:int Speed} )" ],
		"description" : "Override players max speed (temporarily) -1 will restore"
	},
	"int CBasePlayer::GetMaxSpeed()": {
		"prefix": "GetMaxSpeed",
		"body" : [ "GetMaxSpeed()" ],
		"description" : "Get the player persistent max speed. default: sv_maxspeed"
	},
	"int CBasePlayer::GetMaxSpeedOverride()": {
		"prefix": "GetMaxSpeedOverride",
		"body" : [ "GetMaxSpeedOverride()" ],
		"description" : "Get the player max speed override (-1 = not overriding)"
	},
	"void CBasePlayer::ResetOverriddenPlayerModel(const bool bResetToClModel, const bool bForceReset)": {
		"prefix": "ResetOverriddenPlayerModel",
		"body" : [ "ResetOverriddenPlayerModel( ${1:const bool bResetToClModel}, ${2:const bool bForceReset} )" ],
		"description" : "Reset an overriden player model."
	},
	"void CBasePlayer::SetOverriddenPlayerModel(const string& in szOverrideModel)": {
		"prefix": "SetOverriddenPlayerModel",
		"body" : [ "SetOverriddenPlayerModel( ${1:const string& in szOverrideModel} )" ],
		"description" : "Set an overriden player model."
	},
	"void CBasePlayer::SendScoreInfo(edict_t@ edPlayer = null)": {
		"prefix": "SendScoreInfo",
		"body" : [ "SendScoreInfo( ${1:edict_t@ edPlayer = null} )" ],
		"description" : "Refresh the player's score information with one or all players."
	},
	"bool CBasePlayer::SetCheat(int iBit, bool fValue, bool fRequestedBySelf = false)": {
		"prefix": "SetCheat",
		"body" : [ "SetCheat( ${1:int iBit}, ${2:bool fValue}, ${3:bool fRequestedBySelf = false} )" ],
		"description" : "Set a player's cheat bit. (Requires cheat permission. If requested by self a permission message will be shown/logged.)"
	},
	"bool CBasePlayer::GetCheat(int iBit)": {
		"prefix": "GetCheat",
		"body" : [ "GetCheat( ${1:int iBit} )" ],
		"description" : "Get a player's cheat bit."
	},
	"int CBasePlayer::GetCheats()": {
		"prefix": "GetCheats",
		"body" : [ "GetCheats()" ],
		"description" : "Get a player's cheat bits."
	},
	"entvars_t@ CBasePlayer::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBasePlayer::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBasePlayer::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBasePlayer::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBasePlayer::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBasePlayer::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBasePlayer::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBasePlayer::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBasePlayer::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBasePlayer::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBasePlayer::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBasePlayer::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBasePlayer::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBasePlayer::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBasePlayer::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBasePlayer::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBasePlayer::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBasePlayer::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CBasePlayer::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CBasePlayer::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CBasePlayer::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CBasePlayer::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CBasePlayer::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CBasePlayer::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"TOGGLE_STATE CBasePlayer::m_toggle_state": {
		"prefix": "m_toggle_state",
		"body" : [ "m_toggle_state" ],
		"description" : "Current toggle state."
	},
	"float CBasePlayer::m_flMoveDistance": {
		"prefix": "m_flMoveDistance",
		"body" : [ "m_flMoveDistance" ],
		"description" : "How far a door should slide or rotate."
	},
	"float CBasePlayer::m_flWait": {
		"prefix": "m_flWait",
		"body" : [ "m_flWait" ],
		"description" : "How long to wait before resetting."
	},
	"float CBasePlayer::m_flLip": {
		"prefix": "m_flLip",
		"body" : [ "m_flLip" ],
		"description" : "How much to stick out of a wall. Will recede further into walls if negative."
	},
	"float CBasePlayer::m_flTWidth": {
		"prefix": "m_flTWidth",
		"body" : [ "m_flTWidth" ],
		"description" : "For plats."
	},
	"float CBasePlayer::m_flTLength": {
		"prefix": "m_flTLength",
		"body" : [ "m_flTLength" ],
		"description" : "For plats."
	},
	"int CBasePlayer::m_cTriggersLeft": {
		"prefix": "m_cTriggersLeft",
		"body" : [ "m_cTriggersLeft" ],
		"description" : "Trigger_counter only: # of activations remaining."
	},
	"float CBasePlayer::m_flHeight": {
		"prefix": "m_flHeight",
		"body" : [ "m_flHeight" ],
		"description" : "Height."
	},
	"EHandle CBasePlayer::m_hActivator": {
		"prefix": "m_hActivator",
		"body" : [ "m_hActivator" ],
		"description" : "Handle to the activator."
	},
	"Vector CBasePlayer::m_vecPosition1": {
		"prefix": "m_vecPosition1",
		"body" : [ "m_vecPosition1" ],
		"description" : "Closed position."
	},
	"Vector CBasePlayer::m_vecPosition2": {
		"prefix": "m_vecPosition2",
		"body" : [ "m_vecPosition2" ],
		"description" : "Open position."
	},
	"Vector CBasePlayer::m_vecAngle1": {
		"prefix": "m_vecAngle1",
		"body" : [ "m_vecAngle1" ],
		"description" : "Closed angle."
	},
	"Vector CBasePlayer::m_vecAngle2": {
		"prefix": "m_vecAngle2",
		"body" : [ "m_vecAngle2" ],
		"description" : "Open angle."
	},
	"Vector CBasePlayer::m_vecFinalDest": {
		"prefix": "m_vecFinalDest",
		"body" : [ "m_vecFinalDest" ],
		"description" : "Final destination."
	},
	"Vector CBasePlayer::m_vecFinalAngle": {
		"prefix": "m_vecFinalAngle",
		"body" : [ "m_vecFinalAngle" ],
		"description" : "Final angle."
	},
	"int CBasePlayer::m_bitsDamageInflict": {
		"prefix": "m_bitsDamageInflict",
		"body" : [ "m_bitsDamageInflict" ],
		"description" : "DMG_ damage type that the door or trigger does."
	},
	"string_t CBasePlayer::m_sMaster": {
		"prefix": "m_sMaster",
		"body" : [ "m_sMaster" ],
		"description" : "This entity's master, if any."
	},
	"EHandle CBasePlayer::m_hEnemy": {
		"prefix": "m_hEnemy",
		"body" : [ "m_hEnemy" ],
		"description" : "the entity that the monster is fighting."
	},
	"EHandle CBasePlayer::m_hTargetEnt": {
		"prefix": "m_hTargetEnt",
		"body" : [ "m_hTargetEnt" ],
		"description" : "the entity that the monster is trying to reach."
	},
	"EHandle CBasePlayer::m_hTargetTank": {
		"prefix": "m_hTargetTank",
		"body" : [ "m_hTargetTank" ],
		"description" : "Target tank to control."
	},
	"float CBasePlayer::m_flFieldOfView": {
		"prefix": "m_flFieldOfView",
		"body" : [ "m_flFieldOfView" ],
		"description" : "width of monster's field of view (dot product)."
	},
	"float CBasePlayer::m_flWaitFinished": {
		"prefix": "m_flWaitFinished",
		"body" : [ "m_flWaitFinished" ],
		"description" : "if we're told to wait, this is the time that the wait will be over."
	},
	"float CBasePlayer::m_flMoveWaitFinished": {
		"prefix": "m_flMoveWaitFinished",
		"body" : [ "m_flMoveWaitFinished" ],
		"description" : "if we're told to wait before moving, this is the time that the wait will be over."
	},
	"Activity CBasePlayer::m_Activity": {
		"prefix": "m_Activity",
		"body" : [ "m_Activity" ],
		"description" : "what the monster is doing (animation)."
	},
	"Activity CBasePlayer::m_IdealActivity": {
		"prefix": "m_IdealActivity",
		"body" : [ "m_IdealActivity" ],
		"description" : "monster should switch to this activity."
	},
	"Activity CBasePlayer::m_GaitActivity": {
		"prefix": "m_GaitActivity",
		"body" : [ "m_GaitActivity" ],
		"description" : "gaitsequence."
	},
	"int CBasePlayer::m_LastHitGroup": {
		"prefix": "m_LastHitGroup",
		"body" : [ "m_LastHitGroup" ],
		"description" : "the last body region that took damage."
	},
	"MONSTERSTATE CBasePlayer::m_MonsterState": {
		"prefix": "m_MonsterState",
		"body" : [ "m_MonsterState" ],
		"description" : "monster's current state."
	},
	"MONSTERSTATE CBasePlayer::m_IdealMonsterState": {
		"prefix": "m_IdealMonsterState",
		"body" : [ "m_IdealMonsterState" ],
		"description" : "monster should change to this state."
	},
	"int CBasePlayer::m_iTaskStatus": {
		"prefix": "m_iTaskStatus",
		"body" : [ "m_iTaskStatus" ],
		"description" : "Task status."
	},
	"Schedule@ CBasePlayer::m_pSchedule": {
		"prefix": "m_pSchedule",
		"body" : [ "m_pSchedule" ],
		"description" : "Current schedule."
	},
	"Schedule@ CBasePlayer::m_pScheduleSaved": {
		"prefix": "m_pScheduleSaved",
		"body" : [ "m_pScheduleSaved" ],
		"description" : "For land_on_ground schedules (remember last schedule and continue)."
	},
	"int CBasePlayer::m_iScheduleIndex": {
		"prefix": "m_iScheduleIndex",
		"body" : [ "m_iScheduleIndex" ],
		"description" : "Schedule index."
	},
	"int CBasePlayer::m_movementGoal": {
		"prefix": "m_movementGoal",
		"body" : [ "m_movementGoal" ],
		"description" : "Goal that defines route."
	},
	"int CBasePlayer::m_iRouteIndex": {
		"prefix": "m_iRouteIndex",
		"body" : [ "m_iRouteIndex" ],
		"description" : "Index into m_Route[]."
	},
	"float CBasePlayer::m_moveWaitTime": {
		"prefix": "m_moveWaitTime",
		"body" : [ "m_moveWaitTime" ],
		"description" : "How long I should wait for something to move."
	},
	"float CBasePlayer::m_moveradius": {
		"prefix": "m_moveradius",
		"body" : [ "m_moveradius" ],
		"description" : "Minimum radius."
	},
	"Vector CBasePlayer::m_vecMoveGoal": {
		"prefix": "m_vecMoveGoal",
		"body" : [ "m_vecMoveGoal" ],
		"description" : "Kept around for node graph moves, so we know our ultimate goal."
	},
	"Activity CBasePlayer::m_movementActivity": {
		"prefix": "m_movementActivity",
		"body" : [ "m_movementActivity" ],
		"description" : "When moving, set this activity."
	},
	"int CBasePlayer::m_iAudibleList": {
		"prefix": "m_iAudibleList",
		"body" : [ "m_iAudibleList" ],
		"description" : "first index of a linked list of sounds that the monster can hear."
	},
	"int CBasePlayer::m_afSoundTypes": {
		"prefix": "m_afSoundTypes",
		"body" : [ "m_afSoundTypes" ],
		"description" : "Sound types that can be heard."
	},
	"Vector CBasePlayer::m_vecLastPosition": {
		"prefix": "m_vecLastPosition",
		"body" : [ "m_vecLastPosition" ],
		"description" : "monster sometimes wants to return to where it started after an operation.."
	},
	"int CBasePlayer::m_iHintNode": {
		"prefix": "m_iHintNode",
		"body" : [ "m_iHintNode" ],
		"description" : "this is the hint node that the monster is moving towards or performing active idle on.."
	},
	"int CBasePlayer::m_afMemory": {
		"prefix": "m_afMemory",
		"body" : [ "m_afMemory" ],
		"description" : "Monster memory."
	},
	"int CBasePlayer::m_bloodColor": {
		"prefix": "m_bloodColor",
		"body" : [ "m_bloodColor" ],
		"description" : "color of blood particles."
	},
	"int CBasePlayer::m_iMaxHealth": {
		"prefix": "m_iMaxHealth",
		"body" : [ "m_iMaxHealth" ],
		"description" : "keeps track of monster's maximum health value (for re-healing, etc)."
	},
	"Vector CBasePlayer::m_vecEnemyLKP": {
		"prefix": "m_vecEnemyLKP",
		"body" : [ "m_vecEnemyLKP" ],
		"description" : "last known position of enemy. (enemy's origin)."
	},
	"int CBasePlayer::m_cAmmoLoaded": {
		"prefix": "m_cAmmoLoaded",
		"body" : [ "m_cAmmoLoaded" ],
		"description" : "how much ammo is in the weapon (used to trigger reload anim sequences)."
	},
	"int CBasePlayer::m_afCapability": {
		"prefix": "m_afCapability",
		"body" : [ "m_afCapability" ],
		"description" : "tells us what a monster can/can't do."
	},
	"int CBasePlayer::m_afMoveShootCap": {
		"prefix": "m_afMoveShootCap",
		"body" : [ "m_afMoveShootCap" ],
		"description" : "tells us what a monster can/can't do, while moving."
	},
	"float CBasePlayer::m_flNextAttack": {
		"prefix": "m_flNextAttack",
		"body" : [ "m_flNextAttack" ],
		"description" : "cannot attack again until this time."
	},
	"int CBasePlayer::m_bitsDamageType": {
		"prefix": "m_bitsDamageType",
		"body" : [ "m_bitsDamageType" ],
		"description" : "what types of damage has monster (player) taken."
	},
	"float CBasePlayer::m_lastDamageAmount": {
		"prefix": "m_lastDamageAmount",
		"body" : [ "m_lastDamageAmount" ],
		"description" : "how much damage did monster (player) last take."
	},
	"float CBasePlayer::m_tbdPrev": {
		"prefix": "m_tbdPrev",
		"body" : [ "m_tbdPrev" ],
		"description" : "Time-based damage timer."
	},
	"entvars_t@ CBasePlayer::pevTimeBasedInflictor": {
		"prefix": "pevTimeBasedInflictor",
		"body" : [ "pevTimeBasedInflictor" ],
		"description" : "Time based damage inflictor."
	},
	"int CBasePlayer::m_failSchedule": {
		"prefix": "m_failSchedule",
		"body" : [ "m_failSchedule" ],
		"description" : "Schedule type to choose if current schedule fails."
	},
	"float CBasePlayer::m_flHungryTime": {
		"prefix": "m_flHungryTime",
		"body" : [ "m_flHungryTime" ],
		"description" : "Time based damage inflictor."
	},
	"float CBasePlayer::m_flDistTooFar": {
		"prefix": "m_flDistTooFar",
		"body" : [ "m_flDistTooFar" ],
		"description" : "if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy."
	},
	"float CBasePlayer::m_flDistLook": {
		"prefix": "m_flDistLook",
		"body" : [ "m_flDistLook" ],
		"description" : "distance monster sees (Default 2048)."
	},
	"int CBasePlayer::m_iTriggerCondition": {
		"prefix": "m_iTriggerCondition",
		"body" : [ "m_iTriggerCondition" ],
		"description" : "for scripted AI, this is the condition that will cause the activation of the monster's TriggerTarget."
	},
	"string_t CBasePlayer::m_iszTriggerTarget": {
		"prefix": "m_iszTriggerTarget",
		"body" : [ "m_iszTriggerTarget" ],
		"description" : "Name of target that should be fired."
	},
	"Vector CBasePlayer::m_HackedGunPos": {
		"prefix": "m_HackedGunPos",
		"body" : [ "m_HackedGunPos" ],
		"description" : "HACK until we can query end of gun."
	},
	"SCRIPTSTATE CBasePlayer::m_scriptState": {
		"prefix": "m_scriptState",
		"body" : [ "m_scriptState" ],
		"description" : "internal cinematic state."
	},
	"EHandle CBasePlayer::m_hCine": {
		"prefix": "m_hCine",
		"body" : [ "m_hCine" ],
		"description" : "Cinematic entity."
	},
	"EHandle CBasePlayer::m_hCineBlocker": {
		"prefix": "m_hCineBlocker",
		"body" : [ "m_hCineBlocker" ],
		"description" : "Entity that is blocking cinematic execution."
	},
	"float CBasePlayer::m_useTime": {
		"prefix": "m_useTime",
		"body" : [ "m_useTime" ],
		"description" : "Don't allow +USE until this time."
	},
	"string_t CBasePlayer::m_FormattedName": {
		"prefix": "m_FormattedName",
		"body" : [ "m_FormattedName" ],
		"description" : "The formatted name. For better name outputs. E.g. \"Alien Slave\" rather than \"alien_slave\"."
	},
	"int8 CBasePlayer::m_chTextureType": {
		"prefix": "m_chTextureType",
		"body" : [ "m_chTextureType" ],
		"description" : "Current texture type. See TextureType enum."
	},
	"bool CBasePlayer::m_fCanFearCreatures": {
		"prefix": "m_fCanFearCreatures",
		"body" : [ "m_fCanFearCreatures" ],
		"description" : "Whether this monster can fear creatures."
	},
	"float CBasePlayer::m_flAutomaticAttackTime": {
		"prefix": "m_flAutomaticAttackTime",
		"body" : [ "m_flAutomaticAttackTime" ],
		"description" : "How long an npc will attempt to fire full auto."
	},
	"float CBasePlayer::m_flFallVelocity": {
		"prefix": "m_flFallVelocity",
		"body" : [ "m_flFallVelocity" ],
		"description" : "Current fall speed."
	},
	"EHandle CBasePlayer::m_hGuardEnt": {
		"prefix": "m_hGuardEnt",
		"body" : [ "m_hGuardEnt" ],
		"description" : "Monster will guard this entity and turn down follow requests."
	},
	"string_t CBasePlayer::m_iszGuardEntName": {
		"prefix": "m_iszGuardEntName",
		"body" : [ "m_iszGuardEntName" ],
		"description" : "Guard entity name."
	},
	"Vector CBasePlayer::m_vecEffectGlowColor": {
		"prefix": "m_vecEffectGlowColor",
		"body" : [ "m_vecEffectGlowColor" ],
		"description" : "Glow shell."
	},
	"int CBasePlayer::m_iEffectBlockWeapons": {
		"prefix": "m_iEffectBlockWeapons",
		"body" : [ "m_iEffectBlockWeapons" ],
		"description" : "Monster can't use weapons."
	},
	"int CBasePlayer::m_iEffectInvulnerable": {
		"prefix": "m_iEffectInvulnerable",
		"body" : [ "m_iEffectInvulnerable" ],
		"description" : "is invulnerable (god mode)"
	},
	"int CBasePlayer::m_iEffectInvisible": {
		"prefix": "m_iEffectInvisible",
		"body" : [ "m_iEffectInvisible" ],
		"description" : "is invisible (render + non-targetable)"
	},
	"int CBasePlayer::m_iEffectNonSolid": {
		"prefix": "m_iEffectNonSolid",
		"body" : [ "m_iEffectNonSolid" ],
		"description" : "is non-solid"
	},
	"float CBasePlayer::m_flEffectRespiration": {
		"prefix": "m_flEffectRespiration",
		"body" : [ "m_flEffectRespiration" ],
		"description" : "Extra/less breathing time underwater in seconds"
	},
	"float CBasePlayer::m_flEffectGravity": {
		"prefix": "m_flEffectGravity",
		"body" : [ "m_flEffectGravity" ],
		"description" : "Gravity modifier (%)"
	},
	"float CBasePlayer::m_flEffectFriction": {
		"prefix": "m_flEffectFriction",
		"body" : [ "m_flEffectFriction" ],
		"description" : "Movement friction modifier (%)"
	},
	"float CBasePlayer::m_flEffectSpeed": {
		"prefix": "m_flEffectSpeed",
		"body" : [ "m_flEffectSpeed" ],
		"description" : "Movement speed modifier (%)"
	},
	"float CBasePlayer::m_flEffectDamage": {
		"prefix": "m_flEffectDamage",
		"body" : [ "m_flEffectDamage" ],
		"description" : "Damage modifier (%)"
	},
	"const int CBasePlayer::random_seed": {
		"prefix": "random_seed",
		"body" : [ "random_seed" ],
		"description" : "The player's random seed."
	},
	"float CBasePlayer::m_flNextClientCommandTime": {
		"prefix": "m_flNextClientCommandTime",
		"body" : [ "m_flNextClientCommandTime" ],
		"description" : "The next time this player can execute a vocal client command"
	},
	"float CBasePlayer::m_flTimeOfLastDeath": {
		"prefix": "m_flTimeOfLastDeath",
		"body" : [ "m_flTimeOfLastDeath" ],
		"description" : "Time of last death."
	},
	"float CBasePlayer::m_flRespawnDelayTime": {
		"prefix": "m_flRespawnDelayTime",
		"body" : [ "m_flRespawnDelayTime" ],
		"description" : "Gets added to the standard respawn delay time when killed, reset in spawn to 0.0."
	},
	"EHandle CBasePlayer::m_hSpawnPoint": {
		"prefix": "m_hSpawnPoint",
		"body" : [ "m_hSpawnPoint" ],
		"description" : "Pointer for a spawn point to use."
	},
	"float CBasePlayer::m_flLastMove": {
		"prefix": "m_flLastMove",
		"body" : [ "m_flLastMove" ],
		"description" : "When did this player move or tried to move (with the IN_ keys) ?"
	},
	"int CBasePlayer::m_iWeaponVolume": {
		"prefix": "m_iWeaponVolume",
		"body" : [ "m_iWeaponVolume" ],
		"description" : "How loud the player's weapon is right now."
	},
	"int CBasePlayer::m_iExtraSoundTypes": {
		"prefix": "m_iExtraSoundTypes",
		"body" : [ "m_iExtraSoundTypes" ],
		"description" : "Additional classification for this weapon's sound."
	},
	"int CBasePlayer::m_iWeaponFlash": {
		"prefix": "m_iWeaponFlash",
		"body" : [ "m_iWeaponFlash" ],
		"description" : "Brightness of the weapon flash."
	},
	"float CBasePlayer::m_flStopExtraSoundTime": {
		"prefix": "m_flStopExtraSoundTime",
		"body" : [ "m_flStopExtraSoundTime" ],
		"description" : "When to stop the m_iExtraSoundTypes sounds."
	},
	"int CBasePlayer::m_iFlashBattery": {
		"prefix": "m_iFlashBattery",
		"body" : [ "m_iFlashBattery" ],
		"description" : "Player flashlight amount. 0 <= amount <= 100."
	},
	"float CBasePlayer::m_flPlayerFallVelocity": {
		"prefix": "m_flPlayerFallVelocity",
		"body" : [ "m_flPlayerFallVelocity" ],
		"description" : "Player fall velocity."
	},
	"float CBasePlayer::m_flSwimTime": {
		"prefix": "m_flSwimTime",
		"body" : [ "m_flSwimTime" ],
		"description" : "How long this player has been underwater."
	},
	"int CBasePlayer::m_lastPlayerDamageAmount": {
		"prefix": "m_lastPlayerDamageAmount",
		"body" : [ "m_lastPlayerDamageAmount" ],
		"description" : "Last damage taken."
	},
	"int CBasePlayer::m_iDrownDmg": {
		"prefix": "m_iDrownDmg",
		"body" : [ "m_iDrownDmg" ],
		"description" : "Track drowning damage taken."
	},
	"int CBasePlayer::m_iDrownRestored": {
		"prefix": "m_iDrownRestored",
		"body" : [ "m_iDrownRestored" ],
		"description" : "Track drowning damage restored."
	},
	"int CBasePlayer::m_iTrain": {
		"prefix": "m_iTrain",
		"body" : [ "m_iTrain" ],
		"description" : "Train control position"
	},
	"EHandle CBasePlayer::m_hTank": {
		"prefix": "m_hTank",
		"body" : [ "m_hTank" ],
		"description" : "the tank which the player is currently controlling, NULL if no tank"
	},
	"float CBasePlayer::m_fDeadTime": {
		"prefix": "m_fDeadTime",
		"body" : [ "m_fDeadTime" ],
		"description" : "the time at which the player died"
	},
	"bool CBasePlayer::m_fLongJump": {
		"prefix": "m_fLongJump",
		"body" : [ "m_fLongJump" ],
		"description" : "Does this player have the longjump module?"
	},
	"int CBasePlayer::m_iHideHUD": {
		"prefix": "m_iHideHUD",
		"body" : [ "m_iHideHUD" ],
		"description" : "The players hud weapon info is to be hidden."
	},
	"int CBasePlayer::m_iFOV": {
		"prefix": "m_iFOV",
		"body" : [ "m_iFOV" ],
		"description" : "Field of view."
	},
	"EHandle CBasePlayer::m_hActiveItem": {
		"prefix": "m_hActiveItem",
		"body" : [ "m_hActiveItem" ],
		"description" : "The active item."
	},
	"int CBasePlayer::m_iDeaths": {
		"prefix": "m_iDeaths",
		"body" : [ "m_iDeaths" ],
		"description" : "get player death count."
	},
	"float CBasePlayer::m_flNextDecalTime": {
		"prefix": "m_flNextDecalTime",
		"body" : [ "m_flNextDecalTime" ],
		"description" : "Next time this player can spray a decal."
	},
	"int CBasePlayer::m_iPlayerClass": {
		"prefix": "m_iPlayerClass",
		"body" : [ "m_iPlayerClass" ],
		"description" : "The player's class type."
	},
	"CBaseEntity@ CBasePlayerAmmo::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBasePlayerAmmo::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBasePlayerAmmo::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBasePlayerAmmo::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBasePlayerAmmo::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBasePlayerAmmo::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBasePlayerAmmo::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBasePlayerAmmo::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBasePlayerAmmo::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBasePlayerAmmo::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBasePlayerAmmo::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBasePlayerAmmo::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBasePlayerAmmo::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBasePlayerAmmo::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBasePlayerAmmo::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBasePlayerAmmo::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBasePlayerAmmo::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBasePlayerAmmo::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBasePlayerAmmo::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBasePlayerAmmo::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBasePlayerAmmo::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBasePlayerAmmo::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBasePlayerAmmo::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBasePlayerAmmo::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBasePlayerAmmo::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBasePlayerAmmo::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBasePlayerAmmo::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBasePlayerAmmo::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBasePlayerAmmo::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBasePlayerAmmo::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBasePlayerAmmo::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBasePlayerAmmo::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBasePlayerAmmo::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBasePlayerAmmo::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBasePlayerAmmo::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBasePlayerAmmo::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBasePlayerAmmo::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBasePlayerAmmo::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBasePlayerAmmo::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBasePlayerAmmo::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBasePlayerAmmo::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBasePlayerAmmo::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBasePlayerAmmo::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBasePlayerAmmo::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBasePlayerAmmo::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBasePlayerAmmo::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CBasePlayerAmmo::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CBasePlayerAmmo::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBasePlayerAmmo::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBasePlayerAmmo::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBasePlayerAmmo::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBasePlayerAmmo::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBasePlayerAmmo::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBasePlayerAmmo::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBasePlayerAmmo::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBasePlayerAmmo::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBasePlayerAmmo::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBasePlayerAmmo::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBasePlayerAmmo::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBasePlayerAmmo::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBasePlayerAmmo::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBasePlayerAmmo::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBasePlayerAmmo::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBasePlayerAmmo::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBasePlayerAmmo::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBasePlayerAmmo::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBasePlayerAmmo::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBasePlayerAmmo::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBasePlayerAmmo::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBasePlayerAmmo::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBasePlayerAmmo::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBasePlayerAmmo::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBasePlayerAmmo::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBasePlayerAmmo::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBasePlayerAmmo::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBasePlayerAmmo::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBasePlayerAmmo::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBasePlayerAmmo::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBasePlayerAmmo::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBasePlayerAmmo::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBasePlayerAmmo::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBasePlayerAmmo::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBasePlayerAmmo::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBasePlayerAmmo::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBasePlayerAmmo::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBasePlayerAmmo::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBasePlayerAmmo::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBasePlayerAmmo::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBasePlayerAmmo::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBasePlayerAmmo::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBasePlayerAmmo::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBasePlayerAmmo::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBasePlayerAmmo::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBasePlayerAmmo::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBasePlayerAmmo::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBasePlayerAmmo::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBasePlayerAmmo::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBasePlayerAmmo::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBasePlayerAmmo::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBasePlayerAmmo::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBasePlayerAmmo::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBasePlayerAmmo::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBasePlayerAmmo::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBasePlayerAmmo::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBasePlayerAmmo::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBasePlayerAmmo::DefaultTouch(CBaseEntity@ pOther)": {
		"prefix": "DefaultTouch",
		"body" : [ "DefaultTouch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Default touch"
	},
	"bool CBasePlayerAmmo::AddAmmo(CBaseEntity@ pOther)": {
		"prefix": "AddAmmo",
		"body" : [ "AddAmmo( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Adds ammo to the given entity."
	},
	"void CBasePlayerAmmo::Materialize()": {
		"prefix": "Materialize",
		"body" : [ "Materialize()" ],
		"description" : "Makes this entity visible and tangible."
	},
	"entvars_t@ CBasePlayerAmmo::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBasePlayerAmmo::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBasePlayerAmmo::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBasePlayerAmmo::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBasePlayerAmmo::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBasePlayerAmmo::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBasePlayerAmmo::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBasePlayerAmmo::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBasePlayerAmmo::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBasePlayerAmmo::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBasePlayerAmmo::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBasePlayerAmmo::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBasePlayerAmmo::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBasePlayerAmmo::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBasePlayerAmmo::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBasePlayerAmmo::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"CBaseAnimating@ CBasePlayerItem::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CBasePlayerItem::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CBasePlayerItem::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBasePlayerItem::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBasePlayerItem::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBasePlayerItem::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBasePlayerItem::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBasePlayerItem::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBasePlayerItem::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBasePlayerItem::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBasePlayerItem::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBasePlayerItem::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBasePlayerItem::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBasePlayerItem::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBasePlayerItem::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBasePlayerItem::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBasePlayerItem::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBasePlayerItem::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBasePlayerItem::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBasePlayerItem::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBasePlayerItem::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBasePlayerItem::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBasePlayerItem::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBasePlayerItem::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBasePlayerItem::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBasePlayerItem::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBasePlayerItem::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBasePlayerItem::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBasePlayerItem::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBasePlayerItem::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBasePlayerItem::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBasePlayerItem::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBasePlayerItem::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBasePlayerItem::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBasePlayerItem::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBasePlayerItem::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBasePlayerItem::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBasePlayerItem::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBasePlayerItem::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBasePlayerItem::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBasePlayerItem::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBasePlayerItem::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBasePlayerItem::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBasePlayerItem::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBasePlayerItem::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBasePlayerItem::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBasePlayerItem::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBasePlayerItem::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBasePlayerItem::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBasePlayerItem::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBasePlayerItem::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBasePlayerItem::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBasePlayerItem::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBasePlayerItem::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBasePlayerItem::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBasePlayerItem::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBasePlayerItem::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBasePlayerItem::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBasePlayerItem::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBasePlayerItem::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBasePlayerItem::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBasePlayerItem::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBasePlayerItem::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBasePlayerItem::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBasePlayerItem::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBasePlayerItem::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBasePlayerItem::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBasePlayerItem::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBasePlayerItem::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBasePlayerItem::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBasePlayerItem::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBasePlayerItem::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBasePlayerItem::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBasePlayerItem::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBasePlayerItem::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBasePlayerItem::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBasePlayerItem::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBasePlayerItem::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBasePlayerItem::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBasePlayerItem::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBasePlayerItem::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBasePlayerItem::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBasePlayerItem::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBasePlayerItem::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBasePlayerItem::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBasePlayerItem::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBasePlayerItem::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBasePlayerItem::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBasePlayerItem::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBasePlayerItem::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBasePlayerItem::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBasePlayerItem::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBasePlayerItem::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBasePlayerItem::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBasePlayerItem::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBasePlayerItem::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBasePlayerItem::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBasePlayerItem::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBasePlayerItem::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBasePlayerItem::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBasePlayerItem::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBasePlayerItem::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBasePlayerItem::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBasePlayerItem::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBasePlayerItem::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBasePlayerItem::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBasePlayerItem::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBasePlayerItem::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CBasePlayerItem::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CBasePlayerItem::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CBasePlayerItem::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CBasePlayerItem::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CBasePlayerItem::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CBasePlayerItem::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CBasePlayerItem::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CBasePlayerItem::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CBasePlayerItem::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CBasePlayerItem::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CBasePlayerItem::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CBasePlayerItem::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CBasePlayerItem::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CBasePlayerItem::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CBasePlayerItem::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CBasePlayerItem::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CBasePlayerItem::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CBasePlayerItem::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CBasePlayerItem::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CBasePlayerItem::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CBasePlayerItem::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CBasePlayerItem::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"bool CBasePlayerItem::AddToPlayer(CBasePlayer@ pPlayer)": {
		"prefix": "AddToPlayer",
		"body" : [ "AddToPlayer( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Returns true if this item wants itself added to the player's inventory."
	},
	"bool CBasePlayerItem::AddDuplicate(CBasePlayerItem@ pItem)": {
		"prefix": "AddDuplicate",
		"body" : [ "AddDuplicate( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "returns true if this item wants the duplicate removed from the world."
	},
	"void CBasePlayerItem::DestroyItem()": {
		"prefix": "DestroyItem",
		"body" : [ "DestroyItem()" ],
		"description" : "Think function. Destroys this item."
	},
	"void CBasePlayerItem::Collect(CBaseEntity@ pOther)": {
		"prefix": "Collect",
		"body" : [ "Collect( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Attempts to let pOther collect this item."
	},
	"void CBasePlayerItem::DefaultTouch(CBaseEntity@ pOther)": {
		"prefix": "DefaultTouch",
		"body" : [ "DefaultTouch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Touch function. Default touch."
	},
	"void CBasePlayerItem::ItemUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)": {
		"prefix": "ItemUse",
		"body" : [ "ItemUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue} )" ],
		"description" : "Default weapon use function."
	},
	"void CBasePlayerItem::FallThink()": {
		"prefix": "FallThink",
		"body" : [ "FallThink()" ],
		"description" : "Think function. When an item is first spawned, this think is run to determine when the object has hit the ground."
	},
	"void CBasePlayerItem::Materialize()": {
		"prefix": "Materialize",
		"body" : [ "Materialize()" ],
		"description" : "Make a weapon visible and tangible."
	},
	"void CBasePlayerItem::AttemptToMaterialize()": {
		"prefix": "AttemptToMaterialize",
		"body" : [ "AttemptToMaterialize()" ],
		"description" : "Think function. The weapon desires to become visible and tangible, if the game rules allow for it."
	},
	"CBasePlayerItem@ CBasePlayerItem::RespawnItem()": {
		"prefix": "RespawnItem",
		"body" : [ "RespawnItem()" ],
		"description" : "Copy a weapon."
	},
	"void CBasePlayerItem::FallInit()": {
		"prefix": "FallInit",
		"body" : [ "FallInit()" ],
		"description" : "Fall init."
	},
	"void CBasePlayerItem::CheckRespawn()": {
		"prefix": "CheckRespawn",
		"body" : [ "CheckRespawn()" ],
		"description" : "Check respawn."
	},
	"void CBasePlayerItem::GetItemInfo(ItemInfo& out info)": {
		"prefix": "GetItemInfo",
		"body" : [ "GetItemInfo( ${1:ItemInfo& out info} )" ],
		"description" : "Gets item info."
	},
	"bool CBasePlayerItem::CanDeploy()": {
		"prefix": "CanDeploy",
		"body" : [ "CanDeploy()" ],
		"description" : "Returns whether this item can deploy."
	},
	"bool CBasePlayerItem::Deploy()": {
		"prefix": "Deploy",
		"body" : [ "Deploy()" ],
		"description" : "Returns if deploy was successful."
	},
	"bool CBasePlayerItem::CanHolster()": {
		"prefix": "CanHolster",
		"body" : [ "CanHolster()" ],
		"description" : "Can this weapon be put away right now?"
	},
	"void CBasePlayerItem::Holster(int iSkipLocal = 0)": {
		"prefix": "Holster",
		"body" : [ "Holster( ${1:int iSkipLocal = 0} )" ],
		"description" : "Holsters this weapon."
	},
	"void CBasePlayerItem::UpdateItemInfo()": {
		"prefix": "UpdateItemInfo",
		"body" : [ "UpdateItemInfo()" ],
		"description" : "Updates item info."
	},
	"void CBasePlayerItem::LoadSprites(CBasePlayer@ pPlayer, const string& in szName)": {
		"prefix": "LoadSprites",
		"body" : [ "LoadSprites( ${1:CBasePlayer@ pPlayer}, ${2:const string& in szName} )" ],
		"description" : "Load item sprites."
	},
	"void CBasePlayerItem::Kill()": {
		"prefix": "Kill",
		"body" : [ "Kill()" ],
		"description" : "Kills this item."
	},
	"void CBasePlayerItem::AttachToPlayer(CBasePlayer@ pPlayer)": {
		"prefix": "AttachToPlayer",
		"body" : [ "AttachToPlayer( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Attach this item to the given player."
	},
	"int CBasePlayerItem::PrimaryAmmoIndex()": {
		"prefix": "PrimaryAmmoIndex",
		"body" : [ "PrimaryAmmoIndex()" ],
		"description" : "Gets the primary ammo index, or -1 if this item doesn't use primary ammo."
	},
	"int CBasePlayerItem::SecondaryAmmoIndex()": {
		"prefix": "SecondaryAmmoIndex",
		"body" : [ "SecondaryAmmoIndex()" ],
		"description" : "Gets the secondary ammo index, or -1 if this item doesn't use secondary ammo."
	},
	"bool CBasePlayerItem::UpdateClientData(CBasePlayer@ pPlayer)": {
		"prefix": "UpdateClientData",
		"body" : [ "UpdateClientData( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Updates client data."
	},
	"CBasePlayerWeapon@ CBasePlayerItem::GetWeaponPtr()": {
		"prefix": "GetWeaponPtr",
		"body" : [ "GetWeaponPtr()" ],
		"description" : "Gets this item as a weapon. Returns null if this is not a weapon."
	},
	"int CBasePlayerItem::iItemSlot()": {
		"prefix": "iItemSlot",
		"body" : [ "iItemSlot()" ],
		"description" : "Gets the slot this item is in. 0 to MAX_ITEMS_SLOTS."
	},
	"int CBasePlayerItem::iItemPosition()": {
		"prefix": "iItemPosition",
		"body" : [ "iItemPosition()" ],
		"description" : "Gets the item position."
	},
	"string CBasePlayerItem::pszAmmo1()": {
		"prefix": "pszAmmo1",
		"body" : [ "pszAmmo1()" ],
		"description" : "Gets the name of the primary ammo."
	},
	"int CBasePlayerItem::iMaxAmmo1()": {
		"prefix": "iMaxAmmo1",
		"body" : [ "iMaxAmmo1()" ],
		"description" : "Gets the primary ammo maximum."
	},
	"string CBasePlayerItem::pszAmmo2()": {
		"prefix": "pszAmmo2",
		"body" : [ "pszAmmo2()" ],
		"description" : "Gets the name of the secondary ammo."
	},
	"int CBasePlayerItem::iMaxAmmo2()": {
		"prefix": "iMaxAmmo2",
		"body" : [ "iMaxAmmo2()" ],
		"description" : "Gets the secondary ammo maximum."
	},
	"string CBasePlayerItem::pszName()": {
		"prefix": "pszName",
		"body" : [ "pszName()" ],
		"description" : "Gets the name of this item."
	},
	"int CBasePlayerItem::iMaxClip()": {
		"prefix": "iMaxClip",
		"body" : [ "iMaxClip()" ],
		"description" : "Gets the max clip amount."
	},
	"int CBasePlayerItem::iWeight()": {
		"prefix": "iWeight",
		"body" : [ "iWeight()" ],
		"description" : "Gets the item weight."
	},
	"int CBasePlayerItem::iFlags()": {
		"prefix": "iFlags",
		"body" : [ "iFlags()" ],
		"description" : "Gets the item flags."
	},
	"float CBasePlayerItem::GetRespawnTime() const": {
		"prefix": "GetRespawnTime",
		"body" : [ "GetRespawnTime()" ],
		"description" : "Gets this item's respawn time (time from pickup to respawn)."
	},
	"CBasePlayerItem@ CBasePlayerItem::DropItem()": {
		"prefix": "DropItem",
		"body" : [ "DropItem()" ],
		"description" : "CBaseEntity to drop. By default, this entity."
	},
	"bool CBasePlayerItem::CanHaveDuplicates()": {
		"prefix": "CanHaveDuplicates",
		"body" : [ "CanHaveDuplicates()" ],
		"description" : "Can this weapon have duplicates added?"
	},
	"CBasePlayerWeapon@ CBasePlayerItem::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"entvars_t@ CBasePlayerItem::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBasePlayerItem::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBasePlayerItem::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBasePlayerItem::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBasePlayerItem::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBasePlayerItem::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBasePlayerItem::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBasePlayerItem::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBasePlayerItem::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBasePlayerItem::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBasePlayerItem::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBasePlayerItem::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBasePlayerItem::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBasePlayerItem::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBasePlayerItem::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBasePlayerItem::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBasePlayerItem::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBasePlayerItem::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CBasePlayerItem::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CBasePlayerItem::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CBasePlayerItem::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CBasePlayerItem::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CBasePlayerItem::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CBasePlayerItem::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"EHandle CBasePlayerItem::m_hPlayer": {
		"prefix": "m_hPlayer",
		"body" : [ "m_hPlayer" ],
		"description" : "The owning player. null if no owner."
	},
	"EHandle CBasePlayerItem::m_hNextItem": {
		"prefix": "m_hNextItem",
		"body" : [ "m_hNextItem" ],
		"description" : "Gets the next item. null if no next item."
	},
	"const int CBasePlayerItem::m_iId": {
		"prefix": "m_iId",
		"body" : [ "m_iId" ],
		"description" : "The item id."
	},
	"float CBasePlayerItem::m_flLastBounce": {
		"prefix": "m_flLastBounce",
		"body" : [ "m_flLastBounce" ],
		"description" : "The last bounce time."
	},
	"bool CBasePlayerItem::m_bExclusiveHold": {
		"prefix": "m_bExclusiveHold",
		"body" : [ "m_bExclusiveHold" ],
		"description" : "If set, as long as a player has this item, the player must keep this weapon selected.No more than one item with this set can be carried at one time."
	},
	"CBasePlayerItem@ CBasePlayerWeapon::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseAnimating@ CBasePlayerWeapon::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CBasePlayerWeapon::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CBasePlayerWeapon::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBasePlayerWeapon::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBasePlayerWeapon::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBasePlayerWeapon::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBasePlayerWeapon::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBasePlayerWeapon::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBasePlayerWeapon::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBasePlayerWeapon::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBasePlayerWeapon::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBasePlayerWeapon::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBasePlayerWeapon::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBasePlayerWeapon::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBasePlayerWeapon::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBasePlayerWeapon::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBasePlayerWeapon::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBasePlayerWeapon::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBasePlayerWeapon::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBasePlayerWeapon::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBasePlayerWeapon::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBasePlayerWeapon::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBasePlayerWeapon::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBasePlayerWeapon::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBasePlayerWeapon::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBasePlayerWeapon::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBasePlayerWeapon::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBasePlayerWeapon::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBasePlayerWeapon::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBasePlayerWeapon::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBasePlayerWeapon::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBasePlayerWeapon::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBasePlayerWeapon::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBasePlayerWeapon::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBasePlayerWeapon::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBasePlayerWeapon::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBasePlayerWeapon::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBasePlayerWeapon::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBasePlayerWeapon::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBasePlayerWeapon::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBasePlayerWeapon::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBasePlayerWeapon::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBasePlayerWeapon::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBasePlayerWeapon::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBasePlayerWeapon::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBasePlayerWeapon::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBasePlayerWeapon::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBasePlayerWeapon::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBasePlayerWeapon::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBasePlayerWeapon::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBasePlayerWeapon::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBasePlayerWeapon::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBasePlayerWeapon::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBasePlayerWeapon::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBasePlayerWeapon::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBasePlayerWeapon::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBasePlayerWeapon::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBasePlayerWeapon::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBasePlayerWeapon::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBasePlayerWeapon::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBasePlayerWeapon::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBasePlayerWeapon::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBasePlayerWeapon::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBasePlayerWeapon::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBasePlayerWeapon::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBasePlayerWeapon::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBasePlayerWeapon::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBasePlayerWeapon::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBasePlayerWeapon::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBasePlayerWeapon::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBasePlayerWeapon::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBasePlayerWeapon::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBasePlayerWeapon::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBasePlayerWeapon::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBasePlayerWeapon::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBasePlayerWeapon::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBasePlayerWeapon::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBasePlayerWeapon::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBasePlayerWeapon::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBasePlayerWeapon::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBasePlayerWeapon::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBasePlayerWeapon::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBasePlayerWeapon::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBasePlayerWeapon::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBasePlayerWeapon::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBasePlayerWeapon::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBasePlayerWeapon::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBasePlayerWeapon::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBasePlayerWeapon::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBasePlayerWeapon::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBasePlayerWeapon::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBasePlayerWeapon::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBasePlayerWeapon::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBasePlayerWeapon::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBasePlayerWeapon::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBasePlayerWeapon::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBasePlayerWeapon::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBasePlayerWeapon::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBasePlayerWeapon::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBasePlayerWeapon::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBasePlayerWeapon::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBasePlayerWeapon::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBasePlayerWeapon::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBasePlayerWeapon::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBasePlayerWeapon::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBasePlayerWeapon::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBasePlayerWeapon::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBasePlayerWeapon::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CBasePlayerWeapon::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CBasePlayerWeapon::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CBasePlayerWeapon::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CBasePlayerWeapon::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CBasePlayerWeapon::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CBasePlayerWeapon::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CBasePlayerWeapon::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CBasePlayerWeapon::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CBasePlayerWeapon::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CBasePlayerWeapon::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CBasePlayerWeapon::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CBasePlayerWeapon::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CBasePlayerWeapon::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CBasePlayerWeapon::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CBasePlayerWeapon::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CBasePlayerWeapon::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CBasePlayerWeapon::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CBasePlayerWeapon::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CBasePlayerWeapon::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CBasePlayerWeapon::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CBasePlayerWeapon::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CBasePlayerWeapon::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"bool CBasePlayerWeapon::AddToPlayer(CBasePlayer@ pPlayer)": {
		"prefix": "AddToPlayer",
		"body" : [ "AddToPlayer( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Returns true if this item wants itself added to the player's inventory."
	},
	"bool CBasePlayerWeapon::AddDuplicate(CBasePlayerItem@ pItem)": {
		"prefix": "AddDuplicate",
		"body" : [ "AddDuplicate( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "returns true if this item wants the duplicate removed from the world."
	},
	"void CBasePlayerWeapon::DestroyItem()": {
		"prefix": "DestroyItem",
		"body" : [ "DestroyItem()" ],
		"description" : "Think function. Destroys this item."
	},
	"void CBasePlayerWeapon::Collect(CBaseEntity@ pOther)": {
		"prefix": "Collect",
		"body" : [ "Collect( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Attempts to let pOther collect this item."
	},
	"void CBasePlayerWeapon::DefaultTouch(CBaseEntity@ pOther)": {
		"prefix": "DefaultTouch",
		"body" : [ "DefaultTouch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Touch function. Default touch."
	},
	"void CBasePlayerWeapon::ItemUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)": {
		"prefix": "ItemUse",
		"body" : [ "ItemUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue} )" ],
		"description" : "Default weapon use function."
	},
	"void CBasePlayerWeapon::FallThink()": {
		"prefix": "FallThink",
		"body" : [ "FallThink()" ],
		"description" : "Think function. When an item is first spawned, this think is run to determine when the object has hit the ground."
	},
	"void CBasePlayerWeapon::Materialize()": {
		"prefix": "Materialize",
		"body" : [ "Materialize()" ],
		"description" : "Make a weapon visible and tangible."
	},
	"void CBasePlayerWeapon::AttemptToMaterialize()": {
		"prefix": "AttemptToMaterialize",
		"body" : [ "AttemptToMaterialize()" ],
		"description" : "Think function. The weapon desires to become visible and tangible, if the game rules allow for it."
	},
	"CBasePlayerItem@ CBasePlayerWeapon::RespawnItem()": {
		"prefix": "RespawnItem",
		"body" : [ "RespawnItem()" ],
		"description" : "Copy a weapon."
	},
	"void CBasePlayerWeapon::FallInit()": {
		"prefix": "FallInit",
		"body" : [ "FallInit()" ],
		"description" : "Fall init."
	},
	"void CBasePlayerWeapon::CheckRespawn()": {
		"prefix": "CheckRespawn",
		"body" : [ "CheckRespawn()" ],
		"description" : "Check respawn."
	},
	"void CBasePlayerWeapon::GetItemInfo(ItemInfo& out info)": {
		"prefix": "GetItemInfo",
		"body" : [ "GetItemInfo( ${1:ItemInfo& out info} )" ],
		"description" : "Gets item info."
	},
	"bool CBasePlayerWeapon::CanDeploy()": {
		"prefix": "CanDeploy",
		"body" : [ "CanDeploy()" ],
		"description" : "Returns whether this item can deploy."
	},
	"bool CBasePlayerWeapon::Deploy()": {
		"prefix": "Deploy",
		"body" : [ "Deploy()" ],
		"description" : "Returns if deploy was successful."
	},
	"bool CBasePlayerWeapon::CanHolster()": {
		"prefix": "CanHolster",
		"body" : [ "CanHolster()" ],
		"description" : "Can this weapon be put away right now?"
	},
	"void CBasePlayerWeapon::Holster(int iSkipLocal = 0)": {
		"prefix": "Holster",
		"body" : [ "Holster( ${1:int iSkipLocal = 0} )" ],
		"description" : "Holsters this weapon."
	},
	"void CBasePlayerWeapon::UpdateItemInfo()": {
		"prefix": "UpdateItemInfo",
		"body" : [ "UpdateItemInfo()" ],
		"description" : "Updates item info."
	},
	"void CBasePlayerWeapon::LoadSprites(CBasePlayer@ pPlayer, const string& in szName)": {
		"prefix": "LoadSprites",
		"body" : [ "LoadSprites( ${1:CBasePlayer@ pPlayer}, ${2:const string& in szName} )" ],
		"description" : "Load item sprites."
	},
	"void CBasePlayerWeapon::Kill()": {
		"prefix": "Kill",
		"body" : [ "Kill()" ],
		"description" : "Kills this item."
	},
	"void CBasePlayerWeapon::AttachToPlayer(CBasePlayer@ pPlayer)": {
		"prefix": "AttachToPlayer",
		"body" : [ "AttachToPlayer( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Attach this item to the given player."
	},
	"int CBasePlayerWeapon::PrimaryAmmoIndex()": {
		"prefix": "PrimaryAmmoIndex",
		"body" : [ "PrimaryAmmoIndex()" ],
		"description" : "Gets the primary ammo index, or -1 if this item doesn't use primary ammo."
	},
	"int CBasePlayerWeapon::SecondaryAmmoIndex()": {
		"prefix": "SecondaryAmmoIndex",
		"body" : [ "SecondaryAmmoIndex()" ],
		"description" : "Gets the secondary ammo index, or -1 if this item doesn't use secondary ammo."
	},
	"bool CBasePlayerWeapon::UpdateClientData(CBasePlayer@ pPlayer)": {
		"prefix": "UpdateClientData",
		"body" : [ "UpdateClientData( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Updates client data."
	},
	"CBasePlayerWeapon@ CBasePlayerWeapon::GetWeaponPtr()": {
		"prefix": "GetWeaponPtr",
		"body" : [ "GetWeaponPtr()" ],
		"description" : "Gets this item as a weapon. Returns null if this is not a weapon."
	},
	"int CBasePlayerWeapon::iItemSlot()": {
		"prefix": "iItemSlot",
		"body" : [ "iItemSlot()" ],
		"description" : "Gets the slot this item is in. 0 to MAX_ITEMS_SLOTS."
	},
	"int CBasePlayerWeapon::iItemPosition()": {
		"prefix": "iItemPosition",
		"body" : [ "iItemPosition()" ],
		"description" : "Gets the item position."
	},
	"string CBasePlayerWeapon::pszAmmo1()": {
		"prefix": "pszAmmo1",
		"body" : [ "pszAmmo1()" ],
		"description" : "Gets the name of the primary ammo."
	},
	"int CBasePlayerWeapon::iMaxAmmo1()": {
		"prefix": "iMaxAmmo1",
		"body" : [ "iMaxAmmo1()" ],
		"description" : "Gets the primary ammo maximum."
	},
	"string CBasePlayerWeapon::pszAmmo2()": {
		"prefix": "pszAmmo2",
		"body" : [ "pszAmmo2()" ],
		"description" : "Gets the name of the secondary ammo."
	},
	"int CBasePlayerWeapon::iMaxAmmo2()": {
		"prefix": "iMaxAmmo2",
		"body" : [ "iMaxAmmo2()" ],
		"description" : "Gets the secondary ammo maximum."
	},
	"string CBasePlayerWeapon::pszName()": {
		"prefix": "pszName",
		"body" : [ "pszName()" ],
		"description" : "Gets the name of this item."
	},
	"int CBasePlayerWeapon::iMaxClip()": {
		"prefix": "iMaxClip",
		"body" : [ "iMaxClip()" ],
		"description" : "Gets the max clip amount."
	},
	"int CBasePlayerWeapon::iWeight()": {
		"prefix": "iWeight",
		"body" : [ "iWeight()" ],
		"description" : "Gets the item weight."
	},
	"int CBasePlayerWeapon::iFlags()": {
		"prefix": "iFlags",
		"body" : [ "iFlags()" ],
		"description" : "Gets the item flags."
	},
	"float CBasePlayerWeapon::GetRespawnTime() const": {
		"prefix": "GetRespawnTime",
		"body" : [ "GetRespawnTime()" ],
		"description" : "Gets this item's respawn time (time from pickup to respawn)."
	},
	"CBasePlayerItem@ CBasePlayerWeapon::DropItem()": {
		"prefix": "DropItem",
		"body" : [ "DropItem()" ],
		"description" : "CBaseEntity to drop. By default, this entity."
	},
	"bool CBasePlayerWeapon::CanHaveDuplicates()": {
		"prefix": "CanHaveDuplicates",
		"body" : [ "CanHaveDuplicates()" ],
		"description" : "Can this weapon have duplicates added?"
	},
	"void CBasePlayerWeapon::SendWeaponAnim(int iAnim, int skiplocal = 0, int body = 0)": {
		"prefix": "SendWeaponAnim",
		"body" : [ "SendWeaponAnim( ${1:int iAnim}, ${2:int skiplocal = 0}, ${3:int body = 0} )" ],
		"description" : "skiplocal is 1 if client is predicting weapon animations"
	},
	"Vector CBasePlayerWeapon::BulletAccuracy(const Vector& in vecMoving, const Vector& in vecStanding, const Vector& in vecCrouched)": {
		"prefix": "BulletAccuracy",
		"body" : [ "BulletAccuracy( ${1:const Vector& in vecMoving}, ${2:const Vector& in vecStanding}, ${3:const Vector& in vecCrouched} )" ],
		"description" : "Universal code to determine player bullet accuracy based on speed/stance"
	},
	"void CBasePlayerWeapon::PrimaryAttack()": {
		"prefix": "PrimaryAttack",
		"body" : [ "PrimaryAttack()" ],
		"description" : "do \"+ATTACK\"."
	},
	"void CBasePlayerWeapon::SecondaryAttack()": {
		"prefix": "SecondaryAttack",
		"body" : [ "SecondaryAttack()" ],
		"description" : "do \"+ATTACK2\"."
	},
	"void CBasePlayerWeapon::TertiaryAttack()": {
		"prefix": "TertiaryAttack",
		"body" : [ "TertiaryAttack()" ],
		"description" : "do \"+ATTACK3\"."
	},
	"void CBasePlayerWeapon::FinishReload()": {
		"prefix": "FinishReload",
		"body" : [ "FinishReload()" ],
		"description" : "Finishes the reload for this weapon."
	},
	"bool CBasePlayerWeapon::ShouldReload()": {
		"prefix": "ShouldReload",
		"body" : [ "ShouldReload()" ],
		"description" : "Returns whether this weapon should reload automatically."
	},
	"void CBasePlayerWeapon::WeaponIdle()": {
		"prefix": "WeaponIdle",
		"body" : [ "WeaponIdle()" ],
		"description" : "called when no buttons pressed"
	},
	"void CBasePlayerWeapon::RetireWeapon()": {
		"prefix": "RetireWeapon",
		"body" : [ "RetireWeapon()" ],
		"description" : "no more ammo for this gun, put it away."
	},
	"bool CBasePlayerWeapon::UseDecrement()": {
		"prefix": "UseDecrement",
		"body" : [ "UseDecrement()" ],
		"description" : "Whether the client predicts this weapon"
	},
	"string CBasePlayerWeapon::GetP_Model()": {
		"prefix": "GetP_Model",
		"body" : [ "GetP_Model()" ],
		"description" : "Gets the weapon's P model."
	},
	"string CBasePlayerWeapon::GetP_Model(const string& in szAlternative)": {
		"prefix": "GetP_Model",
		"body" : [ "GetP_Model( ${1:const string& in szAlternative} )" ],
		"description" : "Gets the weapon's P model."
	},
	"string CBasePlayerWeapon::GetW_Model()": {
		"prefix": "GetW_Model",
		"body" : [ "GetW_Model()" ],
		"description" : "Gets the weapon's W model."
	},
	"string CBasePlayerWeapon::GetW_Model(const string& in szAlternative)": {
		"prefix": "GetW_Model",
		"body" : [ "GetW_Model( ${1:const string& in szAlternative} )" ],
		"description" : "Gets the weapon's W model."
	},
	"string CBasePlayerWeapon::GetV_Model()": {
		"prefix": "GetV_Model",
		"body" : [ "GetV_Model()" ],
		"description" : "Gets the weapon's V model."
	},
	"string CBasePlayerWeapon::GetV_Model(const string& in szAlternative)": {
		"prefix": "GetV_Model",
		"body" : [ "GetV_Model( ${1:const string& in szAlternative} )" ],
		"description" : "Gets the weapon's V model."
	},
	"void CBasePlayerWeapon::PrecacheCustomModels()": {
		"prefix": "PrecacheCustomModels",
		"body" : [ "PrecacheCustomModels()" ],
		"description" : "Precaches custom models if needed."
	},
	"void CBasePlayerWeapon::SetFOV(int iFOV)": {
		"prefix": "SetFOV",
		"body" : [ "SetFOV( ${1:int iFOV} )" ],
		"description" : "0 means reset to default fov"
	},
	"entvars_t@ CBasePlayerWeapon::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBasePlayerWeapon::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBasePlayerWeapon::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBasePlayerWeapon::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBasePlayerWeapon::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBasePlayerWeapon::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBasePlayerWeapon::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBasePlayerWeapon::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBasePlayerWeapon::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBasePlayerWeapon::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBasePlayerWeapon::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBasePlayerWeapon::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBasePlayerWeapon::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBasePlayerWeapon::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBasePlayerWeapon::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBasePlayerWeapon::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBasePlayerWeapon::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBasePlayerWeapon::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CBasePlayerWeapon::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CBasePlayerWeapon::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CBasePlayerWeapon::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CBasePlayerWeapon::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CBasePlayerWeapon::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CBasePlayerWeapon::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"EHandle CBasePlayerWeapon::m_hPlayer": {
		"prefix": "m_hPlayer",
		"body" : [ "m_hPlayer" ],
		"description" : "The owning player. null if no owner."
	},
	"EHandle CBasePlayerWeapon::m_hNextItem": {
		"prefix": "m_hNextItem",
		"body" : [ "m_hNextItem" ],
		"description" : "Gets the next item. null if no next item."
	},
	"const int CBasePlayerWeapon::m_iId": {
		"prefix": "m_iId",
		"body" : [ "m_iId" ],
		"description" : "The item id."
	},
	"float CBasePlayerWeapon::m_flLastBounce": {
		"prefix": "m_flLastBounce",
		"body" : [ "m_flLastBounce" ],
		"description" : "The last bounce time."
	},
	"bool CBasePlayerWeapon::m_bExclusiveHold": {
		"prefix": "m_bExclusiveHold",
		"body" : [ "m_bExclusiveHold" ],
		"description" : "If set, as long as a player has this item, the player must keep this weapon selected.No more than one item with this set can be carried at one time."
	},
	"bool CBasePlayerWeapon::m_bPlayEmptySound": {
		"prefix": "m_bPlayEmptySound",
		"body" : [ "m_bPlayEmptySound" ],
		"description" : "Whether to play the empty sound when the player attempts to fire"
	},
	"bool CBasePlayerWeapon::m_bFireOnEmpty": {
		"prefix": "m_bFireOnEmpty",
		"body" : [ "m_bFireOnEmpty" ],
		"description" : "True when the gun is empty and the player is still holding down the attack key(s)"
	},
	"float CBasePlayerWeapon::m_flNextPrimaryAttack": {
		"prefix": "m_flNextPrimaryAttack",
		"body" : [ "m_flNextPrimaryAttack" ],
		"description" : "soonest time ItemPostFrame will call PrimaryAttack"
	},
	"float CBasePlayerWeapon::m_flNextSecondaryAttack": {
		"prefix": "m_flNextSecondaryAttack",
		"body" : [ "m_flNextSecondaryAttack" ],
		"description" : "soonest time ItemPostFrame will call SecondaryAttack"
	},
	"float CBasePlayerWeapon::m_flNextTertiaryAttack": {
		"prefix": "m_flNextTertiaryAttack",
		"body" : [ "m_flNextTertiaryAttack" ],
		"description" : "soonest time ItemPostFrame will call TertiaryAttack"
	},
	"float CBasePlayerWeapon::m_flTimeWeaponIdle": {
		"prefix": "m_flTimeWeaponIdle",
		"body" : [ "m_flTimeWeaponIdle" ],
		"description" : "soonest time ItemPostFrame will call WeaponIdle"
	},
	"int CBasePlayerWeapon::m_iPrimaryAmmoType": {
		"prefix": "m_iPrimaryAmmoType",
		"body" : [ "m_iPrimaryAmmoType" ],
		"description" : "\"primary\" ammo index into players m_rgAmmo[]"
	},
	"int CBasePlayerWeapon::m_iSecondaryAmmoType": {
		"prefix": "m_iSecondaryAmmoType",
		"body" : [ "m_iSecondaryAmmoType" ],
		"description" : "\"secondary\" ammo index into players m_rgAmmo[]"
	},
	"int CBasePlayerWeapon::m_iClip": {
		"prefix": "m_iClip",
		"body" : [ "m_iClip" ],
		"description" : "number of shots left in the primary weapon clip, -1 it not used"
	},
	"int CBasePlayerWeapon::m_iClip2": {
		"prefix": "m_iClip2",
		"body" : [ "m_iClip2" ],
		"description" : "number of shots left in the secondary weapon clip, -1 it not used"
	},
	"bool CBasePlayerWeapon::m_fInReload": {
		"prefix": "m_fInReload",
		"body" : [ "m_fInReload" ],
		"description" : "Are we in the middle of a reload"
	},
	"float CBasePlayerWeapon::m_flCustomDmg": {
		"prefix": "m_flCustomDmg",
		"body" : [ "m_flCustomDmg" ],
		"description" : "Per-entity weapon damage"
	},
	"bool CBasePlayerWeapon::m_fIsAkimbo": {
		"prefix": "m_fIsAkimbo",
		"body" : [ "m_fIsAkimbo" ],
		"description" : "Weapon is in 'akimbo' mode"
	},
	"bool CBasePlayerWeapon::m_fInZoom": {
		"prefix": "m_fInZoom",
		"body" : [ "m_fInZoom" ],
		"description" : "Weapon is zoomed in"
	},
	"float CBasePlayerWeapon::m_flNextBurstRound": {
		"prefix": "m_flNextBurstRound",
		"body" : [ "m_flNextBurstRound" ],
		"description" : "When the next burst round is to be fired"
	},
	"int CBasePlayerWeapon::m_iDefaultAmmo": {
		"prefix": "m_iDefaultAmmo",
		"body" : [ "m_iDefaultAmmo" ],
		"description" : "The amount of primary ammo you receive when you pick up this weapon as placed by a level designer."
	},
	"int CBasePlayerWeapon::m_iDefaultSecAmmo": {
		"prefix": "m_iDefaultSecAmmo",
		"body" : [ "m_iDefaultSecAmmo" ],
		"description" : "The amount of secondary ammo you receive when you pick up this weapon as placed by a level designer."
	},
	"CBaseEntity@ CBaseTank::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBaseTank::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBaseTank::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBaseTank::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBaseTank::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBaseTank::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBaseTank::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBaseTank::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBaseTank::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBaseTank::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBaseTank::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBaseTank::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBaseTank::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBaseTank::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBaseTank::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBaseTank::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBaseTank::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBaseTank::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBaseTank::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBaseTank::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBaseTank::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBaseTank::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBaseTank::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBaseTank::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBaseTank::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBaseTank::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBaseTank::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBaseTank::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBaseTank::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBaseTank::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBaseTank::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBaseTank::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBaseTank::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBaseTank::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBaseTank::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBaseTank::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBaseTank::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBaseTank::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBaseTank::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBaseTank::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBaseTank::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBaseTank::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBaseTank::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBaseTank::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBaseTank::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBaseTank::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CBaseTank::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CBaseTank::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBaseTank::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBaseTank::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBaseTank::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBaseTank::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBaseTank::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBaseTank::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBaseTank::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBaseTank::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBaseTank::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBaseTank::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBaseTank::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBaseTank::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBaseTank::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBaseTank::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBaseTank::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBaseTank::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBaseTank::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBaseTank::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBaseTank::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBaseTank::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBaseTank::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBaseTank::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBaseTank::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBaseTank::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBaseTank::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBaseTank::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBaseTank::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBaseTank::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBaseTank::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBaseTank::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBaseTank::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBaseTank::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBaseTank::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBaseTank::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBaseTank::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBaseTank::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBaseTank::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBaseTank::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBaseTank::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBaseTank::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBaseTank::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBaseTank::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBaseTank::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBaseTank::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBaseTank::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBaseTank::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBaseTank::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBaseTank::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBaseTank::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBaseTank::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBaseTank::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBaseTank::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBaseTank::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBaseTank::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBaseTank::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBaseTank::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBaseTank::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBaseTank::TrackTarget()": {
		"prefix": "TrackTarget",
		"body" : [ "TrackTarget()" ],
		"description" : "Updates the tank's angles to match either its controlling player, or its current target.Accounts for rotation speed. Will fire at the target if it's automated."
	},
	"bool CBaseTank::PointAt(const Vector& in vecDestination)": {
		"prefix": "PointAt",
		"body" : [ "PointAt( ${1:const Vector& in vecDestination} )" ],
		"description" : "Points the tank at the target location."
	},
	"void CBaseTank::Fire(const Vector& in vecBarrelEnd, const Vector& in vecForward, entvars_t@ pevAttacker)": {
		"prefix": "Fire",
		"body" : [ "Fire( ${1:const Vector& in vecBarrelEnd}, ${2:const Vector& in vecForward}, ${3:entvars_t@ pevAttacker} )" ],
		"description" : "Fires the tank. Barrel end position, aiming direction and attacker entvars_t must be given."
	},
	"void CBaseTank::Fire()": {
		"prefix": "Fire",
		"body" : [ "Fire()" ],
		"description" : "Fires the tank. Uses this tank's settings to fire, does not determine if it is targeting anything."
	},
	"Vector CBaseTank::UpdateTargetPosition(CBaseEntity@ pTargetEntity)": {
		"prefix": "UpdateTargetPosition",
		"body" : [ "UpdateTargetPosition( ${1:CBaseEntity@ pTargetEntity} )" ],
		"description" : "Gets the updated position of the given target. Target must be valid."
	},
	"void CBaseTank::StartRotSound()": {
		"prefix": "StartRotSound",
		"body" : [ "StartRotSound()" ],
		"description" : "Start playing the rotating sound, if defined."
	},
	"void CBaseTank::StopRotSound()": {
		"prefix": "StopRotSound",
		"body" : [ "StopRotSound()" ],
		"description" : "Stop playing the rotating sound."
	},
	"bool CBaseTank::IsActive() const": {
		"prefix": "IsActive",
		"body" : [ "IsActive()" ],
		"description" : "Returns whether the tank is active. Active tanks are AI controlled."
	},
	"void CBaseTank::TankActivate()": {
		"prefix": "TankActivate",
		"body" : [ "TankActivate()" ],
		"description" : "Activates the tank. Active tanks are AI controlled."
	},
	"void CBaseTank::TankDeactivate()": {
		"prefix": "TankDeactivate",
		"body" : [ "TankDeactivate()" ],
		"description" : "Deactivates the tank. Active tanks are AI controlled."
	},
	"bool CBaseTank::CanFire() const": {
		"prefix": "CanFire",
		"body" : [ "CanFire()" ],
		"description" : "Returns whether this tank is able to fire."
	},
	"bool CBaseTank::InRange(float flRange)": {
		"prefix": "InRange",
		"body" : [ "InRange( ${1:float flRange} )" ],
		"description" : "Returns whether the given range is within the minimum and maximum range of this tank."
	},
	"CBaseEntity@ CBaseTank::FindTarget()": {
		"prefix": "FindTarget",
		"body" : [ "FindTarget()" ],
		"description" : "Finds a target to attack, if any."
	},
	"void CBaseTank::MonsterStartup(CBaseMonster@ pMonster)": {
		"prefix": "MonsterStartup",
		"body" : [ "MonsterStartup( ${1:CBaseMonster@ pMonster} )" ],
		"description" : "Makes the given monster begin controlling this tank, if no other monster had control before."
	},
	"void CBaseTank::TankTrace(const Vector& in vecStart, const Vector& in vecForward, const Vector& in vecSpread, TraceResult& out tr)": {
		"prefix": "TankTrace",
		"body" : [ "TankTrace( ${1:const Vector& in vecStart}, ${2:const Vector& in vecForward}, ${3:const Vector& in vecSpread}, ${4:TraceResult& out tr} )" ],
		"description" : "Performs a traceline using a random spread based on the given spread amount."
	},
	"Vector CBaseTank::BarrelPosition()": {
		"prefix": "BarrelPosition",
		"body" : [ "BarrelPosition()" ],
		"description" : "Returns the barrel position."
	},
	"int CBaseTank::BulletCount()": {
		"prefix": "BulletCount",
		"body" : [ "BulletCount()" ],
		"description" : "Gets the bullet count at this time."
	},
	"Vector CBaseTank::AdjustAnglesForBarrel(const Vector& in vecInAngles, float flDistance)": {
		"prefix": "AdjustAnglesForBarrel",
		"body" : [ "AdjustAnglesForBarrel( ${1:const Vector& in vecInAngles}, ${2:float flDistance} )" ],
		"description" : "Adjusts the given angles to point at the target."
	},
	"bool CBaseTank::StartControl(CBasePlayer@ pController)": {
		"prefix": "StartControl",
		"body" : [ "StartControl( ${1:CBasePlayer@ pController} )" ],
		"description" : "Makes the given player start controlling this tank."
	},
	"void CBaseTank::StopControl()": {
		"prefix": "StopControl",
		"body" : [ "StopControl()" ],
		"description" : "If a player is controlling this tank, makes the player stop controlling the tank."
	},
	"void CBaseTank::MonsterStopControl()": {
		"prefix": "MonsterStopControl",
		"body" : [ "MonsterStopControl()" ],
		"description" : "If a monster is controlling this tank, makes the monster stop controlling the tank."
	},
	"void CBaseTank::Look(int iDistance)": {
		"prefix": "Look",
		"body" : [ "Look( ${1:int iDistance} )" ],
		"description" : "Looks around itself in a box that is iDistance * 2 in width and height for possible targets and stores the list in m_pLink. The target stores the next target in the list in its m_pLink, and so on."
	},
	"const CBasePlayer@ CBaseTank::GetController()": {
		"prefix": "GetController",
		"body" : [ "GetController()" ],
		"description" : "Gets the current player controlling this tank, if any."
	},
	"entvars_t@ CBaseTank::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBaseTank::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBaseTank::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBaseTank::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBaseTank::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBaseTank::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBaseTank::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBaseTank::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBaseTank::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBaseTank::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBaseTank::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBaseTank::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBaseTank::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBaseTank::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBaseTank::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBaseTank::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"Vector CBaseTank::m_vecControllerUsePos": {
		"prefix": "m_vecControllerUsePos",
		"body" : [ "m_vecControllerUsePos" ],
		"description" : "Start origin of the player that is currently controlling this tank. Used to determine when a player has moved too far to continue controlling this tank."
	},
	"float CBaseTank::m_flNextAttack": {
		"prefix": "m_flNextAttack",
		"body" : [ "m_flNextAttack" ],
		"description" : "Next attack time"
	},
	"float CBaseTank::m_yawCenter": {
		"prefix": "m_yawCenter",
		"body" : [ "m_yawCenter" ],
		"description" : "\"Center\" yaw"
	},
	"float CBaseTank::m_yawRate": {
		"prefix": "m_yawRate",
		"body" : [ "m_yawRate" ],
		"description" : "Max turn rate to track targets"
	},
	"float CBaseTank::m_yawRange": {
		"prefix": "m_yawRange",
		"body" : [ "m_yawRange" ],
		"description" : "Range of turning motion (one-sided: 30 is +/- 30 degress from center). Zero is full rotation"
	},
	"float CBaseTank::m_yawTolerance": {
		"prefix": "m_yawTolerance",
		"body" : [ "m_yawTolerance" ],
		"description" : "Tolerance angle"
	},
	"float CBaseTank::m_pitchCenter": {
		"prefix": "m_pitchCenter",
		"body" : [ "m_pitchCenter" ],
		"description" : "\"Center\" pitch"
	},
	"float CBaseTank::m_pitchRate": {
		"prefix": "m_pitchRate",
		"body" : [ "m_pitchRate" ],
		"description" : "Max turn rate on pitch"
	},
	"float CBaseTank::m_pitchRange": {
		"prefix": "m_pitchRange",
		"body" : [ "m_pitchRange" ],
		"description" : "Range of pitch motion as above"
	},
	"float CBaseTank::m_pitchTolerance": {
		"prefix": "m_pitchTolerance",
		"body" : [ "m_pitchTolerance" ],
		"description" : "Tolerance angle"
	},
	"float CBaseTank::m_fireLast": {
		"prefix": "m_fireLast",
		"body" : [ "m_fireLast" ],
		"description" : "Last time I fired"
	},
	"float CBaseTank::m_fireRate": {
		"prefix": "m_fireRate",
		"body" : [ "m_fireRate" ],
		"description" : "How many rounds/second"
	},
	"float CBaseTank::m_lastSightTime": {
		"prefix": "m_lastSightTime",
		"body" : [ "m_lastSightTime" ],
		"description" : "Last time I saw target"
	},
	"float CBaseTank::m_persist": {
		"prefix": "m_persist",
		"body" : [ "m_persist" ],
		"description" : "Persistence of firing (how long do I shoot when I can't see)"
	},
	"float CBaseTank::m_minRange": {
		"prefix": "m_minRange",
		"body" : [ "m_minRange" ],
		"description" : "Minimum range to aim/track"
	},
	"float CBaseTank::m_maxRange": {
		"prefix": "m_maxRange",
		"body" : [ "m_maxRange" ],
		"description" : "Max range to aim/track"
	},
	"Vector CBaseTank::m_barrelPos": {
		"prefix": "m_barrelPos",
		"body" : [ "m_barrelPos" ],
		"description" : "Length of the freakin barrel"
	},
	"float CBaseTank::m_spriteScale": {
		"prefix": "m_spriteScale",
		"body" : [ "m_spriteScale" ],
		"description" : "Scale of any sprites we shoot"
	},
	"TANKBULLET CBaseTank::m_bulletType": {
		"prefix": "m_bulletType",
		"body" : [ "m_bulletType" ],
		"description" : "Bullet type"
	},
	"int CBaseTank::m_iBulletDamage": {
		"prefix": "m_iBulletDamage",
		"body" : [ "m_iBulletDamage" ],
		"description" : "0 means use Bullet type's default damage"
	},
	"Vector CBaseTank::m_sightOrigin": {
		"prefix": "m_sightOrigin",
		"body" : [ "m_sightOrigin" ],
		"description" : "Last sight of target"
	},
	"int CBaseTank::m_spread": {
		"prefix": "m_spread",
		"body" : [ "m_spread" ],
		"description" : "firing spread"
	},
	"string_t CBaseTank::m_iszMaster": {
		"prefix": "m_iszMaster",
		"body" : [ "m_iszMaster" ],
		"description" : "Master entity (game_team_master or multisource)"
	},
	"CBaseAnimating@ CBaseToggle::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CBaseToggle::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CBaseToggle::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBaseToggle::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBaseToggle::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBaseToggle::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBaseToggle::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBaseToggle::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBaseToggle::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBaseToggle::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBaseToggle::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBaseToggle::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBaseToggle::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBaseToggle::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBaseToggle::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBaseToggle::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBaseToggle::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBaseToggle::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBaseToggle::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBaseToggle::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBaseToggle::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBaseToggle::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBaseToggle::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBaseToggle::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBaseToggle::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBaseToggle::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBaseToggle::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBaseToggle::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBaseToggle::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBaseToggle::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBaseToggle::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBaseToggle::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBaseToggle::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBaseToggle::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBaseToggle::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBaseToggle::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBaseToggle::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBaseToggle::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBaseToggle::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBaseToggle::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBaseToggle::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBaseToggle::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBaseToggle::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBaseToggle::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBaseToggle::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBaseToggle::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBaseToggle::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBaseToggle::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CBaseToggle::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBaseToggle::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBaseToggle::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBaseToggle::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBaseToggle::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBaseToggle::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBaseToggle::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBaseToggle::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBaseToggle::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBaseToggle::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBaseToggle::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBaseToggle::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBaseToggle::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBaseToggle::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBaseToggle::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBaseToggle::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBaseToggle::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBaseToggle::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBaseToggle::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBaseToggle::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBaseToggle::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBaseToggle::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBaseToggle::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBaseToggle::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBaseToggle::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBaseToggle::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBaseToggle::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBaseToggle::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBaseToggle::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBaseToggle::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBaseToggle::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBaseToggle::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBaseToggle::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBaseToggle::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBaseToggle::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBaseToggle::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBaseToggle::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBaseToggle::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBaseToggle::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBaseToggle::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBaseToggle::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBaseToggle::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBaseToggle::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBaseToggle::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBaseToggle::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBaseToggle::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBaseToggle::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBaseToggle::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBaseToggle::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBaseToggle::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBaseToggle::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBaseToggle::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBaseToggle::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBaseToggle::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBaseToggle::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBaseToggle::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBaseToggle::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBaseToggle::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBaseToggle::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CBaseToggle::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CBaseToggle::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CBaseToggle::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CBaseToggle::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CBaseToggle::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CBaseToggle::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CBaseToggle::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CBaseToggle::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CBaseToggle::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CBaseToggle::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CBaseToggle::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CBaseToggle::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CBaseToggle::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CBaseToggle::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CBaseToggle::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CBaseToggle::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CBaseToggle::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CBaseToggle::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CBaseToggle::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CBaseToggle::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CBaseToggle::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CBaseToggle::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CBaseToggle::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"void CBaseToggle::LinearMove(Vector vecDest, float flSpeed)": {
		"prefix": "LinearMove",
		"body" : [ "LinearMove( ${1:Vector vecDest}, ${2:float flSpeed} )" ],
		"description" : "Performs linear movement."
	},
	"void CBaseToggle::AngularMove(Vector vecDestAngle, float flSpeed)": {
		"prefix": "AngularMove",
		"body" : [ "AngularMove( ${1:Vector vecDestAngle}, ${2:float flSpeed} )" ],
		"description" : "Performs angular movement."
	},
	"bool CBaseToggle::IsToggleLockedByMaster()": {
		"prefix": "IsToggleLockedByMaster",
		"body" : [ "IsToggleLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master. Separate from IsLockedByMaster due to limitations."
	},
	"InventoryRules@ CBaseToggle::get_m_pInventoryRules() const": {
		"prefix": "get_m_pInventoryRules",
		"body" : [ "get_m_pInventoryRules()" ],
		"description" : "The inventory rules."
	},
	"CBaseMonster@ CBaseToggle::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CCineMonster@ CBaseToggle::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBasePlayer@ CBaseToggle::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CGrenade@ CBaseToggle::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseButton@ CBaseToggle::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"CBaseDoor@ CBaseToggle::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"entvars_t@ CBaseToggle::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBaseToggle::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBaseToggle::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBaseToggle::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBaseToggle::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBaseToggle::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBaseToggle::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBaseToggle::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBaseToggle::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBaseToggle::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBaseToggle::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBaseToggle::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBaseToggle::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBaseToggle::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBaseToggle::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBaseToggle::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CBaseToggle::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CBaseToggle::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CBaseToggle::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CBaseToggle::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CBaseToggle::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CBaseToggle::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CBaseToggle::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CBaseToggle::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"TOGGLE_STATE CBaseToggle::m_toggle_state": {
		"prefix": "m_toggle_state",
		"body" : [ "m_toggle_state" ],
		"description" : "Current toggle state."
	},
	"float CBaseToggle::m_flMoveDistance": {
		"prefix": "m_flMoveDistance",
		"body" : [ "m_flMoveDistance" ],
		"description" : "How far a door should slide or rotate."
	},
	"float CBaseToggle::m_flWait": {
		"prefix": "m_flWait",
		"body" : [ "m_flWait" ],
		"description" : "How long to wait before resetting."
	},
	"float CBaseToggle::m_flLip": {
		"prefix": "m_flLip",
		"body" : [ "m_flLip" ],
		"description" : "How much to stick out of a wall. Will recede further into walls if negative."
	},
	"float CBaseToggle::m_flTWidth": {
		"prefix": "m_flTWidth",
		"body" : [ "m_flTWidth" ],
		"description" : "For plats."
	},
	"float CBaseToggle::m_flTLength": {
		"prefix": "m_flTLength",
		"body" : [ "m_flTLength" ],
		"description" : "For plats."
	},
	"int CBaseToggle::m_cTriggersLeft": {
		"prefix": "m_cTriggersLeft",
		"body" : [ "m_cTriggersLeft" ],
		"description" : "Trigger_counter only: # of activations remaining."
	},
	"float CBaseToggle::m_flHeight": {
		"prefix": "m_flHeight",
		"body" : [ "m_flHeight" ],
		"description" : "Height."
	},
	"EHandle CBaseToggle::m_hActivator": {
		"prefix": "m_hActivator",
		"body" : [ "m_hActivator" ],
		"description" : "Handle to the activator."
	},
	"Vector CBaseToggle::m_vecPosition1": {
		"prefix": "m_vecPosition1",
		"body" : [ "m_vecPosition1" ],
		"description" : "Closed position."
	},
	"Vector CBaseToggle::m_vecPosition2": {
		"prefix": "m_vecPosition2",
		"body" : [ "m_vecPosition2" ],
		"description" : "Open position."
	},
	"Vector CBaseToggle::m_vecAngle1": {
		"prefix": "m_vecAngle1",
		"body" : [ "m_vecAngle1" ],
		"description" : "Closed angle."
	},
	"Vector CBaseToggle::m_vecAngle2": {
		"prefix": "m_vecAngle2",
		"body" : [ "m_vecAngle2" ],
		"description" : "Open angle."
	},
	"Vector CBaseToggle::m_vecFinalDest": {
		"prefix": "m_vecFinalDest",
		"body" : [ "m_vecFinalDest" ],
		"description" : "Final destination."
	},
	"Vector CBaseToggle::m_vecFinalAngle": {
		"prefix": "m_vecFinalAngle",
		"body" : [ "m_vecFinalAngle" ],
		"description" : "Final angle."
	},
	"int CBaseToggle::m_bitsDamageInflict": {
		"prefix": "m_bitsDamageInflict",
		"body" : [ "m_bitsDamageInflict" ],
		"description" : "DMG_ damage type that the door or trigger does."
	},
	"string_t CBaseToggle::m_sMaster": {
		"prefix": "m_sMaster",
		"body" : [ "m_sMaster" ],
		"description" : "This entity's master, if any."
	},
	"CBaseEntity@ CBeam::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CBeam::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CBeam::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CBeam::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CBeam::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CBeam::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CBeam::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CBeam::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CBeam::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CBeam::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CBeam::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CBeam::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CBeam::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CBeam::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CBeam::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CBeam::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CBeam::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CBeam::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CBeam::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CBeam::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CBeam::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CBeam::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CBeam::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CBeam::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CBeam::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CBeam::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CBeam::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CBeam::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CBeam::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CBeam::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CBeam::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CBeam::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CBeam::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CBeam::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CBeam::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CBeam::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CBeam::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CBeam::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CBeam::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CBeam::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CBeam::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CBeam::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CBeam::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CBeam::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CBeam::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CBeam::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CBeam::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CBeam::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CBeam::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CBeam::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CBeam::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CBeam::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CBeam::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CBeam::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CBeam::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CBeam::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CBeam::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CBeam::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CBeam::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CBeam::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CBeam::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CBeam::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CBeam::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CBeam::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CBeam::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CBeam::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CBeam::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CBeam::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CBeam::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CBeam::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CBeam::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CBeam::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CBeam::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CBeam::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CBeam::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CBeam::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CBeam::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CBeam::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CBeam::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CBeam::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CBeam::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CBeam::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CBeam::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CBeam::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CBeam::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CBeam::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CBeam::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CBeam::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CBeam::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CBeam::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CBeam::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CBeam::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CBeam::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CBeam::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CBeam::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CBeam::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CBeam::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CBeam::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CBeam::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CBeam::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CBeam::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CBeam::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CBeam::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CBeam::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CBeam::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CBeam::SetType(BeamType type)": {
		"prefix": "SetType",
		"body" : [ "SetType( ${1:BeamType type} )" ],
		"description" : "Sets the type of the beam."
	},
	"void CBeam::SetFlags(int flags)": {
		"prefix": "SetFlags",
		"body" : [ "SetFlags( ${1:int flags} )" ],
		"description" : "Sets the flags of the beam. Must be a combination of BeamFlags values, or 0."
	},
	"void CBeam::SetStartPos(const Vector& in vecPos)": {
		"prefix": "SetStartPos",
		"body" : [ "SetStartPos( ${1:const Vector& in vecPos} )" ],
		"description" : "Sets the starting position of the beam. Must be a beam of type BEAM_POINTS, BEAM_ENTPOINT or BEAM_HOSE."
	},
	"void CBeam::SetEndPos(const Vector& in vecPos)": {
		"prefix": "SetEndPos",
		"body" : [ "SetEndPos( ${1:const Vector& in vecPos} )" ],
		"description" : "Sets the ending position of the beam. Must be a beam of type BEAM_POINTS or BEAM_HOSE."
	},
	"void CBeam::SetStartEntity(int entityIndex)": {
		"prefix": "SetStartEntity",
		"body" : [ "SetStartEntity( ${1:int entityIndex} )" ],
		"description" : "Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS."
	},
	"void CBeam::SetStartEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetStartEntity",
		"body" : [ "SetStartEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS."
	},
	"void CBeam::SetEndEntity(int entityIndex)": {
		"prefix": "SetEndEntity",
		"body" : [ "SetEndEntity( ${1:int entityIndex} )" ],
		"description" : "Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT."
	},
	"void CBeam::SetEndEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetEndEntity",
		"body" : [ "SetEndEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT."
	},
	"void CBeam::SetStartAttachment(int attachment)": {
		"prefix": "SetStartAttachment",
		"body" : [ "SetStartAttachment( ${1:int attachment} )" ],
		"description" : "Sets the start attachment of the beam. Attachment is a point on the entity's model. Must be a beam of type BEAM_ENTS. Set to 0 to disable."
	},
	"void CBeam::SetEndAttachment(int attachment)": {
		"prefix": "SetEndAttachment",
		"body" : [ "SetEndAttachment( ${1:int attachment} )" ],
		"description" : "Sets the end attachment of the beam. Attachment is a point on the entity's model. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT. Set to 0 to disable."
	},
	"void CBeam::SetTexture(int spriteIndex)": {
		"prefix": "SetTexture",
		"body" : [ "SetTexture( ${1:int spriteIndex} )" ],
		"description" : "Sets the sprite to use. The index is the one returned from CGame::PrecacheModel."
	},
	"void CBeam::SetWidth(int iWidth)": {
		"prefix": "SetWidth",
		"body" : [ "SetWidth( ${1:int iWidth} )" ],
		"description" : "Sets the width of the beam."
	},
	"void CBeam::SetNoise(int iAmplitude)": {
		"prefix": "SetNoise",
		"body" : [ "SetNoise( ${1:int iAmplitude} )" ],
		"description" : "Sets the noise (amplitude) of the beam."
	},
	"void CBeam::SetColor(int r, int g, int b)": {
		"prefix": "SetColor",
		"body" : [ "SetColor( ${1:int r}, ${2:int g}, ${3:int b} )" ],
		"description" : "Sets the color of the beam."
	},
	"void CBeam::SetBrightness(int brightness)": {
		"prefix": "SetBrightness",
		"body" : [ "SetBrightness( ${1:int brightness} )" ],
		"description" : "Sets the brightness of the beam. Value is between 0-255."
	},
	"void CBeam::SetFrame(float frame)": {
		"prefix": "SetFrame",
		"body" : [ "SetFrame( ${1:float frame} )" ],
		"description" : "Sets the frame number of the beam."
	},
	"void CBeam::SetScrollRate(int speed)": {
		"prefix": "SetScrollRate",
		"body" : [ "SetScrollRate( ${1:int speed} )" ],
		"description" : "Sets the scroll rate of the beam."
	},
	"const Vector& CBeam::GetStartPos()": {
		"prefix": "GetStartPos",
		"body" : [ "GetStartPos()" ],
		"description" : "Gets the beam's starting position."
	},
	"const Vector& CBeam::GetEndPos()": {
		"prefix": "GetEndPos",
		"body" : [ "GetEndPos()" ],
		"description" : "Gets the beam's ending position."
	},
	"int CBeam::GetTexture()": {
		"prefix": "GetTexture",
		"body" : [ "GetTexture()" ],
		"description" : "Gets the beam's texture (sprite) index."
	},
	"int CBeam::GetWidth()": {
		"prefix": "GetWidth",
		"body" : [ "GetWidth()" ],
		"description" : "Gets the beam's width."
	},
	"int CBeam::GetNoise()": {
		"prefix": "GetNoise",
		"body" : [ "GetNoise()" ],
		"description" : "Gets the beam's noise."
	},
	"void CBeam::GetColor(int& out r, int& out g, int& out b)": {
		"prefix": "GetColor",
		"body" : [ "GetColor( ${1:int& out r}, ${2:int& out g}, ${3:int& out b} )" ],
		"description" : "Gets the beam's color."
	},
	"int CBeam::GetBrightness()": {
		"prefix": "GetBrightness",
		"body" : [ "GetBrightness()" ],
		"description" : "Gets the beam's brightness."
	},
	"int CBeam::GetFrame()": {
		"prefix": "GetFrame",
		"body" : [ "GetFrame()" ],
		"description" : "Gets the beam's frame number."
	},
	"int CBeam::GetScrollRate()": {
		"prefix": "GetScrollRate",
		"body" : [ "GetScrollRate()" ],
		"description" : "Gets the beam's scroll rate."
	},
	"void CBeam::RelinkBeam()": {
		"prefix": "RelinkBeam",
		"body" : [ "RelinkBeam()" ],
		"description" : "Call after you change start/end positions."
	},
	"void CBeam::DoSparks(const Vector& in vecStart, const Vector& in vecEnd)": {
		"prefix": "DoSparks",
		"body" : [ "DoSparks( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd} )" ],
		"description" : "Creates sparks at the given start and end points, if appropriate spawn flags are set."
	},
	"void CBeam::BeamDamage(TraceResult& in tr)": {
		"prefix": "BeamDamage",
		"body" : [ "BeamDamage( ${1:TraceResult& in tr} )" ],
		"description" : "Damages the entity hit by the given trace line with the amount set in this entity's pev->dmg variable. Also applies decals to BSP models if the appropriate spawnflag is set."
	},
	"void CBeam::BeamInit(const string& in szSpriteName, int iWidth)": {
		"prefix": "BeamInit",
		"body" : [ "BeamInit( ${1:const string& in szSpriteName}, ${2:int iWidth} )" ],
		"description" : "Initializes this beam with default values and sets the given sprite as the sprite used, with the given width."
	},
	"void CBeam::PointsInit(const Vector& in vecStart, const Vector& in vecEnd)": {
		"prefix": "PointsInit",
		"body" : [ "PointsInit( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd} )" ],
		"description" : "Initializes this beam to be a beam between 2 given points (BEAM_POINTS)."
	},
	"void CBeam::PointEntInit(const Vector& in vecStart, int endIndex)": {
		"prefix": "PointEntInit",
		"body" : [ "PointEntInit( ${1:const Vector& in vecStart}, ${2:int endIndex} )" ],
		"description" : "Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT)."
	},
	"void CBeam::PointEntInit(const Vector& in vecStart, CBaseEntity@ pEntEnd)": {
		"prefix": "PointEntInit",
		"body" : [ "PointEntInit( ${1:const Vector& in vecStart}, ${2:CBaseEntity@ pEntEnd} )" ],
		"description" : "Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT)."
	},
	"void CBeam::EntsInit(int startIndex, int endIndex)": {
		"prefix": "EntsInit",
		"body" : [ "EntsInit( ${1:int startIndex}, ${2:int endIndex} )" ],
		"description" : "Initializes this beam to be a beam between 2 given entities (BEAM_ENTS)."
	},
	"void CBeam::EntsInit(CBaseEntity@ pEntStart, CBaseEntity@ pEntEnd)": {
		"prefix": "EntsInit",
		"body" : [ "EntsInit( ${1:CBaseEntity@ pEntStart}, ${2:CBaseEntity@ pEntEnd} )" ],
		"description" : "Initializes this beam to be a beam between 2 given entities (BEAM_ENTS)."
	},
	"void CBeam::HoseInit(const Vector& in vecStart, const Vector& in vecDirection)": {
		"prefix": "HoseInit",
		"body" : [ "HoseInit( ${1:const Vector& in vecStart}, ${2:const Vector& in vecDirection} )" ],
		"description" : "Initializes this beam to be a beam going from a point in a given direction (BEAM_HOSE)."
	},
	"void CBeam::LiveForTime(float flTime)": {
		"prefix": "LiveForTime",
		"body" : [ "LiveForTime( ${1:float flTime} )" ],
		"description" : "Sets this beam to live for the given amount of time, after which it is removed."
	},
	"void CBeam::BeamDamageInstant(TraceResult& in tr, float flDamage)": {
		"prefix": "BeamDamageInstant",
		"body" : [ "BeamDamageInstant( ${1:TraceResult& in tr}, ${2:float flDamage} )" ],
		"description" : "Causes the given amount of damage to be done to the entity hit by the given traceresult, as if the damage occured one second ago."
	},
	"void CBeam::XenTeleportZap(const Vector& in vecSrc, const Vector& in vecDest)": {
		"prefix": "XenTeleportZap",
		"body" : [ "XenTeleportZap( ${1:const Vector& in vecSrc}, ${2:const Vector& in vecDest} )" ],
		"description" : "Creates a Xen teleport zap effect between the given points."
	},
	"void CBeam::XenTeleport(const Vector& in vecSrc, int iRadius = 256)": {
		"prefix": "XenTeleport",
		"body" : [ "XenTeleport( ${1:const Vector& in vecSrc}, ${2:int iRadius = 256} )" ],
		"description" : "Creates a Xen teleport effect at the given location, with zaps occuring within the given radius."
	},
	"CLaser@ CBeam::opCast()": {
		"prefix": "opCast",
		"body" : [ "opCast()" ],
		"description" : "Explicitly casts to sub type."
	},
	"entvars_t@ CBeam::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CBeam::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CBeam::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CBeam::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CBeam::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CBeam::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CBeam::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CBeam::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CBeam::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CBeam::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CBeam::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CBeam::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CBeam::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CBeam::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CBeam::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CBeam::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"enum CBeamSpawnflags {..., SF_BEAM_STARTON, ...}": {
		"prefix": "SF_BEAM_STARTON",
		"body" : [ "SF_BEAM_STARTON" ],
		"description" : "(1) Whether the beam should start on"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_TOGGLE, ...}": {
		"prefix": "SF_BEAM_TOGGLE",
		"body" : [ "SF_BEAM_TOGGLE" ],
		"description" : "(2) Whether the beam should be togglable by triggering it"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_RANDOM, ...}": {
		"prefix": "SF_BEAM_RANDOM",
		"body" : [ "SF_BEAM_RANDOM" ],
		"description" : "(4) Whether beams are created to a randomly selected entity with the given target name"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_RING, ...}": {
		"prefix": "SF_BEAM_RING",
		"body" : [ "SF_BEAM_RING" ],
		"description" : "(8) Whether this beam is a ring between 2 points"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_SPARKSTART, ...}": {
		"prefix": "SF_BEAM_SPARKSTART",
		"body" : [ "SF_BEAM_SPARKSTART" ],
		"description" : "(16) Whether to allow creation of sparks at the beam's start point"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_SPARKEND, ...}": {
		"prefix": "SF_BEAM_SPARKEND",
		"body" : [ "SF_BEAM_SPARKEND" ],
		"description" : "(32) Whether to allow creation of sparks at the beam's end point"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_DECALS, ...}": {
		"prefix": "SF_BEAM_DECALS",
		"body" : [ "SF_BEAM_DECALS" ],
		"description" : "(64) Whether to create decals when the beam does damage to BSP models"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_SHADEIN, ...}": {
		"prefix": "SF_BEAM_SHADEIN",
		"body" : [ "SF_BEAM_SHADEIN" ],
		"description" : "(128) Whether to fade the beam in at its start point"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_SHADEOUT, ...}": {
		"prefix": "SF_BEAM_SHADEOUT",
		"body" : [ "SF_BEAM_SHADEOUT" ],
		"description" : "(256) Whether to fade the beam out at its end point"
	},
	"enum CBeamSpawnflags {..., SF_BEAM_TEMPORARY, ...}": {
		"prefix": "SF_BEAM_TEMPORARY",
		"body" : [ "SF_BEAM_TEMPORARY" ],
		"description" : "(32768) Whether the beam is a temporary entity"
	},
	"CBaseMonster@ CCineMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseToggle@ CCineMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseAnimating@ CCineMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CCineMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CCineMonster::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CCineMonster::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CCineMonster::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CCineMonster::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CCineMonster::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CCineMonster::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CCineMonster::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CCineMonster::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CCineMonster::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CCineMonster::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CCineMonster::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CCineMonster::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CCineMonster::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CCineMonster::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CCineMonster::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CCineMonster::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CCineMonster::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CCineMonster::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CCineMonster::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CCineMonster::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CCineMonster::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CCineMonster::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CCineMonster::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CCineMonster::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CCineMonster::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CCineMonster::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CCineMonster::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CCineMonster::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CCineMonster::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CCineMonster::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CCineMonster::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CCineMonster::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CCineMonster::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CCineMonster::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CCineMonster::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CCineMonster::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CCineMonster::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CCineMonster::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CCineMonster::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CCineMonster::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CCineMonster::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CCineMonster::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CCineMonster::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CCineMonster::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CCineMonster::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CCineMonster::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CCineMonster::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CCineMonster::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CCineMonster::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CCineMonster::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CCineMonster::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CCineMonster::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CCineMonster::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CCineMonster::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CCineMonster::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CCineMonster::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CCineMonster::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CCineMonster::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CCineMonster::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CCineMonster::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CCineMonster::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CCineMonster::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CCineMonster::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CCineMonster::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CCineMonster::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CCineMonster::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CCineMonster::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CCineMonster::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CCineMonster::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CCineMonster::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CCineMonster::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CCineMonster::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CCineMonster::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CCineMonster::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CCineMonster::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CCineMonster::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CCineMonster::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CCineMonster::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CCineMonster::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CCineMonster::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CCineMonster::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CCineMonster::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CCineMonster::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CCineMonster::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CCineMonster::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CCineMonster::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CCineMonster::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CCineMonster::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CCineMonster::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CCineMonster::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CCineMonster::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CCineMonster::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CCineMonster::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CCineMonster::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CCineMonster::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CCineMonster::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CCineMonster::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CCineMonster::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CCineMonster::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CCineMonster::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CCineMonster::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CCineMonster::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CCineMonster::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CCineMonster::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CCineMonster::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CCineMonster::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CCineMonster::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CCineMonster::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CCineMonster::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CCineMonster::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CCineMonster::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CCineMonster::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CCineMonster::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CCineMonster::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CCineMonster::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CCineMonster::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CCineMonster::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CCineMonster::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CCineMonster::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CCineMonster::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CCineMonster::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CCineMonster::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CCineMonster::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CCineMonster::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CCineMonster::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CCineMonster::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CCineMonster::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CCineMonster::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"void CCineMonster::LinearMove(Vector vecDest, float flSpeed)": {
		"prefix": "LinearMove",
		"body" : [ "LinearMove( ${1:Vector vecDest}, ${2:float flSpeed} )" ],
		"description" : "Performs linear movement."
	},
	"void CCineMonster::AngularMove(Vector vecDestAngle, float flSpeed)": {
		"prefix": "AngularMove",
		"body" : [ "AngularMove( ${1:Vector vecDestAngle}, ${2:float flSpeed} )" ],
		"description" : "Performs angular movement."
	},
	"bool CCineMonster::IsToggleLockedByMaster()": {
		"prefix": "IsToggleLockedByMaster",
		"body" : [ "IsToggleLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master. Separate from IsLockedByMaster due to limitations."
	},
	"InventoryRules@ CCineMonster::get_m_pInventoryRules() const": {
		"prefix": "get_m_pInventoryRules",
		"body" : [ "get_m_pInventoryRules()" ],
		"description" : "The inventory rules."
	},
	"EHandle& CCineMonster::m_hOldEnemy(size_t uiIndex)": {
		"prefix": "m_hOldEnemy",
		"body" : [ "m_hOldEnemy( ${1:size_t uiIndex} )" ],
		"description" : "Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."
	},
	"Vector& CCineMonster::m_vecOldEnemy(size_t uiIndex)": {
		"prefix": "m_vecOldEnemy",
		"body" : [ "m_vecOldEnemy( ${1:size_t uiIndex} )" ],
		"description" : "Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."
	},
	"Waypoint& CCineMonster::m_Route(size_t uiIndex)": {
		"prefix": "m_Route",
		"body" : [ "m_Route( ${1:size_t uiIndex} )" ],
		"description" : "Positions of movement. Index must be between 0 and ROUTE_SIZE"
	},
	"int8& CCineMonster::m_rgbTimeBasedDamage(size_t uiIndex)": {
		"prefix": "m_rgbTimeBasedDamage",
		"body" : [ "m_rgbTimeBasedDamage( ${1:size_t uiIndex} )" ],
		"description" : "time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED."
	},
	"void CCineMonster::MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "MonsterUse",
		"body" : [ "MonsterUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Will make a monster angry at whomever activated it."
	},
	"void CCineMonster::Look(int iDistance)": {
		"prefix": "Look",
		"body" : [ "Look( ${1:int iDistance} )" ],
		"description" : "Look - Base class monster function to find enemies or. food by sight. iDistance is distance (in units) that the. monster can see. Sets the sight bits of the m_afConditions mask to indicate. which types of entities were sighted. Function also sets the Looker's m_pLink. to the head of a link list that contains all visible ents. (linked via each ent's m_pLink field)"
	},
	"void CCineMonster::RunAI()": {
		"prefix": "RunAI",
		"body" : [ "RunAI()" ],
		"description" : "Runs this monster's AI."
	},
	"void CCineMonster::Listen()": {
		"prefix": "Listen",
		"body" : [ "Listen()" ],
		"description" : "Listens for anything that is within audible distance."
	},
	"bool CCineMonster::ShouldFadeOnDeath()": {
		"prefix": "ShouldFadeOnDeath",
		"body" : [ "ShouldFadeOnDeath()" ],
		"description" : "Returns whether this monster should fade on death."
	},
	"float CCineMonster::ChangeYaw(int iSpeed)": {
		"prefix": "ChangeYaw",
		"body" : [ "ChangeYaw( ${1:int iSpeed} )" ],
		"description" : "turns a monster towards its ideal_yaw"
	},
	"float CCineMonster::VecToYaw(Vector vecDir)": {
		"prefix": "VecToYaw",
		"body" : [ "VecToYaw( ${1:Vector vecDir} )" ],
		"description" : "turns a directional vector into a yaw value that points down that vector."
	},
	"float CCineMonster::FlYawDiff()": {
		"prefix": "FlYawDiff",
		"body" : [ "FlYawDiff()" ],
		"description" : "returns the difference (in degrees) between monster's current yaw and ideal_yaw. Positive result is left turn, negative is right turn."
	},
	"float CCineMonster::DamageForce(float flDamage)": {
		"prefix": "DamageForce",
		"body" : [ "DamageForce( ${1:float flDamage} )" ],
		"description" : "Returns the amount of force applied to this monster when the given amount of damage is done."
	},
	"void CCineMonster::SetupFriendly()": {
		"prefix": "SetupFriendly",
		"body" : [ "SetupFriendly()" ],
		"description" : "use this overridden to make some other friendly monsters"
	},
	"void CCineMonster::MonsterInit()": {
		"prefix": "MonsterInit",
		"body" : [ "MonsterInit()" ],
		"description" : "Initializes the monster"
	},
	"void CCineMonster::MonsterInitDead()": {
		"prefix": "MonsterInitDead",
		"body" : [ "MonsterInitDead()" ],
		"description" : "Call after animation/pose is set up"
	},
	"void CCineMonster::BecomeDead(float flSavedHealth)": {
		"prefix": "BecomeDead",
		"body" : [ "BecomeDead( ${1:float flSavedHealth} )" ],
		"description" : "Makes the monster become dead"
	},
	"void CCineMonster::Revive()": {
		"prefix": "Revive",
		"body" : [ "Revive()" ],
		"description" : "Revives the monster"
	},
	"void CCineMonster::StartMonster()": {
		"prefix": "StartMonster",
		"body" : [ "StartMonster()" ],
		"description" : "Starts the monster"
	},
	"void CCineMonster::BestVisibleEnemy()": {
		"prefix": "BestVisibleEnemy",
		"body" : [ "BestVisibleEnemy()" ],
		"description" : "finds best visible enemy for attack"
	},
	"bool CCineMonster::FInViewCone(CBaseEntity@ pEntity)": {
		"prefix": "FInViewCone",
		"body" : [ "FInViewCone( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "see if pEntity is in monster's view cone"
	},
	"bool CCineMonster::FInViewCone(const Vector& in vecOrigin)": {
		"prefix": "FInViewCone",
		"body" : [ "FInViewCone( ${1:const Vector& in vecOrigin} )" ],
		"description" : "see if given location is in monster's view cone"
	},
	"int CCineMonster::CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false)": {
		"prefix": "CheckLocalMove",
		"body" : [ "CheckLocalMove( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd,CBaseEntity@ pTarget}, ${3:float& out flDist}, ${4:Vector& out vecEndPosition}, ${5:bool fOriginalCheck = false} )" ],
		"description" : "finds best visible enemy for attack"
	},
	"void CCineMonster::Move(float flInterval = 0.1f)": {
		"prefix": "Move",
		"body" : [ "Move( ${1:float flInterval = 0.1f} )" ],
		"description" : "Starts the monster"
	},
	"void CCineMonster::MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval)": {
		"prefix": "MoveExecute",
		"body" : [ "MoveExecute( ${1:CBaseEntity@ pTargetEnt}, ${2:const Vector& in vecDir}, ${3:float flInterval} )" ],
		"description" : "Starts the monster"
	},
	"bool CCineMonster::ShouldAdvanceRoute(float flWaypointDist)": {
		"prefix": "ShouldAdvanceRoute",
		"body" : [ "ShouldAdvanceRoute( ${1:float flWaypointDist} )" ],
		"description" : "Returns whether this monster should advance its route"
	},
	"Activity CCineMonster::GetStoppedActivity()": {
		"prefix": "GetStoppedActivity",
		"body" : [ "GetStoppedActivity()" ],
		"description" : "Gets the stopped activity"
	},
	"void CCineMonster::Stop()": {
		"prefix": "Stop",
		"body" : [ "Stop()" ],
		"description" : "Stops this monster moving"
	},
	"void CCineMonster::StopAnimation()": {
		"prefix": "StopAnimation",
		"body" : [ "StopAnimation()" ],
		"description" : "This will stop animation until you call ResetSequenceInfo() at some point in the future"
	},
	"bool CCineMonster::CheckRangeAttack1(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1",
		"body" : [ "CheckRangeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CCineMonster::CheckRangeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1_Move",
		"body" : [ "CheckRangeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CCineMonster::CheckRangeAttack2(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2",
		"body" : [ "CheckRangeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CCineMonster::CheckRangeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2_Move",
		"body" : [ "CheckRangeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CCineMonster::CheckMeleeAttack1(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1",
		"body" : [ "CheckMeleeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CCineMonster::CheckMeleeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1_Move",
		"body" : [ "CheckMeleeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CCineMonster::CheckMeleeAttack2(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2",
		"body" : [ "CheckMeleeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CCineMonster::CheckMeleeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2_Move",
		"body" : [ "CheckMeleeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CCineMonster::CheckTankUsage()": {
		"prefix": "CheckTankUsage",
		"body" : [ "CheckTankUsage()" ],
		"description" : "Checks whether the monster can use a func_tank. Return true if possible."
	},
	"bool CCineMonster::FHaveSchedule()": {
		"prefix": "FHaveSchedule",
		"body" : [ "FHaveSchedule()" ],
		"description" : "Returns whether this monster has a schedule."
	},
	"bool CCineMonster::FScheduleValid()": {
		"prefix": "FScheduleValid",
		"body" : [ "FScheduleValid()" ],
		"description" : "Returns whether this monster's schedule is valid."
	},
	"void CCineMonster::ClearSchedule()": {
		"prefix": "ClearSchedule",
		"body" : [ "ClearSchedule()" ],
		"description" : "Clears this monster's schedule."
	},
	"bool CCineMonster::FScheduleDone()": {
		"prefix": "FScheduleDone",
		"body" : [ "FScheduleDone()" ],
		"description" : "Returns whether this monster's schedule is done."
	},
	"void CCineMonster::ChangeSchedule(Schedule@ pNewSchedule)": {
		"prefix": "ChangeSchedule",
		"body" : [ "ChangeSchedule( ${1:Schedule@ pNewSchedule} )" ],
		"description" : "Changes this monster's schedule."
	},
	"bool CCineMonster::NextScheduledTask()": {
		"prefix": "NextScheduledTask",
		"body" : [ "NextScheduledTask()" ],
		"description" : "Moves to the next scheduled task."
	},
	"Schedule@ CCineMonster::ScheduleInList(const string& in szName, array<Schedule@>@ pArray)": {
		"prefix": "ScheduleInList",
		"body" : [ "ScheduleInList( ${1:const string& in szName}, ${2:array<Schedule@>@ pArray} )" ],
		"description" : "Returns the schedule with name szName if it's in the list, NULL otherwise."
	},
	"Schedule@ CCineMonster::ScheduleFromName(const string& in szName)": {
		"prefix": "ScheduleFromName",
		"body" : [ "ScheduleFromName( ${1:const string& in szName} )" ],
		"description" : "Returns the schedule with name szName if it exists, NULL otherwise."
	},
	"void CCineMonster::MaintainSchedule()": {
		"prefix": "MaintainSchedule",
		"body" : [ "MaintainSchedule()" ],
		"description" : "Maintains the monster's schedule."
	},
	"void CCineMonster::StartTask(Task@ pTask)": {
		"prefix": "StartTask",
		"body" : [ "StartTask( ${1:Task@ pTask} )" ],
		"description" : "Starts the given task."
	},
	"void CCineMonster::RunTask(Task@ pTask)": {
		"prefix": "RunTask",
		"body" : [ "RunTask( ${1:Task@ pTask} )" ],
		"description" : "Runs the given task."
	},
	"Schedule@ CCineMonster::GetScheduleOfType(int iType)": {
		"prefix": "GetScheduleOfType",
		"body" : [ "GetScheduleOfType( ${1:int iType} )" ],
		"description" : "Gets one of the available schedules of the given type."
	},
	"Schedule@ CCineMonster::GetSchedule()": {
		"prefix": "GetSchedule",
		"body" : [ "GetSchedule()" ],
		"description" : "Gets the current schedule."
	},
	"void CCineMonster::ScheduleChange()": {
		"prefix": "ScheduleChange",
		"body" : [ "ScheduleChange()" ],
		"description" : "Called after the monster's schedule changes."
	},
	"bool CCineMonster::CanPlaySequence(const bool bDisregardState, int iInterruptLevel)": {
		"prefix": "CanPlaySequence",
		"body" : [ "CanPlaySequence( ${1:const bool bDisregardState}, ${2:int iInterruptLevel} )" ],
		"description" : "Returns whether this monster can play its sequence."
	},
	"bool CCineMonster::CanPlaySentence(const bool bDisregardState)": {
		"prefix": "CanPlaySentence",
		"body" : [ "CanPlaySentence( ${1:const bool bDisregardState} )" ],
		"description" : "Returns whether this monster can play its sentence."
	},
	"void CCineMonster::PlaySentence(const string& in szSentence, float duration, float volume, float attenuation)": {
		"prefix": "PlaySentence",
		"body" : [ "PlaySentence( ${1:const string& in szSentence}, ${2:float duration}, ${3:float volume}, ${4:float attenuation} )" ],
		"description" : "Plays the given sentence."
	},
	"void CCineMonster::PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener)": {
		"prefix": "PlayScriptedSentence",
		"body" : [ "PlayScriptedSentence( ${1:const string& in szSentence}, ${2:float duration}, ${3:float volume}, ${4:float attenuation}, ${5:const bool bConcurrent}, ${6:CBaseEntity@ pListener} )" ],
		"description" : "Plays the given scripted sentence."
	},
	"void CCineMonster::SentenceStop()": {
		"prefix": "SentenceStop",
		"body" : [ "SentenceStop()" ],
		"description" : "Stops playing its current sentence."
	},
	"Task@ CCineMonster::GetTask()": {
		"prefix": "GetTask",
		"body" : [ "GetTask()" ],
		"description" : "Gets the current task."
	},
	"MONSTERSTATE CCineMonster::GetIdealState()": {
		"prefix": "GetIdealState",
		"body" : [ "GetIdealState()" ],
		"description" : "Gets the ideal monster state."
	},
	"void CCineMonster::SetActivity(Activity newActivity)": {
		"prefix": "SetActivity",
		"body" : [ "SetActivity( ${1:Activity newActivity} )" ],
		"description" : "Sets the current activity."
	},
	"void CCineMonster::SetGaitActivity(Activity newActivity)": {
		"prefix": "SetGaitActivity",
		"body" : [ "SetGaitActivity( ${1:Activity newActivity} )" ],
		"description" : "Sets the current gait activity."
	},
	"void CCineMonster::SetSequenceByName(const string& in szSequence)": {
		"prefix": "SetSequenceByName",
		"body" : [ "SetSequenceByName( ${1:const string& in szSequence} )" ],
		"description" : "Sets the current sequence by name."
	},
	"void CCineMonster::SetState(MONSTERSTATE state)": {
		"prefix": "SetState",
		"body" : [ "SetState( ${1:MONSTERSTATE state} )" ],
		"description" : "Sets the current monster state."
	},
	"void CCineMonster::ReportAIState()": {
		"prefix": "ReportAIState",
		"body" : [ "ReportAIState()" ],
		"description" : "Reports the AI state."
	},
	"void CCineMonster::CheckAttacks(CBaseEntity@ pTarget, float flDist)": {
		"prefix": "CheckAttacks",
		"body" : [ "CheckAttacks( ${1:CBaseEntity@ pTarget}, ${2:float flDist} )" ],
		"description" : "Check attacks to the given enemy at the given distance."
	},
	"void CCineMonster::CheckAttacks_Move(CBaseEntity@ pTarget, float flDist)": {
		"prefix": "CheckAttacks_Move",
		"body" : [ "CheckAttacks_Move( ${1:CBaseEntity@ pTarget}, ${2:float flDist} )" ],
		"description" : "Check attacks to the given enemy at the given distance while moving."
	},
	"bool CCineMonster::CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos)": {
		"prefix": "CheckAttacksFromPosition",
		"body" : [ "CheckAttacksFromPosition( ${1:CBaseEntity@ pTarget}, ${2:float flDist}, ${3:Vector vecPos} )" ],
		"description" : "Check whether attacks are possible from the given position."
	},
	"bool CCineMonster::CheckEnemy(CBaseEntity@ pEnemy)": {
		"prefix": "CheckEnemy",
		"body" : [ "CheckEnemy( ${1:CBaseEntity@ pEnemy} )" ],
		"description" : "part of the Condition collection process, gets and stores data and conditions pertaining to a monster's enemy. Returns true if Enemy LKP was updated."
	},
	"void CCineMonster::PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos)": {
		"prefix": "PushEnemy",
		"body" : [ "PushEnemy( ${1:CBaseEntity@ pTarget}, ${2:Vector& in vecLastKnownPos} )" ],
		"description" : "Remember the last few enemies, always remember the player."
	},
	"bool CCineMonster::PopEnemy()": {
		"prefix": "PopEnemy",
		"body" : [ "PopEnemy()" ],
		"description" : "Try remembering the last few enemies."
	},
	"bool CCineMonster::FGetNodeRoute(Vector vecDest)": {
		"prefix": "FGetNodeRoute",
		"body" : [ "FGetNodeRoute( ${1:Vector vecDest} )" ],
		"description" : "tries to build an entire node path from. the callers origin to the passed vector. If this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route. true is returned if the operation  succeeds (path is valid) or false if failed (no path  exists )."
	},
	"bool CCineMonster::TestFGetNodeRoute(Vector vecDest)": {
		"prefix": "TestFGetNodeRoute",
		"body" : [ "TestFGetNodeRoute( ${1:Vector vecDest} )" ],
		"description" : "TEST FGetNodeRoute."
	},
	"void CCineMonster::TaskComplete()": {
		"prefix": "TaskComplete",
		"body" : [ "TaskComplete()" ],
		"description" : "Sets the task status to complete."
	},
	"void CCineMonster::MovementComplete()": {
		"prefix": "MovementComplete",
		"body" : [ "MovementComplete()" ],
		"description" : "Called when movement has completed."
	},
	"void CCineMonster::TaskFail()": {
		"prefix": "TaskFail",
		"body" : [ "TaskFail()" ],
		"description" : "Sets the condition bit for a failed task."
	},
	"void CCineMonster::TaskBegin()": {
		"prefix": "TaskBegin",
		"body" : [ "TaskBegin()" ],
		"description" : "Sets the task status to running."
	},
	"bool CCineMonster::TaskIsRunning()": {
		"prefix": "TaskIsRunning",
		"body" : [ "TaskIsRunning()" ],
		"description" : "Returns whether a task is running."
	},
	"bool CCineMonster::TaskIsComplete()": {
		"prefix": "TaskIsComplete",
		"body" : [ "TaskIsComplete()" ],
		"description" : "Returns whether the task is complete."
	},
	"bool CCineMonster::MovementIsComplete()": {
		"prefix": "MovementIsComplete",
		"body" : [ "MovementIsComplete()" ],
		"description" : "Returns whether movement is complete."
	},
	"int CCineMonster::IScheduleFlags()": {
		"prefix": "IScheduleFlags",
		"body" : [ "IScheduleFlags()" ],
		"description" : "Returns an integer with all Conditions. bits that are currently set and also set in the current. schedule's Interrupt mask."
	},
	"void CCineMonster::MakeIdealYaw(Vector vecTarget)": {
		"prefix": "MakeIdealYaw",
		"body" : [ "MakeIdealYaw( ${1:Vector vecTarget} )" ],
		"description" : "gets a yaw value for the caller that would. face the supplied vector. Value is stuffed into the monster's. ideal_yaw."
	},
	"void CCineMonster::SetYawSpeed()": {
		"prefix": "SetYawSpeed",
		"body" : [ "SetYawSpeed()" ],
		"description" : "Allows different yaw_speeds for each activity."
	},
	"int CCineMonster::RouteClassify(int iMoveFlag)": {
		"prefix": "RouteClassify",
		"body" : [ "RouteClassify( ${1:int iMoveFlag} )" ],
		"description" : "Returns the MOVEGOAL for the given move flag."
	},
	"bool CCineMonster::CheckAttacker(CBaseEntity@ pAttacker)": {
		"prefix": "CheckAttacker",
		"body" : [ "CheckAttacker( ${1:CBaseEntity@ pAttacker} )" ],
		"description" : "Determine if we should ignore damage."
	},
	"void CCineMonster::SetConditions(int iConditions)": {
		"prefix": "SetConditions",
		"body" : [ "SetConditions( ${1:int iConditions} )" ],
		"description" : "Sets AI conditions."
	},
	"void CCineMonster::ClearConditions(int iConditions)": {
		"prefix": "ClearConditions",
		"body" : [ "ClearConditions( ${1:int iConditions} )" ],
		"description" : "Clears AI conditions."
	},
	"bool CCineMonster::HasConditions(int iConditions) const": {
		"prefix": "HasConditions",
		"body" : [ "HasConditions( ${1:int iConditions} )" ],
		"description" : "Returns whether this monster has any of the given AI conditions."
	},
	"bool CCineMonster::HasAllConditions(int iConditions) const": {
		"prefix": "HasAllConditions",
		"body" : [ "HasAllConditions( ${1:int iConditions} )" ],
		"description" : "Returns whether this monster has all of the given AI conditions."
	},
	"CSound@ CCineMonster::PBestSound()": {
		"prefix": "PBestSound",
		"body" : [ "PBestSound()" ],
		"description" : "Returns a pointer to the sound the monster should react to."
	},
	"bool CCineMonster::FShouldEat()": {
		"prefix": "FShouldEat",
		"body" : [ "FShouldEat()" ],
		"description" : "Returns whether this monster should eat."
	},
	"void CCineMonster::Eat(float flFullDuration)": {
		"prefix": "Eat",
		"body" : [ "Eat( ${1:float flFullDuration} )" ],
		"description" : "Make the monster 'full' for a while."
	},
	"bool CCineMonster::FCheckAITrigger()": {
		"prefix": "FCheckAITrigger",
		"body" : [ "FCheckAITrigger()" ],
		"description" : "Checks and, if necessary, fires the monster's trigger target."
	},
	"bool CCineMonster::NoFriendlyFire()": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire()" ],
		"description" : "Returns whether attacking at this time would result in friendly fire"
	},
	"bool CCineMonster::NoFriendlyFire(Vector vecPos)": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire( ${1:Vector vecPos} )" ],
		"description" : "Returns whether attacking at this time from the given location would result in friendly fire"
	},
	"bool CCineMonster::NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget)": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire( ${1:Vector vecPos}, ${2:CBaseEntity@ pTarget} )" ],
		"description" : "Returns whether attacking the given target at this time from the given location would result in friendly fire"
	},
	"bool CCineMonster::NoFriendlyFireToPos(Vector vecPos)": {
		"prefix": "NoFriendlyFireToPos",
		"body" : [ "NoFriendlyFireToPos( ${1:Vector vecPos} )" ],
		"description" : "Returns whether attacking the target location at this time would result in friendly fire"
	},
	"bool CCineMonster::GetEnemy()": {
		"prefix": "GetEnemy",
		"body" : [ "GetEnemy()" ],
		"description" : "Tries to find the best suitable enemy for this monster."
	},
	"void CCineMonster::GibMonster()": {
		"prefix": "GibMonster",
		"body" : [ "GibMonster()" ],
		"description" : "Gibs the monster."
	},
	"bool CCineMonster::ShouldGibMonster(int iGib)": {
		"prefix": "ShouldGibMonster",
		"body" : [ "ShouldGibMonster( ${1:int iGib} )" ],
		"description" : "Returns whether the monster should be gibbed given the gib type. See GIB enum."
	},
	"void CCineMonster::CallGibMonster()": {
		"prefix": "CallGibMonster",
		"body" : [ "CallGibMonster()" ],
		"description" : "Determines whether to gib or fade this monster, and acts accordingly."
	},
	"bool CCineMonster::HasHumanGibs()": {
		"prefix": "HasHumanGibs",
		"body" : [ "HasHumanGibs()" ],
		"description" : "Returns whether this monster has human gibs."
	},
	"bool CCineMonster::HasAlienGibs()": {
		"prefix": "HasAlienGibs",
		"body" : [ "HasAlienGibs()" ],
		"description" : "Returns whether this monster has alien gibs."
	},
	"void CCineMonster::FadeMonster()": {
		"prefix": "FadeMonster",
		"body" : [ "FadeMonster()" ],
		"description" : "Fades this monster. Note: does not kill the monster."
	},
	"Vector CCineMonster::ShootAtEnemy(const Vector& in vecShootOrigin)": {
		"prefix": "ShootAtEnemy",
		"body" : [ "ShootAtEnemy( ${1:const Vector& in vecShootOrigin} )" ],
		"description" : "Shoots at the specified location."
	},
	"void CCineMonster::DeathSound()": {
		"prefix": "DeathSound",
		"body" : [ "DeathSound()" ],
		"description" : "Plays this monster's death sound."
	},
	"void CCineMonster::AlertSound()": {
		"prefix": "AlertSound",
		"body" : [ "AlertSound()" ],
		"description" : "Plays this monster's alert sound."
	},
	"void CCineMonster::IdleSound()": {
		"prefix": "IdleSound",
		"body" : [ "IdleSound()" ],
		"description" : "Plays this monster's idle sound."
	},
	"void CCineMonster::PainSound()": {
		"prefix": "PainSound",
		"body" : [ "PainSound()" ],
		"description" : "Plays this monster's pain sound."
	},
	"void CCineMonster::StartPlayerFollowing(CBaseEntity@ pLeader, bool bSilent = false)": {
		"prefix": "StartPlayerFollowing",
		"body" : [ "StartPlayerFollowing( ${1:CBaseEntity@ pLeader}, ${2:bool bSilent = false} )" ],
		"description" : "Starts following its target."
	},
	"void CCineMonster::StopPlayerFollowing(const bool clearSchedule, bool bSilent = false)": {
		"prefix": "StopPlayerFollowing",
		"body" : [ "StopPlayerFollowing( ${1:const bool clearSchedule}, ${2:bool bSilent = false} )" ],
		"description" : "Stops following its target."
	},
	"void CCineMonster::Remember(int iMemory)": {
		"prefix": "Remember",
		"body" : [ "Remember( ${1:int iMemory} )" ],
		"description" : "Makes this monster remember the given memories."
	},
	"void CCineMonster::Forget(int iMemory)": {
		"prefix": "Forget",
		"body" : [ "Forget( ${1:int iMemory} )" ],
		"description" : "Makes this monster forget the given memories."
	},
	"bool CCineMonster::HasMemory(int iMemory) const": {
		"prefix": "HasMemory",
		"body" : [ "HasMemory( ${1:int iMemory} )" ],
		"description" : "Returns whether this monster remembers any of the given memories."
	},
	"bool CCineMonster::HasAllMemories(int iMemory) const": {
		"prefix": "HasAllMemories",
		"body" : [ "HasAllMemories( ${1:int iMemory} )" ],
		"description" : "Returns whether this monster remembers all of the given memories."
	},
	"bool CCineMonster::ExitScriptedSequence()": {
		"prefix": "ExitScriptedSequence",
		"body" : [ "ExitScriptedSequence()" ],
		"description" : "Exits the scripted sequence this monster is currently in, if any."
	},
	"bool CCineMonster::CineCleanup()": {
		"prefix": "CineCleanup",
		"body" : [ "CineCleanup()" ],
		"description" : "Cleans up after a cinematic event."
	},
	"CBaseEntity@ CCineMonster::DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng)": {
		"prefix": "DropItem",
		"body" : [ "DropItem( ${1:const string& in szItemName}, ${2:const Vector& in vecPos}, ${3:const Vector& in vecAng} )" ],
		"description" : "Drops the given item from the given position at the given angle."
	},
	"void CCineMonster::ShockGlowEffect(bool fMode)": {
		"prefix": "ShockGlowEffect",
		"body" : [ "ShockGlowEffect( ${1:bool fMode} )" ],
		"description" : "Turns the shock glow effect on or off."
	},
	"void CCineMonster::FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)": {
		"prefix": "FollowerPlayerUse",
		"body" : [ "FollowerPlayerUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue} )" ],
		"description" : "Use method for following players (set only if friendly)"
	},
	"bool CCineMonster::IsPlayerFollowing()": {
		"prefix": "IsPlayerFollowing",
		"body" : [ "IsPlayerFollowing()" ],
		"description" : "Returns whether this monster is following a player."
	},
	"bool CCineMonster::CanPlayerFollow()": {
		"prefix": "CanPlayerFollow",
		"body" : [ "CanPlayerFollow()" ],
		"description" : "Returns whether this monster can follow a player."
	},
	"void CCineMonster::StartPlayerFollowing(CBaseEntity@ pLeader)": {
		"prefix": "StartPlayerFollowing",
		"body" : [ "StartPlayerFollowing( ${1:CBaseEntity@ pLeader} )" ],
		"description" : "Starts following a given player."
	},
	"void CCineMonster::StopPlayerFollowing(const bool bClearSchedule)": {
		"prefix": "StopPlayerFollowing",
		"body" : [ "StopPlayerFollowing( ${1:const bool bClearSchedule} )" ],
		"description" : "Stops following a player."
	},
	"string CCineMonster::m_szTextureName()": {
		"prefix": "m_szTextureName",
		"body" : [ "m_szTextureName()" ],
		"description" : "Current texture name we're standing on."
	},
	"void CCineMonster::MedicCallSound(float flDistance = 0.0f)": {
		"prefix": "MedicCallSound",
		"body" : [ "MedicCallSound( ${1:float flDistance = 0.0f} )" ],
		"description" : "Medic call sound."
	},
	"InventoryList@ CCineMonster::get_m_pInventory() const": {
		"prefix": "get_m_pInventory",
		"body" : [ "get_m_pInventory()" ],
		"description" : "The inventory items this monster has"
	},
	"void CCineMonster::ClearEnemyList()": {
		"prefix": "ClearEnemyList",
		"body" : [ "ClearEnemyList()" ],
		"description" : "Clears this monster's list of enemies"
	},
	"void CCineMonster::ApplyEffects()": {
		"prefix": "ApplyEffects",
		"body" : [ "ApplyEffects()" ],
		"description" : "Re-calculate compounded effect modifiers and apply to the monster"
	},
	"void CCineMonster::ResetEffects()": {
		"prefix": "ResetEffects",
		"body" : [ "ResetEffects()" ],
		"description" : "Reset all effect modifiers"
	},
	"void CCineMonster::DelayStart(int iState)": {
		"prefix": "DelayStart",
		"body" : [ "DelayStart( ${1:int iState} )" ],
		"description" : "Find all the cinematic entities with my targetname and tell them to wait before starting."
	},
	"void CCineMonster::PossessEntity()": {
		"prefix": "PossessEntity",
		"body" : [ "PossessEntity()" ],
		"description" : "Make the entity enter a scripted sequence."
	},
	"void CCineMonster::CancelScript()": {
		"prefix": "CancelScript",
		"body" : [ "CancelScript()" ],
		"description" : "Find all the cinematic entities with my targetname and stop them from playing."
	},
	"bool CCineMonster::StartSequence(CBaseMonster@ pTarget, const string& in szSequence, const bool fCompleteOnEmpty)": {
		"prefix": "StartSequence",
		"body" : [ "StartSequence( ${1:CBaseMonster@ pTarget}, ${2:const string& in szSequence}, ${3:const bool fCompleteOnEmpty} )" ],
		"description" : "Make the entity enter a scripted sequence."
	},
	"bool CCineMonster::FCanOverrideState() const": {
		"prefix": "FCanOverrideState",
		"body" : [ "FCanOverrideState()" ],
		"description" : "If this returns false, scripted sequences cannot possess entities regardless of state."
	},
	"bool CCineMonster::CanInterrupt()": {
		"prefix": "CanInterrupt",
		"body" : [ "CanInterrupt()" ],
		"description" : "Returns whether this script can be interrupted."
	},
	"int CCineMonster::IgnoreConditions()": {
		"prefix": "IgnoreConditions",
		"body" : [ "IgnoreConditions()" ],
		"description" : "Gets the ignore conditions."
	},
	"entvars_t@ CCineMonster::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CCineMonster::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CCineMonster::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CCineMonster::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CCineMonster::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CCineMonster::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CCineMonster::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CCineMonster::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CCineMonster::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CCineMonster::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CCineMonster::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CCineMonster::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CCineMonster::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CCineMonster::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CCineMonster::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CCineMonster::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CCineMonster::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CCineMonster::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CCineMonster::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CCineMonster::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CCineMonster::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CCineMonster::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CCineMonster::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CCineMonster::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"TOGGLE_STATE CCineMonster::m_toggle_state": {
		"prefix": "m_toggle_state",
		"body" : [ "m_toggle_state" ],
		"description" : "Current toggle state."
	},
	"float CCineMonster::m_flMoveDistance": {
		"prefix": "m_flMoveDistance",
		"body" : [ "m_flMoveDistance" ],
		"description" : "How far a door should slide or rotate."
	},
	"float CCineMonster::m_flWait": {
		"prefix": "m_flWait",
		"body" : [ "m_flWait" ],
		"description" : "How long to wait before resetting."
	},
	"float CCineMonster::m_flLip": {
		"prefix": "m_flLip",
		"body" : [ "m_flLip" ],
		"description" : "How much to stick out of a wall. Will recede further into walls if negative."
	},
	"float CCineMonster::m_flTWidth": {
		"prefix": "m_flTWidth",
		"body" : [ "m_flTWidth" ],
		"description" : "For plats."
	},
	"float CCineMonster::m_flTLength": {
		"prefix": "m_flTLength",
		"body" : [ "m_flTLength" ],
		"description" : "For plats."
	},
	"int CCineMonster::m_cTriggersLeft": {
		"prefix": "m_cTriggersLeft",
		"body" : [ "m_cTriggersLeft" ],
		"description" : "Trigger_counter only: # of activations remaining."
	},
	"float CCineMonster::m_flHeight": {
		"prefix": "m_flHeight",
		"body" : [ "m_flHeight" ],
		"description" : "Height."
	},
	"EHandle CCineMonster::m_hActivator": {
		"prefix": "m_hActivator",
		"body" : [ "m_hActivator" ],
		"description" : "Handle to the activator."
	},
	"Vector CCineMonster::m_vecPosition1": {
		"prefix": "m_vecPosition1",
		"body" : [ "m_vecPosition1" ],
		"description" : "Closed position."
	},
	"Vector CCineMonster::m_vecPosition2": {
		"prefix": "m_vecPosition2",
		"body" : [ "m_vecPosition2" ],
		"description" : "Open position."
	},
	"Vector CCineMonster::m_vecAngle1": {
		"prefix": "m_vecAngle1",
		"body" : [ "m_vecAngle1" ],
		"description" : "Closed angle."
	},
	"Vector CCineMonster::m_vecAngle2": {
		"prefix": "m_vecAngle2",
		"body" : [ "m_vecAngle2" ],
		"description" : "Open angle."
	},
	"Vector CCineMonster::m_vecFinalDest": {
		"prefix": "m_vecFinalDest",
		"body" : [ "m_vecFinalDest" ],
		"description" : "Final destination."
	},
	"Vector CCineMonster::m_vecFinalAngle": {
		"prefix": "m_vecFinalAngle",
		"body" : [ "m_vecFinalAngle" ],
		"description" : "Final angle."
	},
	"int CCineMonster::m_bitsDamageInflict": {
		"prefix": "m_bitsDamageInflict",
		"body" : [ "m_bitsDamageInflict" ],
		"description" : "DMG_ damage type that the door or trigger does."
	},
	"string_t CCineMonster::m_sMaster": {
		"prefix": "m_sMaster",
		"body" : [ "m_sMaster" ],
		"description" : "This entity's master, if any."
	},
	"EHandle CCineMonster::m_hEnemy": {
		"prefix": "m_hEnemy",
		"body" : [ "m_hEnemy" ],
		"description" : "the entity that the monster is fighting."
	},
	"EHandle CCineMonster::m_hTargetEnt": {
		"prefix": "m_hTargetEnt",
		"body" : [ "m_hTargetEnt" ],
		"description" : "the entity that the monster is trying to reach."
	},
	"EHandle CCineMonster::m_hTargetTank": {
		"prefix": "m_hTargetTank",
		"body" : [ "m_hTargetTank" ],
		"description" : "Target tank to control."
	},
	"float CCineMonster::m_flFieldOfView": {
		"prefix": "m_flFieldOfView",
		"body" : [ "m_flFieldOfView" ],
		"description" : "width of monster's field of view (dot product)."
	},
	"float CCineMonster::m_flWaitFinished": {
		"prefix": "m_flWaitFinished",
		"body" : [ "m_flWaitFinished" ],
		"description" : "if we're told to wait, this is the time that the wait will be over."
	},
	"float CCineMonster::m_flMoveWaitFinished": {
		"prefix": "m_flMoveWaitFinished",
		"body" : [ "m_flMoveWaitFinished" ],
		"description" : "if we're told to wait before moving, this is the time that the wait will be over."
	},
	"Activity CCineMonster::m_Activity": {
		"prefix": "m_Activity",
		"body" : [ "m_Activity" ],
		"description" : "what the monster is doing (animation)."
	},
	"Activity CCineMonster::m_IdealActivity": {
		"prefix": "m_IdealActivity",
		"body" : [ "m_IdealActivity" ],
		"description" : "monster should switch to this activity."
	},
	"Activity CCineMonster::m_GaitActivity": {
		"prefix": "m_GaitActivity",
		"body" : [ "m_GaitActivity" ],
		"description" : "gaitsequence."
	},
	"int CCineMonster::m_LastHitGroup": {
		"prefix": "m_LastHitGroup",
		"body" : [ "m_LastHitGroup" ],
		"description" : "the last body region that took damage."
	},
	"MONSTERSTATE CCineMonster::m_MonsterState": {
		"prefix": "m_MonsterState",
		"body" : [ "m_MonsterState" ],
		"description" : "monster's current state."
	},
	"MONSTERSTATE CCineMonster::m_IdealMonsterState": {
		"prefix": "m_IdealMonsterState",
		"body" : [ "m_IdealMonsterState" ],
		"description" : "monster should change to this state."
	},
	"int CCineMonster::m_iTaskStatus": {
		"prefix": "m_iTaskStatus",
		"body" : [ "m_iTaskStatus" ],
		"description" : "Task status."
	},
	"Schedule@ CCineMonster::m_pSchedule": {
		"prefix": "m_pSchedule",
		"body" : [ "m_pSchedule" ],
		"description" : "Current schedule."
	},
	"Schedule@ CCineMonster::m_pScheduleSaved": {
		"prefix": "m_pScheduleSaved",
		"body" : [ "m_pScheduleSaved" ],
		"description" : "For land_on_ground schedules (remember last schedule and continue)."
	},
	"int CCineMonster::m_iScheduleIndex": {
		"prefix": "m_iScheduleIndex",
		"body" : [ "m_iScheduleIndex" ],
		"description" : "Schedule index."
	},
	"int CCineMonster::m_movementGoal": {
		"prefix": "m_movementGoal",
		"body" : [ "m_movementGoal" ],
		"description" : "Goal that defines route."
	},
	"int CCineMonster::m_iRouteIndex": {
		"prefix": "m_iRouteIndex",
		"body" : [ "m_iRouteIndex" ],
		"description" : "Index into m_Route[]."
	},
	"float CCineMonster::m_moveWaitTime": {
		"prefix": "m_moveWaitTime",
		"body" : [ "m_moveWaitTime" ],
		"description" : "How long I should wait for something to move."
	},
	"float CCineMonster::m_moveradius": {
		"prefix": "m_moveradius",
		"body" : [ "m_moveradius" ],
		"description" : "Minimum radius."
	},
	"Vector CCineMonster::m_vecMoveGoal": {
		"prefix": "m_vecMoveGoal",
		"body" : [ "m_vecMoveGoal" ],
		"description" : "Kept around for node graph moves, so we know our ultimate goal."
	},
	"Activity CCineMonster::m_movementActivity": {
		"prefix": "m_movementActivity",
		"body" : [ "m_movementActivity" ],
		"description" : "When moving, set this activity."
	},
	"int CCineMonster::m_iAudibleList": {
		"prefix": "m_iAudibleList",
		"body" : [ "m_iAudibleList" ],
		"description" : "first index of a linked list of sounds that the monster can hear."
	},
	"int CCineMonster::m_afSoundTypes": {
		"prefix": "m_afSoundTypes",
		"body" : [ "m_afSoundTypes" ],
		"description" : "Sound types that can be heard."
	},
	"Vector CCineMonster::m_vecLastPosition": {
		"prefix": "m_vecLastPosition",
		"body" : [ "m_vecLastPosition" ],
		"description" : "monster sometimes wants to return to where it started after an operation.."
	},
	"int CCineMonster::m_iHintNode": {
		"prefix": "m_iHintNode",
		"body" : [ "m_iHintNode" ],
		"description" : "this is the hint node that the monster is moving towards or performing active idle on.."
	},
	"int CCineMonster::m_afMemory": {
		"prefix": "m_afMemory",
		"body" : [ "m_afMemory" ],
		"description" : "Monster memory."
	},
	"int CCineMonster::m_bloodColor": {
		"prefix": "m_bloodColor",
		"body" : [ "m_bloodColor" ],
		"description" : "color of blood particles."
	},
	"int CCineMonster::m_iMaxHealth": {
		"prefix": "m_iMaxHealth",
		"body" : [ "m_iMaxHealth" ],
		"description" : "keeps track of monster's maximum health value (for re-healing, etc)."
	},
	"Vector CCineMonster::m_vecEnemyLKP": {
		"prefix": "m_vecEnemyLKP",
		"body" : [ "m_vecEnemyLKP" ],
		"description" : "last known position of enemy. (enemy's origin)."
	},
	"int CCineMonster::m_cAmmoLoaded": {
		"prefix": "m_cAmmoLoaded",
		"body" : [ "m_cAmmoLoaded" ],
		"description" : "how much ammo is in the weapon (used to trigger reload anim sequences)."
	},
	"int CCineMonster::m_afCapability": {
		"prefix": "m_afCapability",
		"body" : [ "m_afCapability" ],
		"description" : "tells us what a monster can/can't do."
	},
	"int CCineMonster::m_afMoveShootCap": {
		"prefix": "m_afMoveShootCap",
		"body" : [ "m_afMoveShootCap" ],
		"description" : "tells us what a monster can/can't do, while moving."
	},
	"float CCineMonster::m_flNextAttack": {
		"prefix": "m_flNextAttack",
		"body" : [ "m_flNextAttack" ],
		"description" : "cannot attack again until this time."
	},
	"int CCineMonster::m_bitsDamageType": {
		"prefix": "m_bitsDamageType",
		"body" : [ "m_bitsDamageType" ],
		"description" : "what types of damage has monster (player) taken."
	},
	"float CCineMonster::m_lastDamageAmount": {
		"prefix": "m_lastDamageAmount",
		"body" : [ "m_lastDamageAmount" ],
		"description" : "how much damage did monster (player) last take."
	},
	"float CCineMonster::m_tbdPrev": {
		"prefix": "m_tbdPrev",
		"body" : [ "m_tbdPrev" ],
		"description" : "Time-based damage timer."
	},
	"entvars_t@ CCineMonster::pevTimeBasedInflictor": {
		"prefix": "pevTimeBasedInflictor",
		"body" : [ "pevTimeBasedInflictor" ],
		"description" : "Time based damage inflictor."
	},
	"int CCineMonster::m_failSchedule": {
		"prefix": "m_failSchedule",
		"body" : [ "m_failSchedule" ],
		"description" : "Schedule type to choose if current schedule fails."
	},
	"float CCineMonster::m_flHungryTime": {
		"prefix": "m_flHungryTime",
		"body" : [ "m_flHungryTime" ],
		"description" : "Time based damage inflictor."
	},
	"float CCineMonster::m_flDistTooFar": {
		"prefix": "m_flDistTooFar",
		"body" : [ "m_flDistTooFar" ],
		"description" : "if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy."
	},
	"float CCineMonster::m_flDistLook": {
		"prefix": "m_flDistLook",
		"body" : [ "m_flDistLook" ],
		"description" : "distance monster sees (Default 2048)."
	},
	"int CCineMonster::m_iTriggerCondition": {
		"prefix": "m_iTriggerCondition",
		"body" : [ "m_iTriggerCondition" ],
		"description" : "for scripted AI, this is the condition that will cause the activation of the monster's TriggerTarget."
	},
	"string_t CCineMonster::m_iszTriggerTarget": {
		"prefix": "m_iszTriggerTarget",
		"body" : [ "m_iszTriggerTarget" ],
		"description" : "Name of target that should be fired."
	},
	"Vector CCineMonster::m_HackedGunPos": {
		"prefix": "m_HackedGunPos",
		"body" : [ "m_HackedGunPos" ],
		"description" : "HACK until we can query end of gun."
	},
	"SCRIPTSTATE CCineMonster::m_scriptState": {
		"prefix": "m_scriptState",
		"body" : [ "m_scriptState" ],
		"description" : "internal cinematic state."
	},
	"EHandle CCineMonster::m_hCine": {
		"prefix": "m_hCine",
		"body" : [ "m_hCine" ],
		"description" : "Cinematic entity."
	},
	"EHandle CCineMonster::m_hCineBlocker": {
		"prefix": "m_hCineBlocker",
		"body" : [ "m_hCineBlocker" ],
		"description" : "Entity that is blocking cinematic execution."
	},
	"float CCineMonster::m_useTime": {
		"prefix": "m_useTime",
		"body" : [ "m_useTime" ],
		"description" : "Don't allow +USE until this time."
	},
	"string_t CCineMonster::m_FormattedName": {
		"prefix": "m_FormattedName",
		"body" : [ "m_FormattedName" ],
		"description" : "The formatted name. For better name outputs. E.g. \"Alien Slave\" rather than \"alien_slave\"."
	},
	"int8 CCineMonster::m_chTextureType": {
		"prefix": "m_chTextureType",
		"body" : [ "m_chTextureType" ],
		"description" : "Current texture type. See TextureType enum."
	},
	"bool CCineMonster::m_fCanFearCreatures": {
		"prefix": "m_fCanFearCreatures",
		"body" : [ "m_fCanFearCreatures" ],
		"description" : "Whether this monster can fear creatures."
	},
	"float CCineMonster::m_flAutomaticAttackTime": {
		"prefix": "m_flAutomaticAttackTime",
		"body" : [ "m_flAutomaticAttackTime" ],
		"description" : "How long an npc will attempt to fire full auto."
	},
	"float CCineMonster::m_flFallVelocity": {
		"prefix": "m_flFallVelocity",
		"body" : [ "m_flFallVelocity" ],
		"description" : "Current fall speed."
	},
	"EHandle CCineMonster::m_hGuardEnt": {
		"prefix": "m_hGuardEnt",
		"body" : [ "m_hGuardEnt" ],
		"description" : "Monster will guard this entity and turn down follow requests."
	},
	"string_t CCineMonster::m_iszGuardEntName": {
		"prefix": "m_iszGuardEntName",
		"body" : [ "m_iszGuardEntName" ],
		"description" : "Guard entity name."
	},
	"Vector CCineMonster::m_vecEffectGlowColor": {
		"prefix": "m_vecEffectGlowColor",
		"body" : [ "m_vecEffectGlowColor" ],
		"description" : "Glow shell."
	},
	"int CCineMonster::m_iEffectBlockWeapons": {
		"prefix": "m_iEffectBlockWeapons",
		"body" : [ "m_iEffectBlockWeapons" ],
		"description" : "Monster can't use weapons."
	},
	"int CCineMonster::m_iEffectInvulnerable": {
		"prefix": "m_iEffectInvulnerable",
		"body" : [ "m_iEffectInvulnerable" ],
		"description" : "is invulnerable (god mode)"
	},
	"int CCineMonster::m_iEffectInvisible": {
		"prefix": "m_iEffectInvisible",
		"body" : [ "m_iEffectInvisible" ],
		"description" : "is invisible (render + non-targetable)"
	},
	"int CCineMonster::m_iEffectNonSolid": {
		"prefix": "m_iEffectNonSolid",
		"body" : [ "m_iEffectNonSolid" ],
		"description" : "is non-solid"
	},
	"float CCineMonster::m_flEffectRespiration": {
		"prefix": "m_flEffectRespiration",
		"body" : [ "m_flEffectRespiration" ],
		"description" : "Extra/less breathing time underwater in seconds"
	},
	"float CCineMonster::m_flEffectGravity": {
		"prefix": "m_flEffectGravity",
		"body" : [ "m_flEffectGravity" ],
		"description" : "Gravity modifier (%)"
	},
	"float CCineMonster::m_flEffectFriction": {
		"prefix": "m_flEffectFriction",
		"body" : [ "m_flEffectFriction" ],
		"description" : "Movement friction modifier (%)"
	},
	"float CCineMonster::m_flEffectSpeed": {
		"prefix": "m_flEffectSpeed",
		"body" : [ "m_flEffectSpeed" ],
		"description" : "Movement speed modifier (%)"
	},
	"float CCineMonster::m_flEffectDamage": {
		"prefix": "m_flEffectDamage",
		"body" : [ "m_flEffectDamage" ],
		"description" : "Damage modifier (%)"
	},
	"string_t CCineMonster::m_iszIdle": {
		"prefix": "m_iszIdle",
		"body" : [ "m_iszIdle" ],
		"description" : "Te idle animation name."
	},
	"string_t CCineMonster::m_iszPlay": {
		"prefix": "m_iszPlay",
		"body" : [ "m_iszPlay" ],
		"description" : "The play animation name."
	},
	"string_t CCineMonster::m_iszEntity": {
		"prefix": "m_iszEntity",
		"body" : [ "m_iszEntity" ],
		"description" : "The target entity name."
	},
	"float CCineMonster::m_flRadius": {
		"prefix": "m_flRadius",
		"body" : [ "m_flRadius" ],
		"description" : "The radius to search in."
	},
	"float CCineMonster::m_flRepeat": {
		"prefix": "m_flRepeat",
		"body" : [ "m_flRepeat" ],
		"description" : "How much time has to pass before the scripted sequence can repeat."
	},
	"int CCineMonster::m_iDelay": {
		"prefix": "m_iDelay",
		"body" : [ "m_iDelay" ],
		"description" : "Delay before execution."
	},
	"float CCineMonster::m_startTime": {
		"prefix": "m_startTime",
		"body" : [ "m_startTime" ],
		"description" : "When to start the script."
	},
	"bool CCineMonster::m_interruptable": {
		"prefix": "m_interruptable",
		"body" : [ "m_interruptable" ],
		"description" : "Whether this scripted sequence can be interrupted."
	},
	"float CCineMonster::m_flMoveToRadius": {
		"prefix": "m_flMoveToRadius",
		"body" : [ "m_flMoveToRadius" ],
		"description" : "When in radius, script is done."
	},
	"bool CClassicMode::IsStateDefined() const": {
		"prefix": "IsStateDefined",
		"body" : [ "IsStateDefined()" ],
		"description" : "Returns whether the Classic Mode state setting is defined. If not defined, no voting has taken place to choose whether or not to enable Classic Mode."
	},
	"void CClassicMode::ResetState()": {
		"prefix": "ResetState",
		"body" : [ "ResetState()" ],
		"description" : "Resets the Classic Mode state setting to undefined."
	},
	"bool CClassicMode::IsEnabled() const": {
		"prefix": "IsEnabled",
		"body" : [ "IsEnabled()" ],
		"description" : "Returns whether Classic Mode is enabled or not."
	},
	"void CClassicMode::SetEnabled(const bool fEnabled)": {
		"prefix": "SetEnabled",
		"body" : [ "SetEnabled( ${1:const bool fEnabled} )" ],
		"description" : "Enable or disable Classic Mode."
	},
	"void CClassicMode::ForceItemRemap(const bool fEnabled)": {
		"prefix": "ForceItemRemap",
		"body" : [ "ForceItemRemap( ${1:const bool fEnabled} )" ],
		"description" : "Forces item remapping even if classic mode is disabled."
	},
	"void CClassicMode::Toggle()": {
		"prefix": "Toggle",
		"body" : [ "Toggle()" ],
		"description" : "Toggles Classic Mode."
	},
	"void CClassicMode::EnableMapSupport()": {
		"prefix": "EnableMapSupport",
		"body" : [ "EnableMapSupport()" ],
		"description" : "Tells the game that the current map wants to use Classic Mode. Must be called in MapInit. Cannot be disabled once set.This will ask players whether they want to enable Classic Mode. Reset on map change."
	},
	"bool CClassicMode::ShouldRestartOnChange() const": {
		"prefix": "ShouldRestartOnChange",
		"body" : [ "ShouldRestartOnChange()" ],
		"description" : "Returns whether the map should restart if Classic Mode is changed or not. Defaults to true if not changed by a script. Reset on map change."
	},
	"void CClassicMode::SetShouldRestartOnChange(const bool bShouldRestart)": {
		"prefix": "SetShouldRestartOnChange",
		"body" : [ "SetShouldRestartOnChange( ${1:const bool bShouldRestart} )" ],
		"description" : "Sets whether the map should restart if Classic Mode is changed."
	},
	"void CClassicMode::SetItemMappings(array<ItemMapping@>@ pItemMappings)": {
		"prefix": "SetItemMappings",
		"body" : [ "SetItemMappings( ${1:array<ItemMapping@>@ pItemMappings} )" ],
		"description" : "Sets the item mappings to use from now on. Does not affect previous mappings. Pass null to disable all mappings."
	},
	"const string& CClassicMode::FindItemMapping(const string& in szItemName) const": {
		"prefix": "FindItemMapping",
		"body" : [ "FindItemMapping( ${1:const string& in szItemName} )" ],
		"description" : "Gets the item mapped to the given item name, or an empty string if no mapping exists."
	},
	"const string& CClientCommand::GetName() const": {
		"prefix": "GetName",
		"body" : [ "GetName()" ],
		"description" : "Gets the name of this command."
	},
	"const string& CClientCommand::GetFullyQualifiedName() const": {
		"prefix": "GetFullyQualifiedName",
		"body" : [ "GetFullyQualifiedName()" ],
		"description" : "Gets the fully qualified name of this command. This is the name that the command is referred by when called."
	},
	"const string& CClientCommand::GetHelpInfo() const": {
		"prefix": "GetHelpInfo",
		"body" : [ "GetHelpInfo()" ],
		"description" : "Gets the help info describing this command."
	},
	"ConCommandKind::Type CClientCommand::GetKind() const": {
		"prefix": "GetKind",
		"body" : [ "GetKind()" ],
		"description" : "Gets the type of this console command."
	},
	"const string& CClientCommand::GetOwningModuleName() const": {
		"prefix": "GetOwningModuleName",
		"body" : [ "GetOwningModuleName()" ],
		"description" : "Gets the name of the module that owns (created) this command."
	},
	"bool CClientCommand::HasBeenAdded() const": {
		"prefix": "HasBeenAdded",
		"body" : [ "HasBeenAdded()" ],
		"description" : "Whether this command was added to the list of commands. Must be added to be usable from the console."
	},
	"CClientCommand@ CClientCommand::CClientCommand(const string& in szName, const string& in szHelpInfo, ClientCommandCallback@ pCallback, const ConCommandFlags_t flags = ConCommandFlag::None)": {
		"prefix": "CClientCommand",
		"body" : [ "CClientCommand( ${1:const string& in szName}, ${2:const string& in szHelpInfo}, ${3:ClientCommandCallback@ pCallback}, ${4:const ConCommandFlags_t flags = ConCommandFlag::None} )" ],
		"description" : "Constructor"
	},
	"int CCommand::ArgC() const": {
		"prefix": "ArgC",
		"body" : [ "ArgC()" ],
		"description" : "Gets the number of arguments."
	},
	"string CCommand::GetCommandString() const": {
		"prefix": "GetCommandString",
		"body" : [ "GetCommandString()" ],
		"description" : "Gets the entire command as a string."
	},
	"string CCommand::GetArgumentsString() const": {
		"prefix": "GetArgumentsString",
		"body" : [ "GetArgumentsString()" ],
		"description" : "Gets all arguments as a single string."
	},
	"string CCommand::Arg(const int iIndex) const": {
		"prefix": "Arg",
		"body" : [ "Arg( ${1:const int iIndex} )" ],
		"description" : "Gets the argument by index."
	},
	"string CCommand::opIndex(const int iIndex) const": {
		"prefix": "opIndex",
		"body" : [ "opIndex( ${1:const int iIndex} )" ],
		"description" : "Gets the argument by index."
	},
	"string CCommand::FindArg(const string& in szArgument) const": {
		"prefix": "FindArg",
		"body" : [ "FindArg( ${1:const string& in szArgument} )" ],
		"description" : "Find a value for a given argument. If the argument does not exist or has no value, an empty string is returned. Otherwise, returns the value."
	},
	"int CCommand::FindIntArg(const string& in szArgument, const int iDefault = 0) const": {
		"prefix": "FindIntArg",
		"body" : [ "FindIntArg( ${1:const string& in szArgument}, ${2:const int iDefault = 0} )" ],
		"description" : "Find an int value for a given argument. Returns iDefault if no such argument exists, or no value exists for it. Otherwise, returns the value, converted to an int"
	},
	"const string& CConCommand::GetName() const": {
		"prefix": "GetName",
		"body" : [ "GetName()" ],
		"description" : "Gets the name of this command."
	},
	"const string& CConCommand::GetFullyQualifiedName() const": {
		"prefix": "GetFullyQualifiedName",
		"body" : [ "GetFullyQualifiedName()" ],
		"description" : "Gets the fully qualified name of this command. This is the name that the command is referred by when called."
	},
	"const string& CConCommand::GetHelpInfo() const": {
		"prefix": "GetHelpInfo",
		"body" : [ "GetHelpInfo()" ],
		"description" : "Gets the help info describing this command."
	},
	"ConCommandKind::Type CConCommand::GetKind() const": {
		"prefix": "GetKind",
		"body" : [ "GetKind()" ],
		"description" : "Gets the type of this console command."
	},
	"const string& CConCommand::GetOwningModuleName() const": {
		"prefix": "GetOwningModuleName",
		"body" : [ "GetOwningModuleName()" ],
		"description" : "Gets the name of the module that owns (created) this command."
	},
	"bool CConCommand::HasBeenAdded() const": {
		"prefix": "HasBeenAdded",
		"body" : [ "HasBeenAdded()" ],
		"description" : "Whether this command was added to the list of commands. Must be added to be usable from the console."
	},
	"CConCommand@ CConCommand::CConCommand(const string& in szName, const string& in szHelpInfo, ConCommandCallback@ pCallback, const ConCommandFlags_t flags = ConCommandFlag::None)": {
		"prefix": "CConCommand",
		"body" : [ "CConCommand( ${1:const string& in szName}, ${2:const string& in szHelpInfo}, ${3:ConCommandCallback@ pCallback}, ${4:const ConCommandFlags_t flags = ConCommandFlag::None} )" ],
		"description" : "Constructor"
	},
	"CBasePlayer@ CConCommandSystem::GetCurrentPlayer() const": {
		"prefix": "GetCurrentPlayer",
		"body" : [ "GetCurrentPlayer()" ],
		"description" : "If the current command was executed by a player, this returns that player."
	},
	"void CConCommandSystem::ServerCommand(const string& in szCommand)": {
		"prefix": "ServerCommand",
		"body" : [ "ServerCommand( ${1:const string& in szCommand} )" ],
		"description" : "Executes an Angelscript server command."
	},
	"bool CCustomEntityFuncs::IsCustomEntity(const string& in szEntityname) const": {
		"prefix": "IsCustomEntity",
		"body" : [ "IsCustomEntity( ${1:const string& in szEntityname} )" ],
		"description" : "Returns whether the given entity name is a registered custom entity"
	},
	"void CCustomEntityFuncs::RegisterCustomEntity(const string& in szClassname, const string& in szEntityname)": {
		"prefix": "RegisterCustomEntity",
		"body" : [ "RegisterCustomEntity( ${1:const string& in szClassname}, ${2:const string& in szEntityname} )" ],
		"description" : "Registers a class called szClassname as a custom entity named szEntityname. The class must inherit from a script entity base class."
	},
	"void CCustomEntityFuncs::UnRegisterCustomEntity(const string& in szEntityname)": {
		"prefix": "UnRegisterCustomEntity",
		"body" : [ "UnRegisterCustomEntity( ${1:const string& in szEntityname} )" ],
		"description" : "Unregisters a custom entity by the given name"
	},
	"const string& CCVar::GetName() const": {
		"prefix": "GetName",
		"body" : [ "GetName()" ],
		"description" : "Gets the name of this command."
	},
	"const string& CCVar::GetFullyQualifiedName() const": {
		"prefix": "GetFullyQualifiedName",
		"body" : [ "GetFullyQualifiedName()" ],
		"description" : "Gets the fully qualified name of this command. This is the name that the command is referred by when called."
	},
	"const string& CCVar::GetHelpInfo() const": {
		"prefix": "GetHelpInfo",
		"body" : [ "GetHelpInfo()" ],
		"description" : "Gets the help info describing this command."
	},
	"ConCommandKind::Type CCVar::GetKind() const": {
		"prefix": "GetKind",
		"body" : [ "GetKind()" ],
		"description" : "Gets the type of this console command."
	},
	"const string& CCVar::GetOwningModuleName() const": {
		"prefix": "GetOwningModuleName",
		"body" : [ "GetOwningModuleName()" ],
		"description" : "Gets the name of the module that owns (created) this command."
	},
	"bool CCVar::HasBeenAdded() const": {
		"prefix": "HasBeenAdded",
		"body" : [ "HasBeenAdded()" ],
		"description" : "Whether this command was added to the list of commands. Must be added to be usable from the console."
	},
	"CCVar@ CCVar::CCVar(const string& in szName, float flValue = 0, const string& in szHelpInfo = \"\", const ConCommandFlags_t flags = ConCommandFlag::None, CVarCallback@ pCallback = null)": {
		"prefix": "CCVar",
		"body" : [ "CCVar( ${1:const string& in szName}, ${2:float flValue = 0}, ${3:const string& in szHelpInfo = \"\"}, ${4:const ConCommandFlags_t flags = ConCommandFlag::None}, ${5:CVarCallback@ pCallback = null} )" ],
		"description" : "Constructor"
	},
	"CCVar@ CCVar::CCVar(const string& in szName, const string& in szValue, const string& in szHelpInfo = \"\", const ConCommandFlags_t flags = ConCommandFlag::None, CVarCallback@ pCallback = null)": {
		"prefix": "CCVar",
		"body" : [ "CCVar( ${1:const string& in szName}, ${2:const string& in szValue}, ${3:const string& in szHelpInfo = \"\"}, ${4:const ConCommandFlags_t flags = ConCommandFlag::None}, ${5:CVarCallback@ pCallback = null} )" ],
		"description" : "Constructor"
	},
	"const string& CCVar::GetDefaultValue() const": {
		"prefix": "GetDefaultValue",
		"body" : [ "GetDefaultValue()" ],
		"description" : "Gets the default value for this cvar."
	},
	"const string& CCVar::GetString() const": {
		"prefix": "GetString",
		"body" : [ "GetString()" ],
		"description" : "Converts the value to a string."
	},
	"float CCVar::GetFloat() const": {
		"prefix": "GetFloat",
		"body" : [ "GetFloat()" ],
		"description" : "Converts the value to a float."
	},
	"int CCVar::GetInt() const": {
		"prefix": "GetInt",
		"body" : [ "GetInt()" ],
		"description" : "Converts the value to an integer."
	},
	"bool CCVar::GetBool() const": {
		"prefix": "GetBool",
		"body" : [ "GetBool()" ],
		"description" : "Converts the value to a boolean."
	},
	"void CCVar::SetString(const string& in szValue)": {
		"prefix": "SetString",
		"body" : [ "SetString( ${1:const string& in szValue} )" ],
		"description" : "Sets the given string as the value."
	},
	"void CCVar::SetFloat(const float flValue)": {
		"prefix": "SetFloat",
		"body" : [ "SetFloat( ${1:const float flValue} )" ],
		"description" : "Sets the given float as the value."
	},
	"void CCVar::SetInt(const int iValue)": {
		"prefix": "SetInt",
		"body" : [ "SetInt( ${1:const int iValue} )" ],
		"description" : "Sets the given integer as the value."
	},
	"void CCVar::SetBool(const bool bValue)": {
		"prefix": "SetBool",
		"body" : [ "SetBool( ${1:const bool bValue} )" ],
		"description" : "Sets the given boolean as the value."
	},
	"uint32 CDebugger::GetCurrentStackLevel() const": {
		"prefix": "GetCurrentStackLevel",
		"body" : [ "GetCurrentStackLevel()" ],
		"description" : "Gets the current stack level."
	},
	"void CDebugger::OutputLocals()": {
		"prefix": "OutputLocals",
		"body" : [ "OutputLocals()" ],
		"description" : "Output local variables."
	},
	"void CDebugger::OutputGlobals()": {
		"prefix": "OutputGlobals",
		"body" : [ "OutputGlobals()" ],
		"description" : "Output global variables."
	},
	"void CDebugger::OutputMembers()": {
		"prefix": "OutputMembers",
		"body" : [ "OutputMembers()" ],
		"description" : "Output member variables."
	},
	"void CDebugger::OutputStatistics()": {
		"prefix": "OutputStatistics",
		"body" : [ "OutputStatistics()" ],
		"description" : "Output statistics."
	},
	"string CDecals::GetName(decal_e decal) const": {
		"prefix": "GetName",
		"body" : [ "GetName( ${1:decal_e decal} )" ],
		"description" : "Gets the name of the texture representing the given decal."
	},
	"string CDecals::GetIndex(decal_e decal) const": {
		"prefix": "GetIndex",
		"body" : [ "GetIndex( ${1:decal_e decal} )" ],
		"description" : "Gets the texture frame index of the given decal."
	},
	"enum CDMG {..., itbd_Paralyze, ...}": {
		"prefix": "itbd_Paralyze",
		"body" : [ "itbd_Paralyze" ],
		"description" : "(0)"
	},
	"enum CDMG {..., itbd_NerveGas, ...}": {
		"prefix": "itbd_NerveGas",
		"body" : [ "itbd_NerveGas" ],
		"description" : "(1)"
	},
	"enum CDMG {..., itbd_Poison, ...}": {
		"prefix": "itbd_Poison",
		"body" : [ "itbd_Poison" ],
		"description" : "(2)"
	},
	"enum CDMG {..., itbd_Radiation, ...}": {
		"prefix": "itbd_Radiation",
		"body" : [ "itbd_Radiation" ],
		"description" : "(3)"
	},
	"enum CDMG {..., itbd_DrownRecover, ...}": {
		"prefix": "itbd_DrownRecover",
		"body" : [ "itbd_DrownRecover" ],
		"description" : "(4)"
	},
	"enum CDMG {..., itbd_Acid, ...}": {
		"prefix": "itbd_Acid",
		"body" : [ "itbd_Acid" ],
		"description" : "(5)"
	},
	"enum CDMG {..., itbd_SlowBurn, ...}": {
		"prefix": "itbd_SlowBurn",
		"body" : [ "itbd_SlowBurn" ],
		"description" : "(6)"
	},
	"enum CDMG {..., itbd_SlowFreeze, ...}": {
		"prefix": "itbd_SlowFreeze",
		"body" : [ "itbd_SlowFreeze" ],
		"description" : "(7)"
	},
	"enum CDMG {..., CDMG_TIMEBASED, ...}": {
		"prefix": "CDMG_TIMEBASED",
		"body" : [ "CDMG_TIMEBASED" ],
		"description" : "(8) Number of damage over time types"
	},
	"const float CEngine::time": {
		"prefix": "time",
		"body" : [ "time" ],
		"description" : "Current time"
	},
	"const float CEngine::frametime": {
		"prefix": "frametime",
		"body" : [ "frametime" ],
		"description" : "Time between frames"
	},
	"float CEngine::force_retouch": {
		"prefix": "force_retouch",
		"body" : [ "force_retouch" ],
		"description" : "How many times to force all entities to retouch entities they are currently touching/intersecting. Should always be >= 0."
	},
	"const string_t CEngine::mapname": {
		"prefix": "mapname",
		"body" : [ "mapname" ],
		"description" : "Name of the current map"
	},
	"const string_t CEngine::startspot": {
		"prefix": "startspot",
		"body" : [ "startspot" ],
		"description" : "Start location in the map"
	},
	"float CEngine::deathmatch": {
		"prefix": "deathmatch",
		"body" : [ "deathmatch" ],
		"description" : "Flag telling whether this is deathmatch"
	},
	"float CEngine::coop": {
		"prefix": "coop",
		"body" : [ "coop" ],
		"description" : "Flag telling whether this is coop"
	},
	"float CEngine::teamplay": {
		"prefix": "teamplay",
		"body" : [ "teamplay" ],
		"description" : "Flag telling whether this is teamplay"
	},
	"const float CEngine::serverflags": {
		"prefix": "serverflags",
		"body" : [ "serverflags" ],
		"description" : "Server flags"
	},
	"float CEngine::found_secrets": {
		"prefix": "found_secrets",
		"body" : [ "found_secrets" ],
		"description" : "Found secrets"
	},
	"const Vector CEngine::v_forward": {
		"prefix": "v_forward",
		"body" : [ "v_forward" ],
		"description" : "Forward vector"
	},
	"const Vector CEngine::v_up": {
		"prefix": "v_up",
		"body" : [ "v_up" ],
		"description" : "Up vector"
	},
	"const Vector CEngine::v_right": {
		"prefix": "v_right",
		"body" : [ "v_right" ],
		"description" : "Right vector"
	},
	"const float CEngine::trace_allsolid": {
		"prefix": "trace_allsolid",
		"body" : [ "trace_allsolid" ],
		"description" : "Trace all is solid flag"
	},
	"const float CEngine::trace_startsolid": {
		"prefix": "trace_startsolid",
		"body" : [ "trace_startsolid" ],
		"description" : "Trace start is solid flag"
	},
	"const float CEngine::trace_fraction": {
		"prefix": "trace_fraction",
		"body" : [ "trace_fraction" ],
		"description" : "Trace fraction"
	},
	"const Vector CEngine::trace_endpos": {
		"prefix": "trace_endpos",
		"body" : [ "trace_endpos" ],
		"description" : "Trace end position"
	},
	"const Vector CEngine::trace_plane_normal": {
		"prefix": "trace_plane_normal",
		"body" : [ "trace_plane_normal" ],
		"description" : "Trace plane normal"
	},
	"const float CEngine::trace_plane_dist": {
		"prefix": "trace_plane_dist",
		"body" : [ "trace_plane_dist" ],
		"description" : "Trace plane distance"
	},
	"const edict_t@ CEngine::trace_ent": {
		"prefix": "trace_ent",
		"body" : [ "trace_ent" ],
		"description" : "Trace entity"
	},
	"const float CEngine::trace_inopen": {
		"prefix": "trace_inopen",
		"body" : [ "trace_inopen" ],
		"description" : "Trace is in open flag"
	},
	"const float CEngine::trace_inwater": {
		"prefix": "trace_inwater",
		"body" : [ "trace_inwater" ],
		"description" : "Trace is in water flag"
	},
	"const int CEngine::trace_hitgroup": {
		"prefix": "trace_hitgroup",
		"body" : [ "trace_hitgroup" ],
		"description" : "Trace hit group"
	},
	"const int CEngine::trace_flags": {
		"prefix": "trace_flags",
		"body" : [ "trace_flags" ],
		"description" : "Trace flags"
	},
	"const int CEngine::msg_entity": {
		"prefix": "msg_entity",
		"body" : [ "msg_entity" ],
		"description" : "Message entity"
	},
	"int CEngine::cdAudioTrack": {
		"prefix": "cdAudioTrack",
		"body" : [ "cdAudioTrack" ],
		"description" : "CD audio track"
	},
	"const int CEngine::maxClients": {
		"prefix": "maxClients",
		"body" : [ "maxClients" ],
		"description" : "Maximum connected clients"
	},
	"const int CEngine::maxEntities": {
		"prefix": "maxEntities",
		"body" : [ "maxEntities" ],
		"description" : "Maximum entities"
	},
	"int CEngineFuncs::ModelIndex(const string& in szModelName)": {
		"prefix": "ModelIndex",
		"body" : [ "ModelIndex( ${1:const string& in szModelName} )" ],
		"description" : "Gets the model index of a model."
	},
	"int CEngineFuncs::ModelFrames(int iModelIndex)": {
		"prefix": "ModelFrames",
		"body" : [ "ModelFrames( ${1:int iModelIndex} )" ],
		"description" : "Gets the number of frames in a model."
	},
	"void CEngineFuncs::ChangeLevel(const string& in szLevelName)": {
		"prefix": "ChangeLevel",
		"body" : [ "ChangeLevel( ${1:const string& in szLevelName} )" ],
		"description" : "Changes the current level to the one specified."
	},
	"float CEngineFuncs::VecToYaw(const Vector& in vec)": {
		"prefix": "VecToYaw",
		"body" : [ "VecToYaw( ${1:const Vector& in vec} )" ],
		"description" : "Vector to yaw"
	},
	"void CEngineFuncs::VecToAngles(const Vector& in vec, Vector& out angles)": {
		"prefix": "VecToAngles",
		"body" : [ "VecToAngles( ${1:const Vector& in vec}, ${2:Vector& out angles} )" ],
		"description" : "Vector to angles"
	},
	"void CEngineFuncs::MoveToOrigin(edict_t@ pEntity, const Vector& in vecGoal, float flDist, int iMoveType)": {
		"prefix": "MoveToOrigin",
		"body" : [ "MoveToOrigin( ${1:edict_t@ pEntity}, ${2:const Vector& in vecGoal}, ${3:float flDist}, ${4:int iMoveType} )" ],
		"description" : "Move entity to origin."
	},
	"void CEngineFuncs::ChangeYaw(edict_t@ pEntity)": {
		"prefix": "ChangeYaw",
		"body" : [ "ChangeYaw( ${1:edict_t@ pEntity} )" ],
		"description" : "Change yaw. This updates entvars_t::angles[1] to approach entvars_t::ideal_yaw, at entvars_t::yaw_speed degrees speed."
	},
	"void CEngineFuncs::ChangePitch(edict_t@ pEntity)": {
		"prefix": "ChangePitch",
		"body" : [ "ChangePitch( ${1:edict_t@ pEntity} )" ],
		"description" : "Change pitch. This updates entvars_t::angles[0] to approach entvars_t::idealpitch, at entvars_t::pitch_speed degrees speed."
	},
	"int CEngineFuncs::GetEntityIllum(edict_t@ pEntity)": {
		"prefix": "GetEntityIllum",
		"body" : [ "GetEntityIllum( ${1:edict_t@ pEntity} )" ],
		"description" : "Get entity illumination. This is a weighted value between 0 and 255, inclusive."
	},
	"edict_t@ CEngineFuncs::FindClientInPVS(edict_t@ pStartEntity)": {
		"prefix": "FindClientInPVS",
		"body" : [ "FindClientInPVS( ${1:edict_t@ pStartEntity} )" ],
		"description" : "Find client in Potentially Visible Set."
	},
	"edict_t@ CEngineFuncs::EntitiesInPVS(edict_t@ pStartEntity)": {
		"prefix": "EntitiesInPVS",
		"body" : [ "EntitiesInPVS( ${1:edict_t@ pStartEntity} )" ],
		"description" : "Find entities in Potentially Visible Set. Edict::vars::chain is used for this list, and is temporary."
	},
	"void CEngineFuncs::MakeVectors(const Vector& in vec)": {
		"prefix": "MakeVectors",
		"body" : [ "MakeVectors( ${1:const Vector& in vec} )" ],
		"description" : "Make vectors. The results are stored in g_Engine::v_forward, v_right, and v_up."
	},
	"void CEngineFuncs::AngleVectors(const Vector& in vecIn, Vector& out vecForward, Vector& out vecRight, Vector& out vecUp)": {
		"prefix": "AngleVectors",
		"body" : [ "AngleVectors( ${1:const Vector& in vecIn}, ${2:Vector& out vecForward}, ${3:Vector& out vecRight}, ${4:Vector& out vecUp} )" ],
		"description" : "Angle vectors"
	},
	"void CEngineFuncs::MakeStatic(edict_t@ pEntity)": {
		"prefix": "MakeStatic",
		"body" : [ "MakeStatic( ${1:edict_t@ pEntity} )" ],
		"description" : "Make entity static. This moves the entity to the client.Its current visual state is copied over, and the entity is removed on the server side.Only valid while the level is loading."
	},
	"int CEngineFuncs::EntIsOnFloor(edict_t@ pEntity)": {
		"prefix": "EntIsOnFloor",
		"body" : [ "EntIsOnFloor( ${1:edict_t@ pEntity} )" ],
		"description" : "Returns whether entity is on the floor."
	},
	"int CEngineFuncs::DropToFloor(edict_t@ pEntity)": {
		"prefix": "DropToFloor",
		"body" : [ "DropToFloor( ${1:edict_t@ pEntity} )" ],
		"description" : "Drop entity to floor."
	},
	"int CEngineFuncs::WalkMove(edict_t@ pEntity, float flYaw, float flDist, int iMove)": {
		"prefix": "WalkMove",
		"body" : [ "WalkMove( ${1:edict_t@ pEntity}, ${2:float flYaw}, ${3:float flDist}, ${4:int iMove} )" ],
		"description" : "Make entity walk. See WALKMOVE enum"
	},
	"void CEngineFuncs::GetAimVector(edict_t@ pEntity, float flSpeed, Vector& out vecReturn)": {
		"prefix": "GetAimVector",
		"body" : [ "GetAimVector( ${1:edict_t@ pEntity}, ${2:float flSpeed}, ${3:Vector& out vecReturn} )" ],
		"description" : "Get aim vector for entity."
	},
	"void CEngineFuncs::ServerCommand(const string& in szCommand)": {
		"prefix": "ServerCommand",
		"body" : [ "ServerCommand( ${1:const string& in szCommand} )" ],
		"description" : "Issues a command to the server. Plugins only."
	},
	"void CEngineFuncs::ServerExecute()": {
		"prefix": "ServerExecute",
		"body" : [ "ServerExecute()" ],
		"description" : "Executes all pending server commands. Plugins only."
	},
	"void CEngineFuncs::ParticleEffect(const Vector& in vecOrigin, const Vector& in vecDir, float flColor, float flCount)": {
		"prefix": "ParticleEffect",
		"body" : [ "ParticleEffect( ${1:const Vector& in vecOrigin}, ${2:const Vector& in vecDir}, ${3:float flColor}, ${4:float flCount} )" ],
		"description" : "Emit a particle effect."
	},
	"void CEngineFuncs::LightStyle(int iStyle, const string& in szVal)": {
		"prefix": "LightStyle",
		"body" : [ "LightStyle( ${1:int iStyle}, ${2:const string& in szVal} )" ],
		"description" : "Set a light style."
	},
	"int CEngineFuncs::DecalIndex(const string& in szName)": {
		"prefix": "DecalIndex",
		"body" : [ "DecalIndex( ${1:const string& in szName} )" ],
		"description" : "Get decal index."
	},
	"CONTENTS CEngineFuncs::PointContents(const Vector& in vecPoint)": {
		"prefix": "PointContents",
		"body" : [ "PointContents( ${1:const Vector& in vecPoint} )" ],
		"description" : "Check if point is in contents."
	},
	"float CEngineFuncs::CVarGetFloat(const string& in szCvar)": {
		"prefix": "CVarGetFloat",
		"body" : [ "CVarGetFloat( ${1:const string& in szCvar} )" ],
		"description" : "Get cvar float value."
	},
	"string CEngineFuncs::CVarGetString(const string& in szCvar)": {
		"prefix": "CVarGetString",
		"body" : [ "CVarGetString( ${1:const string& in szCvar} )" ],
		"description" : "Get cvar string value."
	},
	"void CEngineFuncs::CVarSetFloat(const string& in szCvar, float flValue)": {
		"prefix": "CVarSetFloat",
		"body" : [ "CVarSetFloat( ${1:const string& in szCvar}, ${2:float flValue} )" ],
		"description" : "Set cvar float value."
	},
	"void CEngineFuncs::CVarSetString(const string& in szCvar, const string& in szValue)": {
		"prefix": "CVarSetString",
		"body" : [ "CVarSetString( ${1:const string& in szCvar}, ${2:const string& in szValue} )" ],
		"description" : "Set cvar string value."
	},
	"entvars_t@ CEngineFuncs::GetVarsOfEnt(edict_t@ pEdict)": {
		"prefix": "GetVarsOfEnt",
		"body" : [ "GetVarsOfEnt( ${1:edict_t@ pEdict} )" ],
		"description" : "Gets entity variables of entity."
	},
	"int CEngineFuncs::IndexOfEdict(const edict_t@ pEdict)": {
		"prefix": "IndexOfEdict",
		"body" : [ "IndexOfEdict( ${1:const edict_t@ pEdict} )" ],
		"description" : "Get index of edict."
	},
	"edict_t@ CEngineFuncs::PEntityOfEntIndex(int iIndex)": {
		"prefix": "PEntityOfEntIndex",
		"body" : [ "PEntityOfEntIndex( ${1:int iIndex} )" ],
		"description" : "Get entity by entity index."
	},
	"edict_t@ CEngineFuncs::FindEntityByVars(entvars_t@ pVars)": {
		"prefix": "FindEntityByVars",
		"body" : [ "FindEntityByVars( ${1:entvars_t@ pVars} )" ],
		"description" : "Find entity by variables."
	},
	"void CEngineFuncs::GetBonePosition(const edict_t@ pEdict, int iBone, Vector& out vecOrigin, Vector& out vecAngles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:const edict_t@ pEdict}, ${2:int iBone}, ${3:Vector& out vecOrigin}, ${4:Vector& out vecAngles} )" ],
		"description" : "Get bone position."
	},
	"void CEngineFuncs::ClientPrintf(CBasePlayer@ pPlayer, PRINT_TYPE printType, const string& in szMessage)": {
		"prefix": "ClientPrintf",
		"body" : [ "ClientPrintf( ${1:CBasePlayer@ pPlayer}, ${2:PRINT_TYPE printType}, ${3:const string& in szMessage} )" ],
		"description" : "Client print"
	},
	"void CEngineFuncs::ServerPrint(const string& in szMessage)": {
		"prefix": "ServerPrint",
		"body" : [ "ServerPrint( ${1:const string& in szMessage} )" ],
		"description" : "Server print"
	},
	"string CEngineFuncs::Cmd_Args()": {
		"prefix": "Cmd_Args",
		"body" : [ "Cmd_Args()" ],
		"description" : "Get command arguments."
	},
	"string CEngineFuncs::Cmd_Argv(int iIndex)": {
		"prefix": "Cmd_Argv",
		"body" : [ "Cmd_Argv( ${1:int iIndex} )" ],
		"description" : "Get command argument by index."
	},
	"int CEngineFuncs::Cmd_Argc()": {
		"prefix": "Cmd_Argc",
		"body" : [ "Cmd_Argc()" ],
		"description" : "Get number of command arguments."
	},
	"void CEngineFuncs::GetAttachment(const edict_t@ pEdict, int iAttachment, Vector& out vecOrigin, Vector& out vecAngles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:const edict_t@ pEdict}, ${2:int iAttachment}, ${3:Vector& out vecOrigin}, ${4:Vector& out vecAngles} )" ],
		"description" : "Get attachment position."
	},
	"void CEngineFuncs::SetView(const edict_t@ pEdict, const edict_t@ pViewEntity)": {
		"prefix": "SetView",
		"body" : [ "SetView( ${1:const edict_t@ pEdict}, ${2:const edict_t@ pViewEntity} )" ],
		"description" : "Set view."
	},
	"float CEngineFuncs::Time()": {
		"prefix": "Time",
		"body" : [ "Time()" ],
		"description" : "Get current time."
	},
	"void CEngineFuncs::CrosshairAngle(const edict_t@ pEdict, float flPitch, float flYaw)": {
		"prefix": "CrosshairAngle",
		"body" : [ "CrosshairAngle( ${1:const edict_t@ pEdict}, ${2:float flPitch}, ${3:float flYaw} )" ],
		"description" : "Sets the angles of the given player's crosshairs to the given settings. Set both to 0 to disable. May not have any effect in SC."
	},
	"string CEngineFuncs::GetGameDir()": {
		"prefix": "GetGameDir",
		"body" : [ "GetGameDir()" ],
		"description" : "Get game directory."
	},
	"void CEngineFuncs::RunPlayerMove(edict_t@ pEdict, const Vector& in vecViewAngles, float flFowardMove, float flSideMove, float flUpMove, uint16 iButtons, uint8 iImpulse, uint8 iMsec)": {
		"prefix": "RunPlayerMove",
		"body" : [ "RunPlayerMove( ${1:edict_t@ pEdict}, ${2:const Vector& in vecViewAngles}, ${3:float flFowardMove}, ${4:float flSideMove}, ${5:float flUpMove}, ${6:uint16 iButtons}, ${7:uint8 iImpulse}, ${8:uint8 iMsec} )" ],
		"description" : "Run player move."
	},
	"int CEngineFuncs::NumberOfEntities()": {
		"prefix": "NumberOfEntities",
		"body" : [ "NumberOfEntities()" ],
		"description" : "Get number of entities."
	},
	"KeyValueBuffer@ CEngineFuncs::GetInfoKeyBuffer(edict_t@ pEdict)": {
		"prefix": "GetInfoKeyBuffer",
		"body" : [ "GetInfoKeyBuffer( ${1:edict_t@ pEdict} )" ],
		"description" : "Get info key buffer."
	},
	"KeyValueBuffer@ CEngineFuncs::GetPhysicsKeyBuffer(edict_t@ pEdict)": {
		"prefix": "GetPhysicsKeyBuffer",
		"body" : [ "GetPhysicsKeyBuffer( ${1:edict_t@ pEdict} )" ],
		"description" : "Get physics key buffer."
	},
	"bool CEngineFuncs::IsMapValid(const string& in szMapName) const": {
		"prefix": "IsMapValid",
		"body" : [ "IsMapValid( ${1:const string& in szMapName} )" ],
		"description" : "Returns whether the given map is valid."
	},
	"void CEngineFuncs::StaticDecal(const Vector& in vecOrigin, int iDecalIndex, int iEntityIndex, int iModelIndex)": {
		"prefix": "StaticDecal",
		"body" : [ "StaticDecal( ${1:const Vector& in vecOrigin}, ${2:int iDecalIndex}, ${3:int iEntityIndex}, ${4:int iModelIndex} )" ],
		"description" : "Project a static decal."
	},
	"int CEngineFuncs::GetPlayerUserId(edict_t@ pEdict)": {
		"prefix": "GetPlayerUserId",
		"body" : [ "GetPlayerUserId( ${1:edict_t@ pEdict} )" ],
		"description" : "Get player user ID. This is a unique id generated when a player connects. It remains valid as long as the player stays connected to the server."
	},
	"bool CEngineFuncs::IsDedicatedServer() const": {
		"prefix": "IsDedicatedServer",
		"body" : [ "IsDedicatedServer()" ],
		"description" : "Returns whether this is a dedicated server."
	},
	"const Cvar@ CEngineFuncs::CVarGetPointer(const string& in szCvar) const": {
		"prefix": "CVarGetPointer",
		"body" : [ "CVarGetPointer( ${1:const string& in szCvar} )" ],
		"description" : "Gets a pointer to a cvar."
	},
	"void CEngineFuncs::GetPlayerStats(const edict_t@ pEdict, int& out iPing, int& out iPacketLoss)": {
		"prefix": "GetPlayerStats",
		"body" : [ "GetPlayerStats( ${1:const edict_t@ pEdict}, ${2:int& out iPing}, ${3:int& out iPacketLoss} )" ],
		"description" : "Get player stats."
	},
	"bool CEngineFuncs::Voice_GetClientListening(int iReceiver, int iSender)": {
		"prefix": "Voice_GetClientListening",
		"body" : [ "Voice_GetClientListening( ${1:int iReceiver}, ${2:int iSender} )" ],
		"description" : "Voice system - Get client listening."
	},
	"bool CEngineFuncs::Voice_SetClientListening(int iReceiver, int iSender, bool fListen)": {
		"prefix": "Voice_SetClientListening",
		"body" : [ "Voice_SetClientListening( ${1:int iReceiver}, ${2:int iSender}, ${3:bool fListen} )" ],
		"description" : "Voice system - Set client listening."
	},
	"string CEngineFuncs::GetPlayerAuthId(edict_t@ pEdict)": {
		"prefix": "GetPlayerAuthId",
		"body" : [ "GetPlayerAuthId( ${1:edict_t@ pEdict} )" ],
		"description" : "Get the player's Auth ID. (WON/Steam ID)"
	},
	"CBaseEntity@ CEntityFuncs::CreateEntity(const string& in szClassName, dictionary@ pDictionary = null, bool fSpawn = true)": {
		"prefix": "CreateEntity",
		"body" : [ "CreateEntity( ${1:const string& in szClassName}, ${2:dictionary@ pDictionary = null}, ${3:bool fSpawn = true} )" ],
		"description" : "Create an entity by class name. Pass keyvalues in using the dictionary, if any. Keyvalues must be strings. The class name can be either one of the entities included with the game or a custom entity."
	},
	"CBaseEntity@ CEntityFuncs::Create(const string& in szClassname, const Vector& in vecOrigin, const Vector& in vecAngles, bool fCreateAndDontSpawn, edict_t@ entOwner = null)": {
		"prefix": "Create",
		"body" : [ "Create( ${1:const string& in szClassname}, ${2:const Vector& in vecOrigin}, ${3:const Vector& in vecAngles}, ${4:bool fCreateAndDontSpawn}, ${5:edict_t@ entOwner = null} )" ],
		"description" : "Creates an entity by class name."
	},
	"void CEntityFuncs::CreateDecal(const string& in szDecalName, const Vector& in vecOrigin, const string& in szTargetName = \"\")": {
		"prefix": "CreateDecal",
		"body" : [ "CreateDecal( ${1:const string& in szDecalName}, ${2:const Vector& in vecOrigin}, ${3:const string& in szTargetName = \"\"} )" ],
		"description" : "Creates a decal with the specified name. If given a name, has to be triggered to be placed, otherwise, is placed immediately."
	},
	"CSprite@ CEntityFuncs::CreateSprite(const string& in szSpriteName, const Vector& in vecOrigin, bool fAnimated, float flFrameRate = 10.0f)": {
		"prefix": "CreateSprite",
		"body" : [ "CreateSprite( ${1:const string& in szSpriteName}, ${2:const Vector& in vecOrigin}, ${3:bool fAnimated}, ${4:float flFrameRate = 10.0f} )" ],
		"description" : "Creates a sprite. flFrameRate must be set to a valid value to animate the sprite."
	},
	"CBeam@ CEntityFuncs::CreateBeam(const string& in szSpriteName, int width)": {
		"prefix": "CreateBeam",
		"body" : [ "CreateBeam( ${1:const string& in szSpriteName}, ${2:int width} )" ],
		"description" : "Creates a beam entity with the given sprite and width set."
	},
	"void CEntityFuncs::CreateExplosion(const Vector& in vecCenter, const Vector& in vecAngles, edict_t@ pOwner, int iMagnitude, bool fDoDamage)": {
		"prefix": "CreateExplosion",
		"body" : [ "CreateExplosion( ${1:const Vector& in vecCenter}, ${2:const Vector& in vecAngles}, ${3:edict_t@ pOwner}, ${4:int iMagnitude}, ${5:bool fDoDamage} )" ],
		"description" : "Creates an explosion. If fDoDamage is true, also deals damage to entities within its effect radius, which is determined by the magnitude."
	},
	"CBaseEntity@ CEntityFuncs::CreateDisplacerPortal(const Vector& in vecOrigin, const Vector& in vecVelocity, edict_t@ pOwner, float flDamage, float flRadius)": {
		"prefix": "CreateDisplacerPortal",
		"body" : [ "CreateDisplacerPortal( ${1:const Vector& in vecOrigin}, ${2:const Vector& in vecVelocity}, ${3:edict_t@ pOwner}, ${4:float flDamage}, ${5:float flRadius} )" ],
		"description" : "Creates a displacer portal."
	},
	"CBaseEntity@ CEntityFuncs::CreateRPGRocket(const Vector& in vecOrigin, const Vector& in vecAngles, edict_t@ pOwner)": {
		"prefix": "CreateRPGRocket",
		"body" : [ "CreateRPGRocket( ${1:const Vector& in vecOrigin}, ${2:const Vector& in vecAngles}, ${3:edict_t@ pOwner} )" ],
		"description" : "Creates an rpg rocket."
	},
	"CBaseEntity@ CEntityFuncs::CreateRPGRocket(const Vector& in vecOrigin, const Vector& in vecAngles, const Vector& in vecVelocity, edict_t@ pOwner)": {
		"prefix": "CreateRPGRocket",
		"body" : [ "CreateRPGRocket( ${1:const Vector& in vecOrigin}, ${2:const Vector& in vecAngles}, ${3:const Vector& in vecVelocity}, ${4:edict_t@ pOwner} )" ],
		"description" : "Creates an rpg rocket with custom velocity."
	},
	"CGib@ CEntityFuncs::CreateGib(const Vector& in vecOrigin, const Vector& in vecAngles)": {
		"prefix": "CreateGib",
		"body" : [ "CreateGib( ${1:const Vector& in vecOrigin}, ${2:const Vector& in vecAngles} )" ],
		"description" : "Creates a server side gib."
	},
	"CGrenade@ CEntityFuncs::ShootTimed(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity, float flTime)": {
		"prefix": "ShootTimed",
		"body" : [ "ShootTimed( ${1:entvars_t@ pevOwner}, ${2:const Vector& in vecStart}, ${3:const Vector& in vecVelocity}, ${4:float flTime} )" ],
		"description" : "Spawns a timed grenade."
	},
	"CGrenade@ CEntityFuncs::ShootContact(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)": {
		"prefix": "ShootContact",
		"body" : [ "ShootContact( ${1:entvars_t@ pevOwner}, ${2:const Vector& in vecStart}, ${3:const Vector& in vecVelocity} )" ],
		"description" : "Spawns a contact grenade."
	},
	"CGrenade@ CEntityFuncs::ShootMortar(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)": {
		"prefix": "ShootMortar",
		"body" : [ "ShootMortar( ${1:entvars_t@ pevOwner}, ${2:const Vector& in vecStart}, ${3:const Vector& in vecVelocity} )" ],
		"description" : "Spawns a mortar grenade."
	},
	"CGrenade@ CEntityFuncs::ShootBananaCluster(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)": {
		"prefix": "ShootBananaCluster",
		"body" : [ "ShootBananaCluster( ${1:entvars_t@ pevOwner}, ${2:const Vector& in vecStart}, ${3:const Vector& in vecVelocity} )" ],
		"description" : "Spawn a banana bomb."
	},
	"void CEntityFuncs::UseSatchelCharges(entvars_t@ pevOwner, SATCHELCODE code)": {
		"prefix": "UseSatchelCharges",
		"body" : [ "UseSatchelCharges( ${1:entvars_t@ pevOwner}, ${2:SATCHELCODE code} )" ],
		"description" : "Triggers all satchel charges owned by pevOwner to either be released from ownership, or detonated."
	},
	"void CEntityFuncs::SpawnHeadGib(entvars_t@ pevVictim)": {
		"prefix": "SpawnHeadGib",
		"body" : [ "SpawnHeadGib( ${1:entvars_t@ pevVictim} )" ],
		"description" : "Spawns a head gib for the target victim."
	},
	"void CEntityFuncs::SpawnRandomGibs(entvars_t@ pevVictim, int cGibs, int iHuman)": {
		"prefix": "SpawnRandomGibs",
		"body" : [ "SpawnRandomGibs( ${1:entvars_t@ pevVictim}, ${2:int cGibs}, ${3:int iHuman} )" ],
		"description" : "Spawns random gibs for the target victim. iHuman specifies whether the gibs are human or alien."
	},
	"void CEntityFuncs::SpawnStickyGibs(entvars_t@ pevVictim, const Vector& in vecOrigin, int cGibs)": {
		"prefix": "SpawnStickyGibs",
		"body" : [ "SpawnStickyGibs( ${1:entvars_t@ pevVictim}, ${2:const Vector& in vecOrigin}, ${3:int cGibs} )" ],
		"description" : "Spawns sticky gibs for the target victim. cGibs specifies how many gibs there are."
	},
	"void CEntityFuncs::SetOrigin(CBaseEntity@ entity, const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:CBaseEntity@ entity}, ${2:const Vector& in vecOrigin} )" ],
		"description" : "Set the origin of an entity"
	},
	"void CEntityFuncs::SetModel(CBaseEntity@ entity, const string& in szFileName)": {
		"prefix": "SetModel",
		"body" : [ "SetModel( ${1:CBaseEntity@ entity}, ${2:const string& in szFileName} )" ],
		"description" : "Set the model of an entity"
	},
	"void CEntityFuncs::SetSize(entvars_t@ pev, const Vector& in vecMin, const Vector& in vecMax)": {
		"prefix": "SetSize",
		"body" : [ "SetSize( ${1:entvars_t@ pev}, ${2:const Vector& in vecMin}, ${3:const Vector& in vecMax} )" ],
		"description" : "Set the size of an entity"
	},
	"CBaseEntity@ CEntityFuncs::FindEntityInSphere(CBaseEntity@ pStartEntity, const Vector& in vecCenter, float flRadius,const string& in szValue = \"\", const string& in szKeyword = \"targetname\")": {
		"prefix": "FindEntityInSphere",
		"body" : [ "FindEntityInSphere( ${1:CBaseEntity@ pStartEntity}, ${2:const Vector& in vecCenter}, ${3:float flRadius,const string& in szValue = \"\"}, ${4:const string& in szKeyword = \"targetname\"} )" ],
		"description" : "Finds an entity in a sphere"
	},
	"CBaseEntity@ CEntityFuncs::FindEntityByString(CBaseEntity@ pStartEntity,const string& in szKeyword, const string& in szValue)": {
		"prefix": "FindEntityByString",
		"body" : [ "FindEntityByString( ${1:CBaseEntity@ pStartEntity,const string& in szKeyword}, ${2:const string& in szValue} )" ],
		"description" : "Finds an entity based on a key value pair"
	},
	"CBaseEntity@ CEntityFuncs::FindEntityByClassname(CBaseEntity@ startEntity, const string& in name)": {
		"prefix": "FindEntityByClassname",
		"body" : [ "FindEntityByClassname( ${1:CBaseEntity@ startEntity}, ${2:const string& in name} )" ],
		"description" : "Finds an entity by class name"
	},
	"CBaseEntity@ CEntityFuncs::FindEntityByTargetname(CBaseEntity@ startEntity, const string& in name)": {
		"prefix": "FindEntityByTargetname",
		"body" : [ "FindEntityByTargetname( ${1:CBaseEntity@ startEntity}, ${2:const string& in name} )" ],
		"description" : "Finds an entity by target name"
	},
	"CBaseEntity@ CEntityFuncs::FindEntityGeneric(const string& in szName, const Vector& in vecSrc, float flRadius)": {
		"prefix": "FindEntityGeneric",
		"body" : [ "FindEntityGeneric( ${1:const string& in szName}, ${2:const Vector& in vecSrc}, ${3:float flRadius} )" ],
		"description" : "Finds an entity by target name in a sphere"
	},
	"int CEntityFuncs::MonstersInSphere(array<CBaseEntity@>@ pArray, const Vector& in vecCenter, float flRadius)": {
		"prefix": "MonstersInSphere",
		"body" : [ "MonstersInSphere( ${1:array<CBaseEntity@>@ pArray}, ${2:const Vector& in vecCenter}, ${3:float flRadius} )" ],
		"description" : "Finds monsters in a sphere"
	},
	"int CEntityFuncs::EntitiesInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs, int flagMask)": {
		"prefix": "EntitiesInBox",
		"body" : [ "EntitiesInBox( ${1:array<CBaseEntity@>@ pArray}, ${2:const Vector& in mins}, ${3:const Vector& in maxs}, ${4:int flagMask} )" ],
		"description" : "Finds entities in a box"
	},
	"int CEntityFuncs::TargetsInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs)": {
		"prefix": "TargetsInBox",
		"body" : [ "TargetsInBox( ${1:array<CBaseEntity@>@ pArray}, ${2:const Vector& in mins}, ${3:const Vector& in maxs} )" ],
		"description" : "Finds targets in a box"
	},
	"int CEntityFuncs::BrushEntsInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs )": {
		"prefix": "BrushEntsInBox",
		"body" : [ "BrushEntsInBox( ${1:array<CBaseEntity@>@ pArray}, ${2:const Vector& in mins}, ${3:const Vector& in maxs } )" ],
		"description" : "Finds brush entities in a box"
	},
	"int CEntityFuncs::DispatchSpawn(edict_t@ entity)": {
		"prefix": "DispatchSpawn",
		"body" : [ "DispatchSpawn( ${1:edict_t@ entity} )" ],
		"description" : "Dispatches the spawning of an entity"
	},
	"bool CEntityFuncs::DispatchKeyValue(edict_t@ entity, const string& in szKeyName, const string& in szValue)": {
		"prefix": "DispatchKeyValue",
		"body" : [ "DispatchKeyValue( ${1:edict_t@ entity}, ${2:const string& in szKeyName}, ${3:const string& in szValue} )" ],
		"description" : "Dispatches the passing of a key value pair to an entity"
	},
	"bool CEntityFuncs::EntvarsKeyvalue(edict_t@ entity, const string& in szKeyName, const string& in szValue)": {
		"prefix": "EntvarsKeyvalue",
		"body" : [ "EntvarsKeyvalue( ${1:edict_t@ entity}, ${2:const string& in szKeyName}, ${3:const string& in szValue} )" ],
		"description" : "Handles the initialization of keyvalues located in the entity's entvars_t object."
	},
	"void CEntityFuncs::DispatchObjectCollisionBox(edict_t@ entity)": {
		"prefix": "DispatchObjectCollisionBox",
		"body" : [ "DispatchObjectCollisionBox( ${1:edict_t@ entity} )" ],
		"description" : "Dispatches the initialization of the collision box of an entity"
	},
	"CBaseEntity@ CEntityFuncs::Instance(edict_t@ edict)": {
		"prefix": "Instance",
		"body" : [ "Instance( ${1:edict_t@ edict} )" ],
		"description" : "Gets the entity instance of an edict instance"
	},
	"CBaseEntity@ CEntityFuncs::Instance(entvars_t@ vars)": {
		"prefix": "Instance",
		"body" : [ "Instance( ${1:entvars_t@ vars} )" ],
		"description" : "Gets the entity instance of an entvars instance"
	},
	"CBaseEntity@ CEntityFuncs::Instance(int iEdictNum)": {
		"prefix": "Instance",
		"body" : [ "Instance( ${1:int iEdictNum} )" ],
		"description" : "Gets the entity instance based on an edict number"
	},
	"void CEntityFuncs::FireTargets(const string& in szTargetName, CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f, float flDelay = 0.0f)": {
		"prefix": "FireTargets",
		"body" : [ "FireTargets( ${1:const string& in szTargetName}, ${2:CBaseEntity@ pActivator}, ${3:CBaseEntity@ pCaller}, ${4:USE_TYPE useType}, ${5:float flValue = 0.0f}, ${6:float flDelay = 0.0f} )" ],
		"description" : "Triggers targets. If flDelay is nonzero, causes a temporary entity to be spawned to trigger the target at the given time. The temporary entity becomes the caller, not the entity passed in."
	},
	"bool CEntityFuncs::IsMasterTriggered(const string& in szMaster, CBaseEntity@ pActivator)": {
		"prefix": "IsMasterTriggered",
		"body" : [ "IsMasterTriggered( ${1:const string& in szMaster}, ${2:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether the master with the given name would be triggered if activated by the given entity."
	},
	"void CEntityFuncs::Remove(CBaseEntity@ pEntity)": {
		"prefix": "Remove",
		"body" : [ "Remove( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Removes the given entity before the next frame starts."
	},
	"bool CEntityFuncs::IsValidEntity(edict_t@ pEntity)": {
		"prefix": "IsValidEntity",
		"body" : [ "IsValidEntity( ${1:edict_t@ pEntity} )" ],
		"description" : "Returns whether this is a valid entity."
	},
	"int CEntityFuncs::EntIndex(edict_t@ pEdict)": {
		"prefix": "EntIndex",
		"body" : [ "EntIndex( ${1:edict_t@ pEdict} )" ],
		"description" : "Gets the index for the given edict."
	},
	"edict_t@ CEntityFuncs::IndexEnt(int iEdictNum)": {
		"prefix": "IndexEnt",
		"body" : [ "IndexEnt( ${1:int iEdictNum} )" ],
		"description" : "Gets the edict for the given index."
	},
	"void CEntityFuncs::EjectBrass(const Vector& in vecOrigin, const Vector& in vecVelocity, float flRotation, int iModel, TE_BOUNCE soundtype)": {
		"prefix": "EjectBrass",
		"body" : [ "EjectBrass( ${1:const Vector& in vecOrigin}, ${2:const Vector& in vecVelocity}, ${3:float flRotation}, ${4:int iModel}, ${5:TE_BOUNCE soundtype} )" ],
		"description" : "tosses a brass shell from passed origin at passed velocity."
	},
	"ScriptClassInterface@ CEntityFuncs::CastToScriptClass(CBaseEntity@ pEntity)": {
		"prefix": "CastToScriptClass",
		"body" : [ "CastToScriptClass( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Casts an CBaseEntity@ representing a custom entity to the ScriptClassBaseClass type"
	},
	"CBaseEntity@ CEntityFuncs::RandomTargetname(const string& in szTargetname)": {
		"prefix": "RandomTargetname",
		"body" : [ "RandomTargetname( ${1:const string& in szTargetname} )" ],
		"description" : "Returns a randomly selected entity that has the given target name."
	},
	"void CEntityFuncs::PrecacheMaterialSounds(const Materials material)": {
		"prefix": "PrecacheMaterialSounds",
		"body" : [ "PrecacheMaterialSounds( ${1:const Materials material} )" ],
		"description" : "Precaches the sounds used by a particular material"
	},
	"bool CEntityLoader::LoadFromFile(const string& in szFileName, const Vector& in vecOffset = g_vecZero)": {
		"prefix": "LoadFromFile",
		"body" : [ "LoadFromFile( ${1:const string& in szFileName}, ${2:const Vector& in vecOffset = g_vecZero} )" ],
		"description" : "Loads entities from a file."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat}, ${3:?& in} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"bool CGame::AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "AlertMessage",
		"body" : [ "AlertMessage( ${1:ALERT_TYPE aType}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in} )" ],
		"description" : "Outputs a message to the console. Uses SC printf formatting style."
	},
	"int CGame::PrecacheModel(const string& in szFileName)": {
		"prefix": "PrecacheModel",
		"body" : [ "PrecacheModel( ${1:const string& in szFileName} )" ],
		"description" : "Precaches a model. Shuts down the game if not found. Can only be called from MapInit."
	},
	"int CGame::PrecacheModel(CBaseEntity@ pEntity, const string& in szFileName)": {
		"prefix": "PrecacheModel",
		"body" : [ "PrecacheModel( ${1:CBaseEntity@ pEntity}, ${2:const string& in szFileName} )" ],
		"description" : "Precaches a model. Shuts down the game if not found. Can only be called from entity Precache methods."
	},
	"void CGame::PrecacheOther(const string& in szClassName)": {
		"prefix": "PrecacheOther",
		"body" : [ "PrecacheOther( ${1:const string& in szClassName} )" ],
		"description" : "Precaches an entity. This effectively instances an entity with the given class name, calls precache on it, and removes the entity."
	},
	"void CGame::PrecacheMonster(const string& in szClassName, bool fAlly)": {
		"prefix": "PrecacheMonster",
		"body" : [ "PrecacheMonster( ${1:const string& in szClassName}, ${2:bool fAlly} )" ],
		"description" : "Precaches a monster entity. This effectively instances a monster entity with the given class name, calls precache on it, and removes the entity."
	},
	"void CGame::PrecacheGeneric(const string& in szFileName)": {
		"prefix": "PrecacheGeneric",
		"body" : [ "PrecacheGeneric( ${1:const string& in szFileName} )" ],
		"description" : "Precaches a file for download to clients."
	},
	"string CGame::GetGameName() const": {
		"prefix": "GetGameName",
		"body" : [ "GetGameName()" ],
		"description" : "Returns the game name."
	},
	"string CGame::GetGameVersionString() const": {
		"prefix": "GetGameVersionString",
		"body" : [ "GetGameVersionString()" ],
		"description" : "Returns the game version as a string, e.g. \"5.0\"."
	},
	"uint32 CGame::GetGameVersion() const": {
		"prefix": "GetGameVersion",
		"body" : [ "GetGameVersion()" ],
		"description" : "Returns the game version as a number, e.g. 500:. major version, minor version (3.0 becomes 300, 4.0b1 becomes 401, 4.06 becomes 406, 4.5 becomes 450, etc...)"
	},
	"CBaseEntity@ CGib::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CGib::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CGib::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CGib::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CGib::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CGib::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CGib::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CGib::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CGib::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CGib::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CGib::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CGib::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CGib::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CGib::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CGib::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CGib::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CGib::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CGib::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CGib::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CGib::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CGib::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CGib::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CGib::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CGib::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CGib::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CGib::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CGib::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CGib::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CGib::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CGib::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CGib::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CGib::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CGib::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CGib::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CGib::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CGib::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CGib::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CGib::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CGib::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CGib::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CGib::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CGib::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CGib::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CGib::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CGib::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CGib::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CGib::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CGib::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CGib::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CGib::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CGib::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CGib::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CGib::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CGib::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CGib::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CGib::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CGib::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CGib::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CGib::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CGib::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CGib::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CGib::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CGib::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CGib::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CGib::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CGib::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CGib::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CGib::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CGib::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CGib::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CGib::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CGib::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CGib::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CGib::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CGib::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CGib::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CGib::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CGib::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CGib::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CGib::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CGib::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CGib::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CGib::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CGib::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CGib::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CGib::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CGib::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CGib::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CGib::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CGib::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CGib::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CGib::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CGib::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CGib::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CGib::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CGib::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CGib::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CGib::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CGib::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CGib::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CGib::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CGib::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CGib::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CGib::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CGib::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CGib::Spawn(const string& in szModelName)": {
		"prefix": "Spawn",
		"body" : [ "Spawn( ${1:const string& in szModelName} )" ],
		"description" : "Spawns the gib with the given model. Note: this sets several of CGib's variables. Set variables after calling this."
	},
	"void CGib::LimitVelocity()": {
		"prefix": "LimitVelocity",
		"body" : [ "LimitVelocity()" ],
		"description" : "Limits the velocity of the gib"
	},
	"entvars_t@ CGib::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CGib::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CGib::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CGib::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CGib::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CGib::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CGib::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CGib::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CGib::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CGib::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CGib::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CGib::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CGib::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CGib::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CGib::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CGib::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"int CGib::m_bloodColor": {
		"prefix": "m_bloodColor",
		"body" : [ "m_bloodColor" ],
		"description" : "The color of the blood that is sprayed onto walls when the gib touches it."
	},
	"int CGib::m_cBloodDecals": {
		"prefix": "m_cBloodDecals",
		"body" : [ "m_cBloodDecals" ],
		"description" : "Maximum number of blood decals this gib can spray."
	},
	"int CGib::m_material": {
		"prefix": "m_material",
		"body" : [ "m_material" ],
		"description" : "Gib material type. One of the Materials enum values should be used here."
	},
	"float CGib::m_lifeTime": {
		"prefix": "m_lifeTime",
		"body" : [ "m_lifeTime" ],
		"description" : "Lifetime of this gib, in seconds"
	},
	"void CGlobalState::ClearStates()": {
		"prefix": "ClearStates",
		"body" : [ "ClearStates()" ],
		"description" : "Clears all global states"
	},
	"void CGlobalState::EntityAdd(const string& in globalName, const string& in mapName , GLOBALESTATE state)": {
		"prefix": "EntityAdd",
		"body" : [ "EntityAdd( ${1:const string& in globalName}, ${2:const string& in mapName }, ${3:GLOBALESTATE state} )" ],
		"description" : "Adds a new global state object"
	},
	"void CGlobalState::EntitySetState(const string& in globalName, GLOBALESTATE state)": {
		"prefix": "EntitySetState",
		"body" : [ "EntitySetState( ${1:const string& in globalName}, ${2:GLOBALESTATE state} )" ],
		"description" : "Sets the state of an existing global state object"
	},
	"void CGlobalState::EntityUpdate(const string& in globalName, const string& in mapName)": {
		"prefix": "EntityUpdate",
		"body" : [ "EntityUpdate( ${1:const string& in globalName}, ${2:const string& in mapName} )" ],
		"description" : "Updates the level name of the specified global state object"
	},
	"const GlobalEntity@ CGlobalState::EntityFromTable(const string& in globalName) const": {
		"prefix": "EntityFromTable",
		"body" : [ "EntityFromTable( ${1:const string& in globalName} )" ],
		"description" : "Finds a global state object by name"
	},
	"const GLOBALESTATE CGlobalState::EntityGetState(const string& in globalName) const": {
		"prefix": "EntityGetState",
		"body" : [ "EntityGetState( ${1:const string& in globalName} )" ],
		"description" : "Gets the state of the specified global state object"
	},
	"bool CGlobalState::EntityInTable(const string& in globalName) const": {
		"prefix": "EntityInTable",
		"body" : [ "EntityInTable( ${1:const string& in globalName} )" ],
		"description" : "Returns whether the global state object is in the table of objects"
	},
	"void CGlobalState::DumpGlobals() const": {
		"prefix": "DumpGlobals",
		"body" : [ "DumpGlobals()" ],
		"description" : "Dumps all global state objects to the console"
	},
	"CBaseMonster@ CGrenade::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseToggle@ CGrenade::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseAnimating@ CGrenade::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseDelay@ CGrenade::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CGrenade::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CGrenade::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CGrenade::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CGrenade::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CGrenade::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CGrenade::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CGrenade::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CGrenade::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CGrenade::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CGrenade::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CGrenade::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CGrenade::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CGrenade::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CGrenade::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CGrenade::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CGrenade::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CGrenade::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CGrenade::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CGrenade::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CGrenade::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CGrenade::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CGrenade::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CGrenade::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CGrenade::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CGrenade::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CGrenade::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CGrenade::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CGrenade::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CGrenade::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CGrenade::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CGrenade::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CGrenade::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CGrenade::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CGrenade::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CGrenade::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CGrenade::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CGrenade::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CGrenade::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CGrenade::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CGrenade::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CGrenade::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CGrenade::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CGrenade::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CGrenade::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CGrenade::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CGrenade::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"bool CGrenade::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CGrenade::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CGrenade::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CGrenade::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CGrenade::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CGrenade::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CGrenade::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CGrenade::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CGrenade::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CGrenade::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CGrenade::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CGrenade::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CGrenade::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CGrenade::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CGrenade::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CGrenade::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CGrenade::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CGrenade::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CGrenade::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CGrenade::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CGrenade::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CGrenade::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CGrenade::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CGrenade::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CGrenade::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CGrenade::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CGrenade::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CGrenade::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CGrenade::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CGrenade::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CGrenade::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CGrenade::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CGrenade::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CGrenade::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CGrenade::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CGrenade::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CGrenade::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CGrenade::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CGrenade::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CGrenade::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CGrenade::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CGrenade::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CGrenade::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CGrenade::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CGrenade::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CGrenade::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CGrenade::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CGrenade::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CGrenade::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CGrenade::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CGrenade::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CGrenade::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CGrenade::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CGrenade::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CGrenade::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CGrenade::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CGrenade::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CGrenade::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CGrenade::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Causes this entity to trigger its targets with an optional delay."
	},
	"void CGrenade::DelayThink()": {
		"prefix": "DelayThink",
		"body" : [ "DelayThink()" ],
		"description" : "Think function. Used internally."
	},
	"float CGrenade::StudioFrameAdvance(float flInterval = 0.0f)": {
		"prefix": "StudioFrameAdvance",
		"body" : [ "StudioFrameAdvance( ${1:float flInterval = 0.0f} )" ],
		"description" : "Accumulate animation frame time from last time called until now."
	},
	"int CGrenade::GetSequenceFlags()": {
		"prefix": "GetSequenceFlags",
		"body" : [ "GetSequenceFlags()" ],
		"description" : "Get sequence flags."
	},
	"int CGrenade::LookupActivity(int iActivity)": {
		"prefix": "LookupActivity",
		"body" : [ "LookupActivity( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity, or -1 if no such activity exists."
	},
	"int CGrenade::LookupActivityHeaviest(int iActivity)": {
		"prefix": "LookupActivityHeaviest",
		"body" : [ "LookupActivityHeaviest( ${1:int iActivity} )" ],
		"description" : "Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists."
	},
	"int CGrenade::LookupSequence(const string& in szLabel)": {
		"prefix": "LookupSequence",
		"body" : [ "LookupSequence( ${1:const string& in szLabel} )" ],
		"description" : "Returns the index of the given sequence, or -1 if no such sequence exists."
	},
	"void CGrenade::ResetSequenceInfo()": {
		"prefix": "ResetSequenceInfo",
		"body" : [ "ResetSequenceInfo()" ],
		"description" : "Resets sequence info."
	},
	"void CGrenade::ResetGaitSequenceInfo()": {
		"prefix": "ResetGaitSequenceInfo",
		"body" : [ "ResetGaitSequenceInfo()" ],
		"description" : "Resets gait sequence info."
	},
	"void CGrenade::DispatchAnimEvents(float flFutureInterval = 0.1f)": {
		"prefix": "DispatchAnimEvents",
		"body" : [ "DispatchAnimEvents( ${1:float flFutureInterval = 0.1f} )" ],
		"description" : "Handle events that have happend since last time called up until X seconds into the future."
	},
	"float CGrenade::SetBoneController(int iController, float flValue)": {
		"prefix": "SetBoneController",
		"body" : [ "SetBoneController( ${1:int iController}, ${2:float flValue} )" ],
		"description" : "Sets the specified bone controller to the given value."
	},
	"void CGrenade::InitBoneControllers()": {
		"prefix": "InitBoneControllers",
		"body" : [ "InitBoneControllers()" ],
		"description" : "Initializes bone controllers."
	},
	"float CGrenade::SetBlending(int iBlender, float flValue)": {
		"prefix": "SetBlending",
		"body" : [ "SetBlending( ${1:int iBlender}, ${2:float flValue} )" ],
		"description" : "Sets the given blending controller to the given value."
	},
	"void CGrenade::GetBonePosition(int iBone, Vector& out origin, Vector& out angles)": {
		"prefix": "GetBonePosition",
		"body" : [ "GetBonePosition( ${1:int iBone}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the position of the given bone."
	},
	"void CGrenade::GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f)": {
		"prefix": "GetAutomovement",
		"body" : [ "GetAutomovement( ${1:Vector& out origin}, ${2:Vector& out angles}, ${3:float flInterval = 0.1f} )" ],
		"description" : "Gets automatic movement."
	},
	"int CGrenade::FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence}, ${3:int& out iDir} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"int CGrenade::FindTransition(int iEndingSequence, int iGoalSequence)": {
		"prefix": "FindTransition",
		"body" : [ "FindTransition( ${1:int iEndingSequence}, ${2:int iGoalSequence} )" ],
		"description" : "Find the transition between 2 sequences."
	},
	"void CGrenade::GetAttachment(int iAttachment, Vector& out origin, Vector& out angles)": {
		"prefix": "GetAttachment",
		"body" : [ "GetAttachment( ${1:int iAttachment}, ${2:Vector& out origin}, ${3:Vector& out angles} )" ],
		"description" : "Gets the attachment position."
	},
	"void CGrenade::SetBodygroup(int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iGroup}, ${2:int iValue} )" ],
		"description" : "Sets the given body group to the given value."
	},
	"int CGrenade::GetBodygroup(int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iGroup} )" ],
		"description" : "Gets the value of the given body group."
	},
	"bool CGrenade::ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs)": {
		"prefix": "ExtractBbox",
		"body" : [ "ExtractBbox( ${1:int iSequence}, ${2:Vector& out mins}, ${3:Vector& out maxs} )" ],
		"description" : "Extracts the bounding box of the current model."
	},
	"int CGrenade::GetAttachmentCount()": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount()" ],
		"description" : "Gets the number of attachments that the current model has."
	},
	"void CGrenade::SetSequenceBox()": {
		"prefix": "SetSequenceBox",
		"body" : [ "SetSequenceBox()" ],
		"description" : "Sets the sequence box."
	},
	"int CGrenade::GetSequenceActivityName(int iSequence)": {
		"prefix": "GetSequenceActivityName",
		"body" : [ "GetSequenceActivityName( ${1:int iSequence} )" ],
		"description" : "Gets activity for the given sequence."
	},
	"void CGrenade::LinearMove(Vector vecDest, float flSpeed)": {
		"prefix": "LinearMove",
		"body" : [ "LinearMove( ${1:Vector vecDest}, ${2:float flSpeed} )" ],
		"description" : "Performs linear movement."
	},
	"void CGrenade::AngularMove(Vector vecDestAngle, float flSpeed)": {
		"prefix": "AngularMove",
		"body" : [ "AngularMove( ${1:Vector vecDestAngle}, ${2:float flSpeed} )" ],
		"description" : "Performs angular movement."
	},
	"bool CGrenade::IsToggleLockedByMaster()": {
		"prefix": "IsToggleLockedByMaster",
		"body" : [ "IsToggleLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master. Separate from IsLockedByMaster due to limitations."
	},
	"InventoryRules@ CGrenade::get_m_pInventoryRules() const": {
		"prefix": "get_m_pInventoryRules",
		"body" : [ "get_m_pInventoryRules()" ],
		"description" : "The inventory rules."
	},
	"EHandle& CGrenade::m_hOldEnemy(size_t uiIndex)": {
		"prefix": "m_hOldEnemy",
		"body" : [ "m_hOldEnemy( ${1:size_t uiIndex} )" ],
		"description" : "Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."
	},
	"Vector& CGrenade::m_vecOldEnemy(size_t uiIndex)": {
		"prefix": "m_vecOldEnemy",
		"body" : [ "m_vecOldEnemy( ${1:size_t uiIndex} )" ],
		"description" : "Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES."
	},
	"Waypoint& CGrenade::m_Route(size_t uiIndex)": {
		"prefix": "m_Route",
		"body" : [ "m_Route( ${1:size_t uiIndex} )" ],
		"description" : "Positions of movement. Index must be between 0 and ROUTE_SIZE"
	},
	"int8& CGrenade::m_rgbTimeBasedDamage(size_t uiIndex)": {
		"prefix": "m_rgbTimeBasedDamage",
		"body" : [ "m_rgbTimeBasedDamage( ${1:size_t uiIndex} )" ],
		"description" : "time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED."
	},
	"void CGrenade::MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "MonsterUse",
		"body" : [ "MonsterUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Will make a monster angry at whomever activated it."
	},
	"void CGrenade::Look(int iDistance)": {
		"prefix": "Look",
		"body" : [ "Look( ${1:int iDistance} )" ],
		"description" : "Look - Base class monster function to find enemies or. food by sight. iDistance is distance (in units) that the. monster can see. Sets the sight bits of the m_afConditions mask to indicate. which types of entities were sighted. Function also sets the Looker's m_pLink. to the head of a link list that contains all visible ents. (linked via each ent's m_pLink field)"
	},
	"void CGrenade::RunAI()": {
		"prefix": "RunAI",
		"body" : [ "RunAI()" ],
		"description" : "Runs this monster's AI."
	},
	"void CGrenade::Listen()": {
		"prefix": "Listen",
		"body" : [ "Listen()" ],
		"description" : "Listens for anything that is within audible distance."
	},
	"bool CGrenade::ShouldFadeOnDeath()": {
		"prefix": "ShouldFadeOnDeath",
		"body" : [ "ShouldFadeOnDeath()" ],
		"description" : "Returns whether this monster should fade on death."
	},
	"float CGrenade::ChangeYaw(int iSpeed)": {
		"prefix": "ChangeYaw",
		"body" : [ "ChangeYaw( ${1:int iSpeed} )" ],
		"description" : "turns a monster towards its ideal_yaw"
	},
	"float CGrenade::VecToYaw(Vector vecDir)": {
		"prefix": "VecToYaw",
		"body" : [ "VecToYaw( ${1:Vector vecDir} )" ],
		"description" : "turns a directional vector into a yaw value that points down that vector."
	},
	"float CGrenade::FlYawDiff()": {
		"prefix": "FlYawDiff",
		"body" : [ "FlYawDiff()" ],
		"description" : "returns the difference (in degrees) between monster's current yaw and ideal_yaw. Positive result is left turn, negative is right turn."
	},
	"float CGrenade::DamageForce(float flDamage)": {
		"prefix": "DamageForce",
		"body" : [ "DamageForce( ${1:float flDamage} )" ],
		"description" : "Returns the amount of force applied to this monster when the given amount of damage is done."
	},
	"void CGrenade::SetupFriendly()": {
		"prefix": "SetupFriendly",
		"body" : [ "SetupFriendly()" ],
		"description" : "use this overridden to make some other friendly monsters"
	},
	"void CGrenade::MonsterInit()": {
		"prefix": "MonsterInit",
		"body" : [ "MonsterInit()" ],
		"description" : "Initializes the monster"
	},
	"void CGrenade::MonsterInitDead()": {
		"prefix": "MonsterInitDead",
		"body" : [ "MonsterInitDead()" ],
		"description" : "Call after animation/pose is set up"
	},
	"void CGrenade::BecomeDead(float flSavedHealth)": {
		"prefix": "BecomeDead",
		"body" : [ "BecomeDead( ${1:float flSavedHealth} )" ],
		"description" : "Makes the monster become dead"
	},
	"void CGrenade::Revive()": {
		"prefix": "Revive",
		"body" : [ "Revive()" ],
		"description" : "Revives the monster"
	},
	"void CGrenade::StartMonster()": {
		"prefix": "StartMonster",
		"body" : [ "StartMonster()" ],
		"description" : "Starts the monster"
	},
	"void CGrenade::BestVisibleEnemy()": {
		"prefix": "BestVisibleEnemy",
		"body" : [ "BestVisibleEnemy()" ],
		"description" : "finds best visible enemy for attack"
	},
	"bool CGrenade::FInViewCone(CBaseEntity@ pEntity)": {
		"prefix": "FInViewCone",
		"body" : [ "FInViewCone( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "see if pEntity is in monster's view cone"
	},
	"bool CGrenade::FInViewCone(const Vector& in vecOrigin)": {
		"prefix": "FInViewCone",
		"body" : [ "FInViewCone( ${1:const Vector& in vecOrigin} )" ],
		"description" : "see if given location is in monster's view cone"
	},
	"int CGrenade::CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false)": {
		"prefix": "CheckLocalMove",
		"body" : [ "CheckLocalMove( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd,CBaseEntity@ pTarget}, ${3:float& out flDist}, ${4:Vector& out vecEndPosition}, ${5:bool fOriginalCheck = false} )" ],
		"description" : "finds best visible enemy for attack"
	},
	"void CGrenade::Move(float flInterval = 0.1f)": {
		"prefix": "Move",
		"body" : [ "Move( ${1:float flInterval = 0.1f} )" ],
		"description" : "Starts the monster"
	},
	"void CGrenade::MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval)": {
		"prefix": "MoveExecute",
		"body" : [ "MoveExecute( ${1:CBaseEntity@ pTargetEnt}, ${2:const Vector& in vecDir}, ${3:float flInterval} )" ],
		"description" : "Starts the monster"
	},
	"bool CGrenade::ShouldAdvanceRoute(float flWaypointDist)": {
		"prefix": "ShouldAdvanceRoute",
		"body" : [ "ShouldAdvanceRoute( ${1:float flWaypointDist} )" ],
		"description" : "Returns whether this monster should advance its route"
	},
	"Activity CGrenade::GetStoppedActivity()": {
		"prefix": "GetStoppedActivity",
		"body" : [ "GetStoppedActivity()" ],
		"description" : "Gets the stopped activity"
	},
	"void CGrenade::Stop()": {
		"prefix": "Stop",
		"body" : [ "Stop()" ],
		"description" : "Stops this monster moving"
	},
	"void CGrenade::StopAnimation()": {
		"prefix": "StopAnimation",
		"body" : [ "StopAnimation()" ],
		"description" : "This will stop animation until you call ResetSequenceInfo() at some point in the future"
	},
	"bool CGrenade::CheckRangeAttack1(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1",
		"body" : [ "CheckRangeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CGrenade::CheckRangeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack1_Move",
		"body" : [ "CheckRangeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CGrenade::CheckRangeAttack2(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2",
		"body" : [ "CheckRangeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CGrenade::CheckRangeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckRangeAttack2_Move",
		"body" : [ "CheckRangeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CGrenade::CheckMeleeAttack1(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1",
		"body" : [ "CheckMeleeAttack1( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CGrenade::CheckMeleeAttack1_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack1_Move",
		"body" : [ "CheckMeleeAttack1_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CGrenade::CheckMeleeAttack2(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2",
		"body" : [ "CheckMeleeAttack2( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CGrenade::CheckMeleeAttack2_Move(float flDot, float flDist)": {
		"prefix": "CheckMeleeAttack2_Move",
		"body" : [ "CheckMeleeAttack2_Move( ${1:float flDot}, ${2:float flDist} )" ],
		"description" : "this function will survey conditions and set appropriate conditions bits for attack types."
	},
	"bool CGrenade::CheckTankUsage()": {
		"prefix": "CheckTankUsage",
		"body" : [ "CheckTankUsage()" ],
		"description" : "Checks whether the monster can use a func_tank. Return true if possible."
	},
	"bool CGrenade::FHaveSchedule()": {
		"prefix": "FHaveSchedule",
		"body" : [ "FHaveSchedule()" ],
		"description" : "Returns whether this monster has a schedule."
	},
	"bool CGrenade::FScheduleValid()": {
		"prefix": "FScheduleValid",
		"body" : [ "FScheduleValid()" ],
		"description" : "Returns whether this monster's schedule is valid."
	},
	"void CGrenade::ClearSchedule()": {
		"prefix": "ClearSchedule",
		"body" : [ "ClearSchedule()" ],
		"description" : "Clears this monster's schedule."
	},
	"bool CGrenade::FScheduleDone()": {
		"prefix": "FScheduleDone",
		"body" : [ "FScheduleDone()" ],
		"description" : "Returns whether this monster's schedule is done."
	},
	"void CGrenade::ChangeSchedule(Schedule@ pNewSchedule)": {
		"prefix": "ChangeSchedule",
		"body" : [ "ChangeSchedule( ${1:Schedule@ pNewSchedule} )" ],
		"description" : "Changes this monster's schedule."
	},
	"bool CGrenade::NextScheduledTask()": {
		"prefix": "NextScheduledTask",
		"body" : [ "NextScheduledTask()" ],
		"description" : "Moves to the next scheduled task."
	},
	"Schedule@ CGrenade::ScheduleInList(const string& in szName, array<Schedule@>@ pArray)": {
		"prefix": "ScheduleInList",
		"body" : [ "ScheduleInList( ${1:const string& in szName}, ${2:array<Schedule@>@ pArray} )" ],
		"description" : "Returns the schedule with name szName if it's in the list, NULL otherwise."
	},
	"Schedule@ CGrenade::ScheduleFromName(const string& in szName)": {
		"prefix": "ScheduleFromName",
		"body" : [ "ScheduleFromName( ${1:const string& in szName} )" ],
		"description" : "Returns the schedule with name szName if it exists, NULL otherwise."
	},
	"void CGrenade::MaintainSchedule()": {
		"prefix": "MaintainSchedule",
		"body" : [ "MaintainSchedule()" ],
		"description" : "Maintains the monster's schedule."
	},
	"void CGrenade::StartTask(Task@ pTask)": {
		"prefix": "StartTask",
		"body" : [ "StartTask( ${1:Task@ pTask} )" ],
		"description" : "Starts the given task."
	},
	"void CGrenade::RunTask(Task@ pTask)": {
		"prefix": "RunTask",
		"body" : [ "RunTask( ${1:Task@ pTask} )" ],
		"description" : "Runs the given task."
	},
	"Schedule@ CGrenade::GetScheduleOfType(int iType)": {
		"prefix": "GetScheduleOfType",
		"body" : [ "GetScheduleOfType( ${1:int iType} )" ],
		"description" : "Gets one of the available schedules of the given type."
	},
	"Schedule@ CGrenade::GetSchedule()": {
		"prefix": "GetSchedule",
		"body" : [ "GetSchedule()" ],
		"description" : "Gets the current schedule."
	},
	"void CGrenade::ScheduleChange()": {
		"prefix": "ScheduleChange",
		"body" : [ "ScheduleChange()" ],
		"description" : "Called after the monster's schedule changes."
	},
	"bool CGrenade::CanPlaySequence(const bool bDisregardState, int iInterruptLevel)": {
		"prefix": "CanPlaySequence",
		"body" : [ "CanPlaySequence( ${1:const bool bDisregardState}, ${2:int iInterruptLevel} )" ],
		"description" : "Returns whether this monster can play its sequence."
	},
	"bool CGrenade::CanPlaySentence(const bool bDisregardState)": {
		"prefix": "CanPlaySentence",
		"body" : [ "CanPlaySentence( ${1:const bool bDisregardState} )" ],
		"description" : "Returns whether this monster can play its sentence."
	},
	"void CGrenade::PlaySentence(const string& in szSentence, float duration, float volume, float attenuation)": {
		"prefix": "PlaySentence",
		"body" : [ "PlaySentence( ${1:const string& in szSentence}, ${2:float duration}, ${3:float volume}, ${4:float attenuation} )" ],
		"description" : "Plays the given sentence."
	},
	"void CGrenade::PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener)": {
		"prefix": "PlayScriptedSentence",
		"body" : [ "PlayScriptedSentence( ${1:const string& in szSentence}, ${2:float duration}, ${3:float volume}, ${4:float attenuation}, ${5:const bool bConcurrent}, ${6:CBaseEntity@ pListener} )" ],
		"description" : "Plays the given scripted sentence."
	},
	"void CGrenade::SentenceStop()": {
		"prefix": "SentenceStop",
		"body" : [ "SentenceStop()" ],
		"description" : "Stops playing its current sentence."
	},
	"Task@ CGrenade::GetTask()": {
		"prefix": "GetTask",
		"body" : [ "GetTask()" ],
		"description" : "Gets the current task."
	},
	"MONSTERSTATE CGrenade::GetIdealState()": {
		"prefix": "GetIdealState",
		"body" : [ "GetIdealState()" ],
		"description" : "Gets the ideal monster state."
	},
	"void CGrenade::SetActivity(Activity newActivity)": {
		"prefix": "SetActivity",
		"body" : [ "SetActivity( ${1:Activity newActivity} )" ],
		"description" : "Sets the current activity."
	},
	"void CGrenade::SetGaitActivity(Activity newActivity)": {
		"prefix": "SetGaitActivity",
		"body" : [ "SetGaitActivity( ${1:Activity newActivity} )" ],
		"description" : "Sets the current gait activity."
	},
	"void CGrenade::SetSequenceByName(const string& in szSequence)": {
		"prefix": "SetSequenceByName",
		"body" : [ "SetSequenceByName( ${1:const string& in szSequence} )" ],
		"description" : "Sets the current sequence by name."
	},
	"void CGrenade::SetState(MONSTERSTATE state)": {
		"prefix": "SetState",
		"body" : [ "SetState( ${1:MONSTERSTATE state} )" ],
		"description" : "Sets the current monster state."
	},
	"void CGrenade::ReportAIState()": {
		"prefix": "ReportAIState",
		"body" : [ "ReportAIState()" ],
		"description" : "Reports the AI state."
	},
	"void CGrenade::CheckAttacks(CBaseEntity@ pTarget, float flDist)": {
		"prefix": "CheckAttacks",
		"body" : [ "CheckAttacks( ${1:CBaseEntity@ pTarget}, ${2:float flDist} )" ],
		"description" : "Check attacks to the given enemy at the given distance."
	},
	"void CGrenade::CheckAttacks_Move(CBaseEntity@ pTarget, float flDist)": {
		"prefix": "CheckAttacks_Move",
		"body" : [ "CheckAttacks_Move( ${1:CBaseEntity@ pTarget}, ${2:float flDist} )" ],
		"description" : "Check attacks to the given enemy at the given distance while moving."
	},
	"bool CGrenade::CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos)": {
		"prefix": "CheckAttacksFromPosition",
		"body" : [ "CheckAttacksFromPosition( ${1:CBaseEntity@ pTarget}, ${2:float flDist}, ${3:Vector vecPos} )" ],
		"description" : "Check whether attacks are possible from the given position."
	},
	"bool CGrenade::CheckEnemy(CBaseEntity@ pEnemy)": {
		"prefix": "CheckEnemy",
		"body" : [ "CheckEnemy( ${1:CBaseEntity@ pEnemy} )" ],
		"description" : "part of the Condition collection process, gets and stores data and conditions pertaining to a monster's enemy. Returns true if Enemy LKP was updated."
	},
	"void CGrenade::PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos)": {
		"prefix": "PushEnemy",
		"body" : [ "PushEnemy( ${1:CBaseEntity@ pTarget}, ${2:Vector& in vecLastKnownPos} )" ],
		"description" : "Remember the last few enemies, always remember the player."
	},
	"bool CGrenade::PopEnemy()": {
		"prefix": "PopEnemy",
		"body" : [ "PopEnemy()" ],
		"description" : "Try remembering the last few enemies."
	},
	"bool CGrenade::FGetNodeRoute(Vector vecDest)": {
		"prefix": "FGetNodeRoute",
		"body" : [ "FGetNodeRoute( ${1:Vector vecDest} )" ],
		"description" : "tries to build an entire node path from. the callers origin to the passed vector. If this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route. true is returned if the operation  succeeds (path is valid) or false if failed (no path  exists )."
	},
	"bool CGrenade::TestFGetNodeRoute(Vector vecDest)": {
		"prefix": "TestFGetNodeRoute",
		"body" : [ "TestFGetNodeRoute( ${1:Vector vecDest} )" ],
		"description" : "TEST FGetNodeRoute."
	},
	"void CGrenade::TaskComplete()": {
		"prefix": "TaskComplete",
		"body" : [ "TaskComplete()" ],
		"description" : "Sets the task status to complete."
	},
	"void CGrenade::MovementComplete()": {
		"prefix": "MovementComplete",
		"body" : [ "MovementComplete()" ],
		"description" : "Called when movement has completed."
	},
	"void CGrenade::TaskFail()": {
		"prefix": "TaskFail",
		"body" : [ "TaskFail()" ],
		"description" : "Sets the condition bit for a failed task."
	},
	"void CGrenade::TaskBegin()": {
		"prefix": "TaskBegin",
		"body" : [ "TaskBegin()" ],
		"description" : "Sets the task status to running."
	},
	"bool CGrenade::TaskIsRunning()": {
		"prefix": "TaskIsRunning",
		"body" : [ "TaskIsRunning()" ],
		"description" : "Returns whether a task is running."
	},
	"bool CGrenade::TaskIsComplete()": {
		"prefix": "TaskIsComplete",
		"body" : [ "TaskIsComplete()" ],
		"description" : "Returns whether the task is complete."
	},
	"bool CGrenade::MovementIsComplete()": {
		"prefix": "MovementIsComplete",
		"body" : [ "MovementIsComplete()" ],
		"description" : "Returns whether movement is complete."
	},
	"int CGrenade::IScheduleFlags()": {
		"prefix": "IScheduleFlags",
		"body" : [ "IScheduleFlags()" ],
		"description" : "Returns an integer with all Conditions. bits that are currently set and also set in the current. schedule's Interrupt mask."
	},
	"void CGrenade::MakeIdealYaw(Vector vecTarget)": {
		"prefix": "MakeIdealYaw",
		"body" : [ "MakeIdealYaw( ${1:Vector vecTarget} )" ],
		"description" : "gets a yaw value for the caller that would. face the supplied vector. Value is stuffed into the monster's. ideal_yaw."
	},
	"void CGrenade::SetYawSpeed()": {
		"prefix": "SetYawSpeed",
		"body" : [ "SetYawSpeed()" ],
		"description" : "Allows different yaw_speeds for each activity."
	},
	"int CGrenade::RouteClassify(int iMoveFlag)": {
		"prefix": "RouteClassify",
		"body" : [ "RouteClassify( ${1:int iMoveFlag} )" ],
		"description" : "Returns the MOVEGOAL for the given move flag."
	},
	"bool CGrenade::CheckAttacker(CBaseEntity@ pAttacker)": {
		"prefix": "CheckAttacker",
		"body" : [ "CheckAttacker( ${1:CBaseEntity@ pAttacker} )" ],
		"description" : "Determine if we should ignore damage."
	},
	"void CGrenade::SetConditions(int iConditions)": {
		"prefix": "SetConditions",
		"body" : [ "SetConditions( ${1:int iConditions} )" ],
		"description" : "Sets AI conditions."
	},
	"void CGrenade::ClearConditions(int iConditions)": {
		"prefix": "ClearConditions",
		"body" : [ "ClearConditions( ${1:int iConditions} )" ],
		"description" : "Clears AI conditions."
	},
	"bool CGrenade::HasConditions(int iConditions) const": {
		"prefix": "HasConditions",
		"body" : [ "HasConditions( ${1:int iConditions} )" ],
		"description" : "Returns whether this monster has any of the given AI conditions."
	},
	"bool CGrenade::HasAllConditions(int iConditions) const": {
		"prefix": "HasAllConditions",
		"body" : [ "HasAllConditions( ${1:int iConditions} )" ],
		"description" : "Returns whether this monster has all of the given AI conditions."
	},
	"CSound@ CGrenade::PBestSound()": {
		"prefix": "PBestSound",
		"body" : [ "PBestSound()" ],
		"description" : "Returns a pointer to the sound the monster should react to."
	},
	"bool CGrenade::FShouldEat()": {
		"prefix": "FShouldEat",
		"body" : [ "FShouldEat()" ],
		"description" : "Returns whether this monster should eat."
	},
	"void CGrenade::Eat(float flFullDuration)": {
		"prefix": "Eat",
		"body" : [ "Eat( ${1:float flFullDuration} )" ],
		"description" : "Make the monster 'full' for a while."
	},
	"bool CGrenade::FCheckAITrigger()": {
		"prefix": "FCheckAITrigger",
		"body" : [ "FCheckAITrigger()" ],
		"description" : "Checks and, if necessary, fires the monster's trigger target."
	},
	"bool CGrenade::NoFriendlyFire()": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire()" ],
		"description" : "Returns whether attacking at this time would result in friendly fire"
	},
	"bool CGrenade::NoFriendlyFire(Vector vecPos)": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire( ${1:Vector vecPos} )" ],
		"description" : "Returns whether attacking at this time from the given location would result in friendly fire"
	},
	"bool CGrenade::NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget)": {
		"prefix": "NoFriendlyFire",
		"body" : [ "NoFriendlyFire( ${1:Vector vecPos}, ${2:CBaseEntity@ pTarget} )" ],
		"description" : "Returns whether attacking the given target at this time from the given location would result in friendly fire"
	},
	"bool CGrenade::NoFriendlyFireToPos(Vector vecPos)": {
		"prefix": "NoFriendlyFireToPos",
		"body" : [ "NoFriendlyFireToPos( ${1:Vector vecPos} )" ],
		"description" : "Returns whether attacking the target location at this time would result in friendly fire"
	},
	"bool CGrenade::GetEnemy()": {
		"prefix": "GetEnemy",
		"body" : [ "GetEnemy()" ],
		"description" : "Tries to find the best suitable enemy for this monster."
	},
	"void CGrenade::GibMonster()": {
		"prefix": "GibMonster",
		"body" : [ "GibMonster()" ],
		"description" : "Gibs the monster."
	},
	"bool CGrenade::ShouldGibMonster(int iGib)": {
		"prefix": "ShouldGibMonster",
		"body" : [ "ShouldGibMonster( ${1:int iGib} )" ],
		"description" : "Returns whether the monster should be gibbed given the gib type. See GIB enum."
	},
	"void CGrenade::CallGibMonster()": {
		"prefix": "CallGibMonster",
		"body" : [ "CallGibMonster()" ],
		"description" : "Determines whether to gib or fade this monster, and acts accordingly."
	},
	"bool CGrenade::HasHumanGibs()": {
		"prefix": "HasHumanGibs",
		"body" : [ "HasHumanGibs()" ],
		"description" : "Returns whether this monster has human gibs."
	},
	"bool CGrenade::HasAlienGibs()": {
		"prefix": "HasAlienGibs",
		"body" : [ "HasAlienGibs()" ],
		"description" : "Returns whether this monster has alien gibs."
	},
	"void CGrenade::FadeMonster()": {
		"prefix": "FadeMonster",
		"body" : [ "FadeMonster()" ],
		"description" : "Fades this monster. Note: does not kill the monster."
	},
	"Vector CGrenade::ShootAtEnemy(const Vector& in vecShootOrigin)": {
		"prefix": "ShootAtEnemy",
		"body" : [ "ShootAtEnemy( ${1:const Vector& in vecShootOrigin} )" ],
		"description" : "Shoots at the specified location."
	},
	"void CGrenade::DeathSound()": {
		"prefix": "DeathSound",
		"body" : [ "DeathSound()" ],
		"description" : "Plays this monster's death sound."
	},
	"void CGrenade::AlertSound()": {
		"prefix": "AlertSound",
		"body" : [ "AlertSound()" ],
		"description" : "Plays this monster's alert sound."
	},
	"void CGrenade::IdleSound()": {
		"prefix": "IdleSound",
		"body" : [ "IdleSound()" ],
		"description" : "Plays this monster's idle sound."
	},
	"void CGrenade::PainSound()": {
		"prefix": "PainSound",
		"body" : [ "PainSound()" ],
		"description" : "Plays this monster's pain sound."
	},
	"void CGrenade::StartPlayerFollowing(CBaseEntity@ pLeader, bool bSilent = false)": {
		"prefix": "StartPlayerFollowing",
		"body" : [ "StartPlayerFollowing( ${1:CBaseEntity@ pLeader}, ${2:bool bSilent = false} )" ],
		"description" : "Starts following its target."
	},
	"void CGrenade::StopPlayerFollowing(const bool clearSchedule, bool bSilent = false)": {
		"prefix": "StopPlayerFollowing",
		"body" : [ "StopPlayerFollowing( ${1:const bool clearSchedule}, ${2:bool bSilent = false} )" ],
		"description" : "Stops following its target."
	},
	"void CGrenade::Remember(int iMemory)": {
		"prefix": "Remember",
		"body" : [ "Remember( ${1:int iMemory} )" ],
		"description" : "Makes this monster remember the given memories."
	},
	"void CGrenade::Forget(int iMemory)": {
		"prefix": "Forget",
		"body" : [ "Forget( ${1:int iMemory} )" ],
		"description" : "Makes this monster forget the given memories."
	},
	"bool CGrenade::HasMemory(int iMemory) const": {
		"prefix": "HasMemory",
		"body" : [ "HasMemory( ${1:int iMemory} )" ],
		"description" : "Returns whether this monster remembers any of the given memories."
	},
	"bool CGrenade::HasAllMemories(int iMemory) const": {
		"prefix": "HasAllMemories",
		"body" : [ "HasAllMemories( ${1:int iMemory} )" ],
		"description" : "Returns whether this monster remembers all of the given memories."
	},
	"bool CGrenade::ExitScriptedSequence()": {
		"prefix": "ExitScriptedSequence",
		"body" : [ "ExitScriptedSequence()" ],
		"description" : "Exits the scripted sequence this monster is currently in, if any."
	},
	"bool CGrenade::CineCleanup()": {
		"prefix": "CineCleanup",
		"body" : [ "CineCleanup()" ],
		"description" : "Cleans up after a cinematic event."
	},
	"CBaseEntity@ CGrenade::DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng)": {
		"prefix": "DropItem",
		"body" : [ "DropItem( ${1:const string& in szItemName}, ${2:const Vector& in vecPos}, ${3:const Vector& in vecAng} )" ],
		"description" : "Drops the given item from the given position at the given angle."
	},
	"void CGrenade::ShockGlowEffect(bool fMode)": {
		"prefix": "ShockGlowEffect",
		"body" : [ "ShockGlowEffect( ${1:bool fMode} )" ],
		"description" : "Turns the shock glow effect on or off."
	},
	"void CGrenade::FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)": {
		"prefix": "FollowerPlayerUse",
		"body" : [ "FollowerPlayerUse( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue} )" ],
		"description" : "Use method for following players (set only if friendly)"
	},
	"bool CGrenade::IsPlayerFollowing()": {
		"prefix": "IsPlayerFollowing",
		"body" : [ "IsPlayerFollowing()" ],
		"description" : "Returns whether this monster is following a player."
	},
	"bool CGrenade::CanPlayerFollow()": {
		"prefix": "CanPlayerFollow",
		"body" : [ "CanPlayerFollow()" ],
		"description" : "Returns whether this monster can follow a player."
	},
	"void CGrenade::StartPlayerFollowing(CBaseEntity@ pLeader)": {
		"prefix": "StartPlayerFollowing",
		"body" : [ "StartPlayerFollowing( ${1:CBaseEntity@ pLeader} )" ],
		"description" : "Starts following a given player."
	},
	"void CGrenade::StopPlayerFollowing(const bool bClearSchedule)": {
		"prefix": "StopPlayerFollowing",
		"body" : [ "StopPlayerFollowing( ${1:const bool bClearSchedule} )" ],
		"description" : "Stops following a player."
	},
	"string CGrenade::m_szTextureName()": {
		"prefix": "m_szTextureName",
		"body" : [ "m_szTextureName()" ],
		"description" : "Current texture name we're standing on."
	},
	"void CGrenade::MedicCallSound(float flDistance = 0.0f)": {
		"prefix": "MedicCallSound",
		"body" : [ "MedicCallSound( ${1:float flDistance = 0.0f} )" ],
		"description" : "Medic call sound."
	},
	"InventoryList@ CGrenade::get_m_pInventory() const": {
		"prefix": "get_m_pInventory",
		"body" : [ "get_m_pInventory()" ],
		"description" : "The inventory items this monster has"
	},
	"void CGrenade::ClearEnemyList()": {
		"prefix": "ClearEnemyList",
		"body" : [ "ClearEnemyList()" ],
		"description" : "Clears this monster's list of enemies"
	},
	"void CGrenade::ApplyEffects()": {
		"prefix": "ApplyEffects",
		"body" : [ "ApplyEffects()" ],
		"description" : "Re-calculate compounded effect modifiers and apply to the monster"
	},
	"void CGrenade::ResetEffects()": {
		"prefix": "ResetEffects",
		"body" : [ "ResetEffects()" ],
		"description" : "Reset all effect modifiers"
	},
	"void CGrenade::Explode(Vector vecSrc, Vector vecAim)": {
		"prefix": "Explode",
		"body" : [ "Explode( ${1:Vector vecSrc}, ${2:Vector vecAim} )" ],
		"description" : "Makes this grenade explode"
	},
	"entvars_t@ CGrenade::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CGrenade::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CGrenade::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CGrenade::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CGrenade::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CGrenade::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CGrenade::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CGrenade::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CGrenade::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CGrenade::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CGrenade::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CGrenade::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CGrenade::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CGrenade::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CGrenade::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CGrenade::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CGrenade::m_flDelay": {
		"prefix": "m_flDelay",
		"body" : [ "m_flDelay" ],
		"description" : "Delay before fire."
	},
	"string_t CGrenade::m_iszKillTarget": {
		"prefix": "m_iszKillTarget",
		"body" : [ "m_iszKillTarget" ],
		"description" : "The name of the kill target, if any."
	},
	"float CGrenade::m_flFrameRate": {
		"prefix": "m_flFrameRate",
		"body" : [ "m_flFrameRate" ],
		"description" : "Computed FPS for current sequence."
	},
	"float CGrenade::m_flGroundSpeed": {
		"prefix": "m_flGroundSpeed",
		"body" : [ "m_flGroundSpeed" ],
		"description" : "Computed linear movement rate for current sequence."
	},
	"float CGrenade::m_flLastEventCheck": {
		"prefix": "m_flLastEventCheck",
		"body" : [ "m_flLastEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"float CGrenade::m_flLastGaitEventCheck": {
		"prefix": "m_flLastGaitEventCheck",
		"body" : [ "m_flLastGaitEventCheck" ],
		"description" : "Last time the event list was checked."
	},
	"bool CGrenade::m_fSequenceFinished": {
		"prefix": "m_fSequenceFinished",
		"body" : [ "m_fSequenceFinished" ],
		"description" : "Flag set when StudioAdvanceFrame moves across a frame boundry."
	},
	"bool CGrenade::m_fSequenceLoops": {
		"prefix": "m_fSequenceLoops",
		"body" : [ "m_fSequenceLoops" ],
		"description" : "True if the sequence loops."
	},
	"TOGGLE_STATE CGrenade::m_toggle_state": {
		"prefix": "m_toggle_state",
		"body" : [ "m_toggle_state" ],
		"description" : "Current toggle state."
	},
	"float CGrenade::m_flMoveDistance": {
		"prefix": "m_flMoveDistance",
		"body" : [ "m_flMoveDistance" ],
		"description" : "How far a door should slide or rotate."
	},
	"float CGrenade::m_flWait": {
		"prefix": "m_flWait",
		"body" : [ "m_flWait" ],
		"description" : "How long to wait before resetting."
	},
	"float CGrenade::m_flLip": {
		"prefix": "m_flLip",
		"body" : [ "m_flLip" ],
		"description" : "How much to stick out of a wall. Will recede further into walls if negative."
	},
	"float CGrenade::m_flTWidth": {
		"prefix": "m_flTWidth",
		"body" : [ "m_flTWidth" ],
		"description" : "For plats."
	},
	"float CGrenade::m_flTLength": {
		"prefix": "m_flTLength",
		"body" : [ "m_flTLength" ],
		"description" : "For plats."
	},
	"int CGrenade::m_cTriggersLeft": {
		"prefix": "m_cTriggersLeft",
		"body" : [ "m_cTriggersLeft" ],
		"description" : "Trigger_counter only: # of activations remaining."
	},
	"float CGrenade::m_flHeight": {
		"prefix": "m_flHeight",
		"body" : [ "m_flHeight" ],
		"description" : "Height."
	},
	"EHandle CGrenade::m_hActivator": {
		"prefix": "m_hActivator",
		"body" : [ "m_hActivator" ],
		"description" : "Handle to the activator."
	},
	"Vector CGrenade::m_vecPosition1": {
		"prefix": "m_vecPosition1",
		"body" : [ "m_vecPosition1" ],
		"description" : "Closed position."
	},
	"Vector CGrenade::m_vecPosition2": {
		"prefix": "m_vecPosition2",
		"body" : [ "m_vecPosition2" ],
		"description" : "Open position."
	},
	"Vector CGrenade::m_vecAngle1": {
		"prefix": "m_vecAngle1",
		"body" : [ "m_vecAngle1" ],
		"description" : "Closed angle."
	},
	"Vector CGrenade::m_vecAngle2": {
		"prefix": "m_vecAngle2",
		"body" : [ "m_vecAngle2" ],
		"description" : "Open angle."
	},
	"Vector CGrenade::m_vecFinalDest": {
		"prefix": "m_vecFinalDest",
		"body" : [ "m_vecFinalDest" ],
		"description" : "Final destination."
	},
	"Vector CGrenade::m_vecFinalAngle": {
		"prefix": "m_vecFinalAngle",
		"body" : [ "m_vecFinalAngle" ],
		"description" : "Final angle."
	},
	"int CGrenade::m_bitsDamageInflict": {
		"prefix": "m_bitsDamageInflict",
		"body" : [ "m_bitsDamageInflict" ],
		"description" : "DMG_ damage type that the door or trigger does."
	},
	"string_t CGrenade::m_sMaster": {
		"prefix": "m_sMaster",
		"body" : [ "m_sMaster" ],
		"description" : "This entity's master, if any."
	},
	"EHandle CGrenade::m_hEnemy": {
		"prefix": "m_hEnemy",
		"body" : [ "m_hEnemy" ],
		"description" : "the entity that the monster is fighting."
	},
	"EHandle CGrenade::m_hTargetEnt": {
		"prefix": "m_hTargetEnt",
		"body" : [ "m_hTargetEnt" ],
		"description" : "the entity that the monster is trying to reach."
	},
	"EHandle CGrenade::m_hTargetTank": {
		"prefix": "m_hTargetTank",
		"body" : [ "m_hTargetTank" ],
		"description" : "Target tank to control."
	},
	"float CGrenade::m_flFieldOfView": {
		"prefix": "m_flFieldOfView",
		"body" : [ "m_flFieldOfView" ],
		"description" : "width of monster's field of view (dot product)."
	},
	"float CGrenade::m_flWaitFinished": {
		"prefix": "m_flWaitFinished",
		"body" : [ "m_flWaitFinished" ],
		"description" : "if we're told to wait, this is the time that the wait will be over."
	},
	"float CGrenade::m_flMoveWaitFinished": {
		"prefix": "m_flMoveWaitFinished",
		"body" : [ "m_flMoveWaitFinished" ],
		"description" : "if we're told to wait before moving, this is the time that the wait will be over."
	},
	"Activity CGrenade::m_Activity": {
		"prefix": "m_Activity",
		"body" : [ "m_Activity" ],
		"description" : "what the monster is doing (animation)."
	},
	"Activity CGrenade::m_IdealActivity": {
		"prefix": "m_IdealActivity",
		"body" : [ "m_IdealActivity" ],
		"description" : "monster should switch to this activity."
	},
	"Activity CGrenade::m_GaitActivity": {
		"prefix": "m_GaitActivity",
		"body" : [ "m_GaitActivity" ],
		"description" : "gaitsequence."
	},
	"int CGrenade::m_LastHitGroup": {
		"prefix": "m_LastHitGroup",
		"body" : [ "m_LastHitGroup" ],
		"description" : "the last body region that took damage."
	},
	"MONSTERSTATE CGrenade::m_MonsterState": {
		"prefix": "m_MonsterState",
		"body" : [ "m_MonsterState" ],
		"description" : "monster's current state."
	},
	"MONSTERSTATE CGrenade::m_IdealMonsterState": {
		"prefix": "m_IdealMonsterState",
		"body" : [ "m_IdealMonsterState" ],
		"description" : "monster should change to this state."
	},
	"int CGrenade::m_iTaskStatus": {
		"prefix": "m_iTaskStatus",
		"body" : [ "m_iTaskStatus" ],
		"description" : "Task status."
	},
	"Schedule@ CGrenade::m_pSchedule": {
		"prefix": "m_pSchedule",
		"body" : [ "m_pSchedule" ],
		"description" : "Current schedule."
	},
	"Schedule@ CGrenade::m_pScheduleSaved": {
		"prefix": "m_pScheduleSaved",
		"body" : [ "m_pScheduleSaved" ],
		"description" : "For land_on_ground schedules (remember last schedule and continue)."
	},
	"int CGrenade::m_iScheduleIndex": {
		"prefix": "m_iScheduleIndex",
		"body" : [ "m_iScheduleIndex" ],
		"description" : "Schedule index."
	},
	"int CGrenade::m_movementGoal": {
		"prefix": "m_movementGoal",
		"body" : [ "m_movementGoal" ],
		"description" : "Goal that defines route."
	},
	"int CGrenade::m_iRouteIndex": {
		"prefix": "m_iRouteIndex",
		"body" : [ "m_iRouteIndex" ],
		"description" : "Index into m_Route[]."
	},
	"float CGrenade::m_moveWaitTime": {
		"prefix": "m_moveWaitTime",
		"body" : [ "m_moveWaitTime" ],
		"description" : "How long I should wait for something to move."
	},
	"float CGrenade::m_moveradius": {
		"prefix": "m_moveradius",
		"body" : [ "m_moveradius" ],
		"description" : "Minimum radius."
	},
	"Vector CGrenade::m_vecMoveGoal": {
		"prefix": "m_vecMoveGoal",
		"body" : [ "m_vecMoveGoal" ],
		"description" : "Kept around for node graph moves, so we know our ultimate goal."
	},
	"Activity CGrenade::m_movementActivity": {
		"prefix": "m_movementActivity",
		"body" : [ "m_movementActivity" ],
		"description" : "When moving, set this activity."
	},
	"int CGrenade::m_iAudibleList": {
		"prefix": "m_iAudibleList",
		"body" : [ "m_iAudibleList" ],
		"description" : "first index of a linked list of sounds that the monster can hear."
	},
	"int CGrenade::m_afSoundTypes": {
		"prefix": "m_afSoundTypes",
		"body" : [ "m_afSoundTypes" ],
		"description" : "Sound types that can be heard."
	},
	"Vector CGrenade::m_vecLastPosition": {
		"prefix": "m_vecLastPosition",
		"body" : [ "m_vecLastPosition" ],
		"description" : "monster sometimes wants to return to where it started after an operation.."
	},
	"int CGrenade::m_iHintNode": {
		"prefix": "m_iHintNode",
		"body" : [ "m_iHintNode" ],
		"description" : "this is the hint node that the monster is moving towards or performing active idle on.."
	},
	"int CGrenade::m_afMemory": {
		"prefix": "m_afMemory",
		"body" : [ "m_afMemory" ],
		"description" : "Monster memory."
	},
	"int CGrenade::m_bloodColor": {
		"prefix": "m_bloodColor",
		"body" : [ "m_bloodColor" ],
		"description" : "color of blood particles."
	},
	"int CGrenade::m_iMaxHealth": {
		"prefix": "m_iMaxHealth",
		"body" : [ "m_iMaxHealth" ],
		"description" : "keeps track of monster's maximum health value (for re-healing, etc)."
	},
	"Vector CGrenade::m_vecEnemyLKP": {
		"prefix": "m_vecEnemyLKP",
		"body" : [ "m_vecEnemyLKP" ],
		"description" : "last known position of enemy. (enemy's origin)."
	},
	"int CGrenade::m_cAmmoLoaded": {
		"prefix": "m_cAmmoLoaded",
		"body" : [ "m_cAmmoLoaded" ],
		"description" : "how much ammo is in the weapon (used to trigger reload anim sequences)."
	},
	"int CGrenade::m_afCapability": {
		"prefix": "m_afCapability",
		"body" : [ "m_afCapability" ],
		"description" : "tells us what a monster can/can't do."
	},
	"int CGrenade::m_afMoveShootCap": {
		"prefix": "m_afMoveShootCap",
		"body" : [ "m_afMoveShootCap" ],
		"description" : "tells us what a monster can/can't do, while moving."
	},
	"float CGrenade::m_flNextAttack": {
		"prefix": "m_flNextAttack",
		"body" : [ "m_flNextAttack" ],
		"description" : "cannot attack again until this time."
	},
	"int CGrenade::m_bitsDamageType": {
		"prefix": "m_bitsDamageType",
		"body" : [ "m_bitsDamageType" ],
		"description" : "what types of damage has monster (player) taken."
	},
	"float CGrenade::m_lastDamageAmount": {
		"prefix": "m_lastDamageAmount",
		"body" : [ "m_lastDamageAmount" ],
		"description" : "how much damage did monster (player) last take."
	},
	"float CGrenade::m_tbdPrev": {
		"prefix": "m_tbdPrev",
		"body" : [ "m_tbdPrev" ],
		"description" : "Time-based damage timer."
	},
	"entvars_t@ CGrenade::pevTimeBasedInflictor": {
		"prefix": "pevTimeBasedInflictor",
		"body" : [ "pevTimeBasedInflictor" ],
		"description" : "Time based damage inflictor."
	},
	"int CGrenade::m_failSchedule": {
		"prefix": "m_failSchedule",
		"body" : [ "m_failSchedule" ],
		"description" : "Schedule type to choose if current schedule fails."
	},
	"float CGrenade::m_flHungryTime": {
		"prefix": "m_flHungryTime",
		"body" : [ "m_flHungryTime" ],
		"description" : "Time based damage inflictor."
	},
	"float CGrenade::m_flDistTooFar": {
		"prefix": "m_flDistTooFar",
		"body" : [ "m_flDistTooFar" ],
		"description" : "if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy."
	},
	"float CGrenade::m_flDistLook": {
		"prefix": "m_flDistLook",
		"body" : [ "m_flDistLook" ],
		"description" : "distance monster sees (Default 2048)."
	},
	"int CGrenade::m_iTriggerCondition": {
		"prefix": "m_iTriggerCondition",
		"body" : [ "m_iTriggerCondition" ],
		"description" : "for scripted AI, this is the condition that will cause the activation of the monster's TriggerTarget."
	},
	"string_t CGrenade::m_iszTriggerTarget": {
		"prefix": "m_iszTriggerTarget",
		"body" : [ "m_iszTriggerTarget" ],
		"description" : "Name of target that should be fired."
	},
	"Vector CGrenade::m_HackedGunPos": {
		"prefix": "m_HackedGunPos",
		"body" : [ "m_HackedGunPos" ],
		"description" : "HACK until we can query end of gun."
	},
	"SCRIPTSTATE CGrenade::m_scriptState": {
		"prefix": "m_scriptState",
		"body" : [ "m_scriptState" ],
		"description" : "internal cinematic state."
	},
	"EHandle CGrenade::m_hCine": {
		"prefix": "m_hCine",
		"body" : [ "m_hCine" ],
		"description" : "Cinematic entity."
	},
	"EHandle CGrenade::m_hCineBlocker": {
		"prefix": "m_hCineBlocker",
		"body" : [ "m_hCineBlocker" ],
		"description" : "Entity that is blocking cinematic execution."
	},
	"float CGrenade::m_useTime": {
		"prefix": "m_useTime",
		"body" : [ "m_useTime" ],
		"description" : "Don't allow +USE until this time."
	},
	"string_t CGrenade::m_FormattedName": {
		"prefix": "m_FormattedName",
		"body" : [ "m_FormattedName" ],
		"description" : "The formatted name. For better name outputs. E.g. \"Alien Slave\" rather than \"alien_slave\"."
	},
	"int8 CGrenade::m_chTextureType": {
		"prefix": "m_chTextureType",
		"body" : [ "m_chTextureType" ],
		"description" : "Current texture type. See TextureType enum."
	},
	"bool CGrenade::m_fCanFearCreatures": {
		"prefix": "m_fCanFearCreatures",
		"body" : [ "m_fCanFearCreatures" ],
		"description" : "Whether this monster can fear creatures."
	},
	"float CGrenade::m_flAutomaticAttackTime": {
		"prefix": "m_flAutomaticAttackTime",
		"body" : [ "m_flAutomaticAttackTime" ],
		"description" : "How long an npc will attempt to fire full auto."
	},
	"float CGrenade::m_flFallVelocity": {
		"prefix": "m_flFallVelocity",
		"body" : [ "m_flFallVelocity" ],
		"description" : "Current fall speed."
	},
	"EHandle CGrenade::m_hGuardEnt": {
		"prefix": "m_hGuardEnt",
		"body" : [ "m_hGuardEnt" ],
		"description" : "Monster will guard this entity and turn down follow requests."
	},
	"string_t CGrenade::m_iszGuardEntName": {
		"prefix": "m_iszGuardEntName",
		"body" : [ "m_iszGuardEntName" ],
		"description" : "Guard entity name."
	},
	"Vector CGrenade::m_vecEffectGlowColor": {
		"prefix": "m_vecEffectGlowColor",
		"body" : [ "m_vecEffectGlowColor" ],
		"description" : "Glow shell."
	},
	"int CGrenade::m_iEffectBlockWeapons": {
		"prefix": "m_iEffectBlockWeapons",
		"body" : [ "m_iEffectBlockWeapons" ],
		"description" : "Monster can't use weapons."
	},
	"int CGrenade::m_iEffectInvulnerable": {
		"prefix": "m_iEffectInvulnerable",
		"body" : [ "m_iEffectInvulnerable" ],
		"description" : "is invulnerable (god mode)"
	},
	"int CGrenade::m_iEffectInvisible": {
		"prefix": "m_iEffectInvisible",
		"body" : [ "m_iEffectInvisible" ],
		"description" : "is invisible (render + non-targetable)"
	},
	"int CGrenade::m_iEffectNonSolid": {
		"prefix": "m_iEffectNonSolid",
		"body" : [ "m_iEffectNonSolid" ],
		"description" : "is non-solid"
	},
	"float CGrenade::m_flEffectRespiration": {
		"prefix": "m_flEffectRespiration",
		"body" : [ "m_flEffectRespiration" ],
		"description" : "Extra/less breathing time underwater in seconds"
	},
	"float CGrenade::m_flEffectGravity": {
		"prefix": "m_flEffectGravity",
		"body" : [ "m_flEffectGravity" ],
		"description" : "Gravity modifier (%)"
	},
	"float CGrenade::m_flEffectFriction": {
		"prefix": "m_flEffectFriction",
		"body" : [ "m_flEffectFriction" ],
		"description" : "Movement friction modifier (%)"
	},
	"float CGrenade::m_flEffectSpeed": {
		"prefix": "m_flEffectSpeed",
		"body" : [ "m_flEffectSpeed" ],
		"description" : "Movement speed modifier (%)"
	},
	"float CGrenade::m_flEffectDamage": {
		"prefix": "m_flEffectDamage",
		"body" : [ "m_flEffectDamage" ],
		"description" : "Damage modifier (%)"
	},
	"void char::char()": {
		"prefix": "char",
		"body" : [ "char()" ],
		"description" : "Default constructor"
	},
	"void char::char(const char& in character)": {
		"prefix": "char",
		"body" : [ "char( ${1:const char& in character} )" ],
		"description" : "Copy constructor"
	},
	"void char::char(const string& in szString)": {
		"prefix": "char",
		"body" : [ "char( ${1:const string& in szString} )" ],
		"description" : "Copy constructor"
	},
	"char char::opAssign(const char& in character)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const char& in character} )" ],
		"description" : "Assigns one character to another."
	},
	"uint32 char::opImplConv() const": {
		"prefix": "opImplConv",
		"body" : [ "opImplConv()" ],
		"description" : "Implicitly converts this character to an unsigned 32 bit integer."
	},
	"char char::opAssign(const string& in szString)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const string& in szString} )" ],
		"description" : "Assigns the first character of the given string to this character."
	},
	"bool char::opEquals(const string& in szString) const": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:const string& in szString} )" ],
		"description" : "Compares this char with the given character."
	},
	"bool CInventoryMisc::IsValidInventoryHolder(CBaseEntity@ pOther)": {
		"prefix": "IsValidInventoryHolder",
		"body" : [ "IsValidInventoryHolder( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether the given entity is a valid inventory holder"
	},
	"bool CInventoryMisc::CheckTokenStringRule(const string& in szRule, const string& in szValue)": {
		"prefix": "CheckTokenStringRule",
		"body" : [ "CheckTokenStringRule( ${1:const string& in szRule}, ${2:const string& in szValue} )" ],
		"description" : "Returns whether the given value is in the given rule"
	},
	"int CInventoryMisc::Count(CBaseMonster@ pHolder)": {
		"prefix": "Count",
		"body" : [ "Count( ${1:CBaseMonster@ pHolder} )" ],
		"description" : "Counts the number of inventory items held by the given holder"
	},
	"float CInventoryMisc::GetWeight(CBaseMonster@ pHolder)": {
		"prefix": "GetWeight",
		"body" : [ "GetWeight( ${1:CBaseMonster@ pHolder} )" ],
		"description" : "Gets the total weight of all inventory items held by the given holder"
	},
	"int CInventoryMisc::ExistsInGroup(const string& in szGroup)": {
		"prefix": "ExistsInGroup",
		"body" : [ "ExistsInGroup( ${1:const string& in szGroup} )" ],
		"description" : "Counts all the existing items in a group"
	},
	"int CInventoryMisc::HaveNumFromGroup(CBaseMonster@ pHolder, const string& in szGroup)": {
		"prefix": "HaveNumFromGroup",
		"body" : [ "HaveNumFromGroup( ${1:CBaseMonster@ pHolder}, ${2:const string& in szGroup} )" ],
		"description" : "Returns count of how many items someone holds of a group"
	},
	"bool CInventoryMisc::HasAllInGroup(CBaseMonster@ pHolder, const string& in szGroup)": {
		"prefix": "HasAllInGroup",
		"body" : [ "HasAllInGroup( ${1:CBaseMonster@ pHolder}, ${2:const string& in szGroup} )" ],
		"description" : "Returns true if is holding all items of a group"
	},
	"void CInventoryMisc::RemoveAllFromHolder(CBaseMonster@ pHolder, const bool fDrop = false, const bool fBlockingWeaponsOnly = false, const bool fKeepOnRespawn = false)": {
		"prefix": "RemoveAllFromHolder",
		"body" : [ "RemoveAllFromHolder( ${1:CBaseMonster@ pHolder}, ${2:const bool fDrop = false}, ${3:const bool fBlockingWeaponsOnly = false}, ${4:const bool fKeepOnRespawn = false} )" ],
		"description" : "Clears all held inventory"
	},
	"CBaseEntity@ CItem::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CItem::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CItem::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CItem::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CItem::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CItem::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CItem::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CItem::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CItem::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CItem::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CItem::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CItem::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CItem::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CItem::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CItem::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CItem::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CItem::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CItem::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CItem::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CItem::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CItem::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CItem::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CItem::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CItem::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CItem::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CItem::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CItem::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CItem::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CItem::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CItem::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CItem::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CItem::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CItem::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CItem::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CItem::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CItem::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CItem::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CItem::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CItem::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CItem::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CItem::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CItem::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CItem::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CItem::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CItem::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CItem::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CItem::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CItem::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CItem::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CItem::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CItem::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CItem::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CItem::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CItem::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CItem::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CItem::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CItem::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CItem::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CItem::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CItem::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CItem::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CItem::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CItem::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CItem::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CItem::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CItem::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CItem::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CItem::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CItem::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CItem::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CItem::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CItem::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CItem::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CItem::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CItem::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CItem::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CItem::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CItem::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CItem::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CItem::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CItem::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CItem::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CItem::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CItem::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CItem::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CItem::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CItem::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CItem::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CItem::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CItem::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CItem::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CItem::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CItem::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CItem::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CItem::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CItem::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CItem::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CItem::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CItem::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CItem::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CItem::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CItem::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CItem::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CItem::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CItem::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CItem::ItemTouch(CBaseEntity@ pOther)": {
		"prefix": "ItemTouch",
		"body" : [ "ItemTouch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Item touch function"
	},
	"void CItem::Materialize()": {
		"prefix": "Materialize",
		"body" : [ "Materialize()" ],
		"description" : "Makes this entity visible and tangible."
	},
	"bool CItem::MyTouch(CBasePlayer@ pPlayer)": {
		"prefix": "MyTouch",
		"body" : [ "MyTouch( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "The item's touch function."
	},
	"entvars_t@ CItem::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CItem::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CItem::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CItem::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CItem::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CItem::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CItem::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CItem::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CItem::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CItem::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CItem::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CItem::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CItem::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CItem::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CItem::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CItem::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"CBaseEntity@ CItemInventory::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CItemInventory::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CItemInventory::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CItemInventory::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CItemInventory::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CItemInventory::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CItemInventory::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CItemInventory::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CItemInventory::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CItemInventory::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CItemInventory::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CItemInventory::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CItemInventory::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CItemInventory::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CItemInventory::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CItemInventory::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CItemInventory::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CItemInventory::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CItemInventory::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CItemInventory::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CItemInventory::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CItemInventory::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CItemInventory::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CItemInventory::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CItemInventory::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CItemInventory::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CItemInventory::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CItemInventory::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CItemInventory::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CItemInventory::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CItemInventory::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CItemInventory::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CItemInventory::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CItemInventory::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CItemInventory::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CItemInventory::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CItemInventory::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CItemInventory::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CItemInventory::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CItemInventory::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CItemInventory::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CItemInventory::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CItemInventory::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CItemInventory::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CItemInventory::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CItemInventory::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CItemInventory::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CItemInventory::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CItemInventory::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CItemInventory::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CItemInventory::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CItemInventory::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CItemInventory::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CItemInventory::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CItemInventory::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CItemInventory::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CItemInventory::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CItemInventory::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CItemInventory::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CItemInventory::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CItemInventory::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CItemInventory::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CItemInventory::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CItemInventory::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CItemInventory::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CItemInventory::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CItemInventory::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CItemInventory::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CItemInventory::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CItemInventory::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CItemInventory::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CItemInventory::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CItemInventory::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CItemInventory::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CItemInventory::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CItemInventory::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CItemInventory::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CItemInventory::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CItemInventory::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CItemInventory::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CItemInventory::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CItemInventory::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CItemInventory::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CItemInventory::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CItemInventory::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CItemInventory::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CItemInventory::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CItemInventory::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CItemInventory::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CItemInventory::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CItemInventory::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CItemInventory::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CItemInventory::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CItemInventory::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CItemInventory::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CItemInventory::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CItemInventory::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CItemInventory::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CItemInventory::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CItemInventory::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CItemInventory::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CItemInventory::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CItemInventory::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CItemInventory::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CItemInventory::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"bool CItemInventory::CanCollect(CBaseEntity@ pOther)": {
		"prefix": "CanCollect",
		"body" : [ "CanCollect( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this item can be collected by the given entity."
	},
	"bool CItemInventory::Drop(bool fForce = false, CBaseEntity@ pCaller = null)": {
		"prefix": "Drop",
		"body" : [ "Drop( ${1:bool fForce = false}, ${2:CBaseEntity@ pCaller = null} )" ],
		"description" : "Drops this item, if it's being carried."
	},
	"void CItemInventory::Return()": {
		"prefix": "Return",
		"body" : [ "Return()" ],
		"description" : "Returns this item to its original spawn location."
	},
	"void CItemInventory::Destroy()": {
		"prefix": "Destroy",
		"body" : [ "Destroy()" ],
		"description" : "Destroys this item."
	},
	"void CItemInventory::AddItemEffects()": {
		"prefix": "AddItemEffects",
		"body" : [ "AddItemEffects()" ],
		"description" : "Prepares to add effects to holder."
	},
	"void CItemInventory::RemoveItemEffects()": {
		"prefix": "RemoveItemEffects",
		"body" : [ "RemoveItemEffects()" ],
		"description" : "Prepares to remove effects from holder."
	},
	"entvars_t@ CItemInventory::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CItemInventory::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CItemInventory::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CItemInventory::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CItemInventory::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CItemInventory::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CItemInventory::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CItemInventory::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CItemInventory::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CItemInventory::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CItemInventory::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CItemInventory::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CItemInventory::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CItemInventory::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CItemInventory::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CItemInventory::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"EHandle CItemInventory::m_hHolder": {
		"prefix": "m_hHolder",
		"body" : [ "m_hHolder" ],
		"description" : "The monster or player holding this item."
	},
	"Vector CItemInventory::m_vecSpawnOrigin": {
		"prefix": "m_vecSpawnOrigin",
		"body" : [ "m_vecSpawnOrigin" ],
		"description" : "Spawn-time origin."
	},
	"Vector CItemInventory::m_vecSpawnAngles": {
		"prefix": "m_vecSpawnAngles",
		"body" : [ "m_vecSpawnAngles" ],
		"description" : "Spawn-time angles."
	},
	"int CItemInventory::m_iMoveType": {
		"prefix": "m_iMoveType",
		"body" : [ "m_iMoveType" ],
		"description" : "Spawn-time move type."
	},
	"string_t CItemInventory::m_szItemName": {
		"prefix": "m_szItemName",
		"body" : [ "m_szItemName" ],
		"description" : "Item name referred to by triggers, doesn't need to be unique -- remember the targetname refers to the entity itself only."
	},
	"string_t CItemInventory::m_szItemGroup": {
		"prefix": "m_szItemGroup",
		"body" : [ "m_szItemGroup" ],
		"description" : "Group name referred to by triggers."
	},
	"string CItemInventory::m_szDisplayName": {
		"prefix": "m_szDisplayName",
		"body" : [ "m_szDisplayName" ],
		"description" : "Friendly item name for client-side UI."
	},
	"string_t CItemInventory::m_szDescription": {
		"prefix": "m_szDescription",
		"body" : [ "m_szDescription" ],
		"description" : "Friendly item description for client-side UI."
	},
	"int CItemInventory::m_iCollectLimit": {
		"prefix": "m_iCollectLimit",
		"body" : [ "m_iCollectLimit" ],
		"description" : "How many times the item can be picked up, destroyed when limit is reached (0 = infinite)."
	},
	"float CItemInventory::m_flWeight": {
		"prefix": "m_flWeight",
		"body" : [ "m_flWeight" ],
		"description" : "How heavy the item is (0-100),. holders can hold multiple items up to a total weight 100, think of this as KG if you like (though what person can carry 100KG!?)."
	},
	"bool CItemInventory::m_fHiddenWhenCarried": {
		"prefix": "m_fHiddenWhenCarried",
		"body" : [ "m_fHiddenWhenCarried" ],
		"description" : "Model is hidden while it is being carried."
	},
	"int CItemInventory::m_iIdleSkin": {
		"prefix": "m_iIdleSkin",
		"body" : [ "m_iIdleSkin" ],
		"description" : "Model skin while IDLE (not carried)."
	},
	"int CItemInventory::m_iIdleBody": {
		"prefix": "m_iIdleBody",
		"body" : [ "m_iIdleBody" ],
		"description" : "Model body while IDLE."
	},
	"string_t CItemInventory::m_szIdleSequenceName": {
		"prefix": "m_szIdleSequenceName",
		"body" : [ "m_szIdleSequenceName" ],
		"description" : "Model sequence name while IDLE."
	},
	"int CItemInventory::m_iIdleSequence": {
		"prefix": "m_iIdleSequence",
		"body" : [ "m_iIdleSequence" ],
		"description" : "Model sequence number while IDLE."
	},
	"int CItemInventory::m_iCarriedSkin": {
		"prefix": "m_iCarriedSkin",
		"body" : [ "m_iCarriedSkin" ],
		"description" : "Model skin while CARRIED."
	},
	"int CItemInventory::m_iCarriedBody": {
		"prefix": "m_iCarriedBody",
		"body" : [ "m_iCarriedBody" ],
		"description" : "Model body while CARRIED."
	},
	"string_t CItemInventory::m_szCarriedSequenceName": {
		"prefix": "m_szCarriedSequenceName",
		"body" : [ "m_szCarriedSequenceName" ],
		"description" : "Model sequence name while CARRIED."
	},
	"int CItemInventory::m_iCarriedSequence": {
		"prefix": "m_iCarriedSequence",
		"body" : [ "m_iCarriedSequence" ],
		"description" : "Model sequence number while CARRIED."
	},
	"string_t CItemInventory::m_szAllowedTargetNames": {
		"prefix": "m_szAllowedTargetNames",
		"body" : [ "m_szAllowedTargetNames" ],
		"description" : "CBaseEntity target name filters"
	},
	"string_t CItemInventory::m_szAllowedClassNames": {
		"prefix": "m_szAllowedClassNames",
		"body" : [ "m_szAllowedClassNames" ],
		"description" : "CBaseEntity class name filters"
	},
	"string_t CItemInventory::m_szAllowedTeams": {
		"prefix": "m_szAllowedTeams",
		"body" : [ "m_szAllowedTeams" ],
		"description" : "Team filters"
	},
	"int CItemInventory::m_iAllowedNpcClassify": {
		"prefix": "m_iAllowedNpcClassify",
		"body" : [ "m_iAllowedNpcClassify" ],
		"description" : "NPC classification filter"
	},
	"string_t CItemInventory::m_szRequiresItemName": {
		"prefix": "m_szRequiresItemName",
		"body" : [ "m_szRequiresItemName" ],
		"description" : "Require these item(s)"
	},
	"string_t CItemInventory::m_szRequiresItemGroup": {
		"prefix": "m_szRequiresItemGroup",
		"body" : [ "m_szRequiresItemGroup" ],
		"description" : "Require an item from these group(s)"
	},
	"int CItemInventory::m_iRequiresItemGroupNum": {
		"prefix": "m_iRequiresItemGroupNum",
		"body" : [ "m_iRequiresItemGroupNum" ],
		"description" : "Number of item(s) from the required group(s) required (0 = all)"
	},
	"string_t CItemInventory::m_szItemNameMoved": {
		"prefix": "m_szItemNameMoved",
		"body" : [ "m_szItemNameMoved" ],
		"description" : "These item(s) must have moved"
	},
	"string_t CItemInventory::m_szCantHaveItemName": {
		"prefix": "m_szCantHaveItemName",
		"body" : [ "m_szCantHaveItemName" ],
		"description" : "Must not have these item(s)"
	},
	"string_t CItemInventory::m_szCantHaveItemGroup": {
		"prefix": "m_szCantHaveItemGroup",
		"body" : [ "m_szCantHaveItemGroup" ],
		"description" : "Must not have an item in these group(s)"
	},
	"int CItemInventory::m_iCantHaveItemGroupNum": {
		"prefix": "m_iCantHaveItemGroupNum",
		"body" : [ "m_iCantHaveItemGroupNum" ],
		"description" : "Number of item(s) from the can't have group(s) (0 = all)"
	},
	"string_t CItemInventory::m_szItemNameNotMoved": {
		"prefix": "m_szItemNameNotMoved",
		"body" : [ "m_szItemNameNotMoved" ],
		"description" : "These item(s) must NOT have moved"
	},
	"float CItemInventory::m_flMaximumHoldTime": {
		"prefix": "m_flMaximumHoldTime",
		"body" : [ "m_flMaximumHoldTime" ],
		"description" : "Limit to how long this item can be held for, forcibly dropped after (0 = no limit)"
	},
	"float CItemInventory::m_flWearOutTime": {
		"prefix": "m_flWearOutTime",
		"body" : [ "m_flWearOutTime" ],
		"description" : "Perform a trigger prior to this item being forcibly dropped (0 = none)"
	},
	"bool CItemInventory::m_fCanBeDropped": {
		"prefix": "m_fCanBeDropped",
		"body" : [ "m_fCanBeDropped" ],
		"description" : "Holder is allowed to drop this item by choice"
	},
	"float CItemInventory::m_flReturnTime": {
		"prefix": "m_flReturnTime",
		"body" : [ "m_flReturnTime" ],
		"description" : "How long this item returns to its' original location when dropped (-1 = never, 0 = instant)"
	},
	"bool CItemInventory::m_fDelayedRespawn": {
		"prefix": "m_fDelayedRespawn",
		"body" : [ "m_fDelayedRespawn" ],
		"description" : "Delayed respawn on return (like with weapons/ammo/pickups)"
	},
	"bool CItemInventory::m_fKeepOnDeath": {
		"prefix": "m_fKeepOnDeath",
		"body" : [ "m_fKeepOnDeath" ],
		"description" : "Holder still has the item after dying (i.e. so they can keep it while being revived)"
	},
	"bool CItemInventory::m_fKeepOnRespawn": {
		"prefix": "m_fKeepOnRespawn",
		"body" : [ "m_fKeepOnRespawn" ],
		"description" : "Holder still has the item after respawning (only applies to players -- re-equip NPC's manually)"
	},
	"string_t CItemInventory::m_szTriggerOnCollectSelf": {
		"prefix": "m_szTriggerOnCollectSelf",
		"body" : [ "m_szTriggerOnCollectSelf" ],
		"description" : "On successful collection (for collector)"
	},
	"string_t CItemInventory::m_szTriggerOnCollectTeam": {
		"prefix": "m_szTriggerOnCollectTeam",
		"body" : [ "m_szTriggerOnCollectTeam" ],
		"description" : "On successful collection (for collector's team)"
	},
	"string_t CItemInventory::m_szTriggerOnCollectOther": {
		"prefix": "m_szTriggerOnCollectOther",
		"body" : [ "m_szTriggerOnCollectOther" ],
		"description" : "On successful collection (for everyone else)"
	},
	"string_t CItemInventory::m_szTriggerOnCantCollectSelf": {
		"prefix": "m_szTriggerOnCantCollectSelf",
		"body" : [ "m_szTriggerOnCantCollectSelf" ],
		"description" : "On failed collection (for collector)"
	},
	"string_t CItemInventory::m_szTriggerOnCantCollectTeam": {
		"prefix": "m_szTriggerOnCantCollectTeam",
		"body" : [ "m_szTriggerOnCantCollectTeam" ],
		"description" : "On failed collection (for collector's team)"
	},
	"string_t CItemInventory::m_szTriggerOnCantCollectOther": {
		"prefix": "m_szTriggerOnCantCollectOther",
		"body" : [ "m_szTriggerOnCantCollectOther" ],
		"description" : "On failed collection (for everyone else)"
	},
	"string_t CItemInventory::m_szTriggerOnDropSelf": {
		"prefix": "m_szTriggerOnDropSelf",
		"body" : [ "m_szTriggerOnDropSelf" ],
		"description" : "On successful drop (for collector)"
	},
	"string_t CItemInventory::m_szTriggerOnDropTeam": {
		"prefix": "m_szTriggerOnDropTeam",
		"body" : [ "m_szTriggerOnDropTeam" ],
		"description" : "On successful drop (for collector's team)"
	},
	"string_t CItemInventory::m_szTriggerOnDropOther": {
		"prefix": "m_szTriggerOnDropOther",
		"body" : [ "m_szTriggerOnDropOther" ],
		"description" : "On successful drop (for everyone else)"
	},
	"string_t CItemInventory::m_szTriggerOnCantDropSelf": {
		"prefix": "m_szTriggerOnCantDropSelf",
		"body" : [ "m_szTriggerOnCantDropSelf" ],
		"description" : "On failed drop (for collector)"
	},
	"string_t CItemInventory::m_szTriggerOnCantDropTeam": {
		"prefix": "m_szTriggerOnCantDropTeam",
		"body" : [ "m_szTriggerOnCantDropTeam" ],
		"description" : "On failed drop (for collector's team)"
	},
	"string_t CItemInventory::m_szTriggerOnCantDropOther": {
		"prefix": "m_szTriggerOnCantDropOther",
		"body" : [ "m_szTriggerOnCantDropOther" ],
		"description" : "On failed drop (for everyone else)"
	},
	"string_t CItemInventory::m_szTriggerOnUseSelf": {
		"prefix": "m_szTriggerOnUseSelf",
		"body" : [ "m_szTriggerOnUseSelf" ],
		"description" : "On use by trigger (for collector)"
	},
	"string_t CItemInventory::m_szTriggerOnUseTeam": {
		"prefix": "m_szTriggerOnUseTeam",
		"body" : [ "m_szTriggerOnUseTeam" ],
		"description" : "On use by trigger (for collector's team)"
	},
	"string_t CItemInventory::m_szTriggerOnUseOther": {
		"prefix": "m_szTriggerOnUseOther",
		"body" : [ "m_szTriggerOnUseOther" ],
		"description" : "On use by trigger (for everyone else)"
	},
	"string_t CItemInventory::m_szTriggerOnWearingOutSelf": {
		"prefix": "m_szTriggerOnWearingOutSelf",
		"body" : [ "m_szTriggerOnWearingOutSelf" ],
		"description" : "On wearing out (for collector)"
	},
	"string_t CItemInventory::m_szTriggerOnWearingOutTeam": {
		"prefix": "m_szTriggerOnWearingOutTeam",
		"body" : [ "m_szTriggerOnWearingOutTeam" ],
		"description" : "On wearing out (for collector's team)"
	},
	"string_t CItemInventory::m_szTriggerOnWearingOutOther": {
		"prefix": "m_szTriggerOnWearingOutOther",
		"body" : [ "m_szTriggerOnWearingOutOther" ],
		"description" : "On wearing out (for everyone else)"
	},
	"string_t CItemInventory::m_szTriggerOnReturnSelf": {
		"prefix": "m_szTriggerOnReturnSelf",
		"body" : [ "m_szTriggerOnReturnSelf" ],
		"description" : "On return (for collector)"
	},
	"string_t CItemInventory::m_szTriggerOnReturnTeam": {
		"prefix": "m_szTriggerOnReturnTeam",
		"body" : [ "m_szTriggerOnReturnTeam" ],
		"description" : "On return (for collector's team)"
	},
	"string_t CItemInventory::m_szTriggerOnReturnOther": {
		"prefix": "m_szTriggerOnReturnOther",
		"body" : [ "m_szTriggerOnReturnOther" ],
		"description" : "On return (for everyone else)"
	},
	"string_t CItemInventory::m_szTriggerOnMaterialise": {
		"prefix": "m_szTriggerOnMaterialise",
		"body" : [ "m_szTriggerOnMaterialise" ],
		"description" : "On materialise after return"
	},
	"string_t CItemInventory::m_szTriggerOnDestroy": {
		"prefix": "m_szTriggerOnDestroy",
		"body" : [ "m_szTriggerOnDestroy" ],
		"description" : "On destroy"
	},
	"bool CItemInventory::m_fEffectsPermanent": {
		"prefix": "m_fEffectsPermanent",
		"body" : [ "m_fEffectsPermanent" ],
		"description" : "Holder keeps effects after dropping the item"
	},
	"Vector CItemInventory::m_vecEffectGlowColor": {
		"prefix": "m_vecEffectGlowColor",
		"body" : [ "m_vecEffectGlowColor" ],
		"description" : "Holder has a glow shell"
	},
	"bool CItemInventory::m_fEffectBlockWeapons": {
		"prefix": "m_fEffectBlockWeapons",
		"body" : [ "m_fEffectBlockWeapons" ],
		"description" : "Holder can't use weapons"
	},
	"bool CItemInventory::m_fEffectInvulnerable": {
		"prefix": "m_fEffectInvulnerable",
		"body" : [ "m_fEffectInvulnerable" ],
		"description" : "Holder is invulnerable (god mode)"
	},
	"bool CItemInventory::m_fEffectInvisible": {
		"prefix": "m_fEffectInvisible",
		"body" : [ "m_fEffectInvisible" ],
		"description" : "Holder is invisible (render + non-targetable)"
	},
	"bool CItemInventory::m_fEffectNonSolid": {
		"prefix": "m_fEffectNonSolid",
		"body" : [ "m_fEffectNonSolid" ],
		"description" : "Holder is non-solid"
	},
	"float CItemInventory::m_flEffectRespiration": {
		"prefix": "m_flEffectRespiration",
		"body" : [ "m_flEffectRespiration" ],
		"description" : "Extra/less breathing time underwater in seconds"
	},
	"float CItemInventory::m_flEffectGravity": {
		"prefix": "m_flEffectGravity",
		"body" : [ "m_flEffectGravity" ],
		"description" : "Gravity modifier (%)"
	},
	"float CItemInventory::m_flEffectFriction": {
		"prefix": "m_flEffectFriction",
		"body" : [ "m_flEffectFriction" ],
		"description" : "Movement friction modifier (%)"
	},
	"float CItemInventory::m_flEffectSpeed": {
		"prefix": "m_flEffectSpeed",
		"body" : [ "m_flEffectSpeed" ],
		"description" : "Movement speed modifier (%)"
	},
	"float CItemInventory::m_flEffectDamage": {
		"prefix": "m_flEffectDamage",
		"body" : [ "m_flEffectDamage" ],
		"description" : "Damage modifier (%)"
	},
	"int CItemInventory::m_iCollectCount": {
		"prefix": "m_iCollectCount",
		"body" : [ "m_iCollectCount" ],
		"description" : "Number of times the item has been collected"
	},
	"float CItemInventory::m_flTouchedTime": {
		"prefix": "m_flTouchedTime",
		"body" : [ "m_flTouchedTime" ],
		"description" : "Time the item was last touched"
	},
	"float CItemInventory::m_flCollectTime": {
		"prefix": "m_flCollectTime",
		"body" : [ "m_flCollectTime" ],
		"description" : "Time the item was last collected"
	},
	"float CItemInventory::m_flDropTime": {
		"prefix": "m_flDropTime",
		"body" : [ "m_flDropTime" ],
		"description" : "Time the item was last dropped"
	},
	"bool CItemInventory::m_fRemovedByForced": {
		"prefix": "m_fRemovedByForced",
		"body" : [ "m_fRemovedByForced" ],
		"description" : "Item was just removed by force"
	},
	"int CItemRegistry::GetIdForName(const string& in szName) const": {
		"prefix": "GetIdForName",
		"body" : [ "GetIdForName( ${1:const string& in szName} )" ],
		"description" : "Gets the id associated with the given weapon name. Returns WEAPON_NONE if no id is associated with the given name."
	},
	"int CItemRegistry::RegisterItem(const string& in szName, const string& in szSpriteDir, const string& in szPrimaryAmmoName = \"\", const string& in szSecondaryAmmoName = \"\", const string& in szPrimaryAmmoClass = \"\", const string& in szSecondaryAmmoClass = \"\")": {
		"prefix": "RegisterItem",
		"body" : [ "RegisterItem( ${1:const string& in szName}, ${2:const string& in szSpriteDir}, ${3:const string& in szPrimaryAmmoName = \"\"}, ${4:const string& in szSecondaryAmmoName = \"\"}, ${5:const string& in szPrimaryAmmoClass = \"\"}, ${6:const string& in szSecondaryAmmoClass = \"\"} )" ],
		"description" : "Registers the given entity name as an item and returns the id associated with it. Returns WEAPON_NONE if no id could be assigned to it."
	},
	"int CItemRegistry::RegisterWeapon(const string& in szName, const string& in szSpriteDir, const string& in szPrimaryAmmoName = \"\", const string& in szSecondaryAmmoName = \"\", const string& in szPrimaryAmmoClass = \"\", const string& in szSecondaryAmmoClass = \"\")": {
		"prefix": "RegisterWeapon",
		"body" : [ "RegisterWeapon( ${1:const string& in szName}, ${2:const string& in szSpriteDir}, ${3:const string& in szPrimaryAmmoName = \"\"}, ${4:const string& in szSecondaryAmmoName = \"\"}, ${5:const string& in szPrimaryAmmoClass = \"\"}, ${6:const string& in szSecondaryAmmoClass = \"\"} )" ],
		"description" : "Registers the given entity name as a weapon and returns the id associated with it. Returns WEAPON_NONE if no id could be assigned to it."
	},
	"CBeam@ CLaser::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"CBaseEntity@ CLaser::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CLaser::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CLaser::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CLaser::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CLaser::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CLaser::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CLaser::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CLaser::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CLaser::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CLaser::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CLaser::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CLaser::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CLaser::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CLaser::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CLaser::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CLaser::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CLaser::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CLaser::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CLaser::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CLaser::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CLaser::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CLaser::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CLaser::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CLaser::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CLaser::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CLaser::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CLaser::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CLaser::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CLaser::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CLaser::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CLaser::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CLaser::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CLaser::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CLaser::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CLaser::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CLaser::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CLaser::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CLaser::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CLaser::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CLaser::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CLaser::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CLaser::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CLaser::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CLaser::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CLaser::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CLaser::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CLaser::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CLaser::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CLaser::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CLaser::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CLaser::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CLaser::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CLaser::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CLaser::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CLaser::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CLaser::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CLaser::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CLaser::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CLaser::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CLaser::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CLaser::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CLaser::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CLaser::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CLaser::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CLaser::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CLaser::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CLaser::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CLaser::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CLaser::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CLaser::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CLaser::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CLaser::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CLaser::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CLaser::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CLaser::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CLaser::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CLaser::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CLaser::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CLaser::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CLaser::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CLaser::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CLaser::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CLaser::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CLaser::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CLaser::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CLaser::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CLaser::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CLaser::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CLaser::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CLaser::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CLaser::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CLaser::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CLaser::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CLaser::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CLaser::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CLaser::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CLaser::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CLaser::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CLaser::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CLaser::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CLaser::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CLaser::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CLaser::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CLaser::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CLaser::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CLaser::SetType(BeamType type)": {
		"prefix": "SetType",
		"body" : [ "SetType( ${1:BeamType type} )" ],
		"description" : "Sets the type of the beam."
	},
	"void CLaser::SetFlags(int flags)": {
		"prefix": "SetFlags",
		"body" : [ "SetFlags( ${1:int flags} )" ],
		"description" : "Sets the flags of the beam. Must be a combination of BeamFlags values, or 0."
	},
	"void CLaser::SetStartPos(const Vector& in vecPos)": {
		"prefix": "SetStartPos",
		"body" : [ "SetStartPos( ${1:const Vector& in vecPos} )" ],
		"description" : "Sets the starting position of the beam. Must be a beam of type BEAM_POINTS, BEAM_ENTPOINT or BEAM_HOSE."
	},
	"void CLaser::SetEndPos(const Vector& in vecPos)": {
		"prefix": "SetEndPos",
		"body" : [ "SetEndPos( ${1:const Vector& in vecPos} )" ],
		"description" : "Sets the ending position of the beam. Must be a beam of type BEAM_POINTS or BEAM_HOSE."
	},
	"void CLaser::SetStartEntity(int entityIndex)": {
		"prefix": "SetStartEntity",
		"body" : [ "SetStartEntity( ${1:int entityIndex} )" ],
		"description" : "Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS."
	},
	"void CLaser::SetStartEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetStartEntity",
		"body" : [ "SetStartEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS."
	},
	"void CLaser::SetEndEntity(int entityIndex)": {
		"prefix": "SetEndEntity",
		"body" : [ "SetEndEntity( ${1:int entityIndex} )" ],
		"description" : "Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT."
	},
	"void CLaser::SetEndEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetEndEntity",
		"body" : [ "SetEndEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT."
	},
	"void CLaser::SetStartAttachment(int attachment)": {
		"prefix": "SetStartAttachment",
		"body" : [ "SetStartAttachment( ${1:int attachment} )" ],
		"description" : "Sets the start attachment of the beam. Attachment is a point on the entity's model. Must be a beam of type BEAM_ENTS. Set to 0 to disable."
	},
	"void CLaser::SetEndAttachment(int attachment)": {
		"prefix": "SetEndAttachment",
		"body" : [ "SetEndAttachment( ${1:int attachment} )" ],
		"description" : "Sets the end attachment of the beam. Attachment is a point on the entity's model. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT. Set to 0 to disable."
	},
	"void CLaser::SetTexture(int spriteIndex)": {
		"prefix": "SetTexture",
		"body" : [ "SetTexture( ${1:int spriteIndex} )" ],
		"description" : "Sets the sprite to use. The index is the one returned from CGame::PrecacheModel."
	},
	"void CLaser::SetWidth(int iWidth)": {
		"prefix": "SetWidth",
		"body" : [ "SetWidth( ${1:int iWidth} )" ],
		"description" : "Sets the width of the beam."
	},
	"void CLaser::SetNoise(int iAmplitude)": {
		"prefix": "SetNoise",
		"body" : [ "SetNoise( ${1:int iAmplitude} )" ],
		"description" : "Sets the noise (amplitude) of the beam."
	},
	"void CLaser::SetColor(int r, int g, int b)": {
		"prefix": "SetColor",
		"body" : [ "SetColor( ${1:int r}, ${2:int g}, ${3:int b} )" ],
		"description" : "Sets the color of the beam."
	},
	"void CLaser::SetBrightness(int brightness)": {
		"prefix": "SetBrightness",
		"body" : [ "SetBrightness( ${1:int brightness} )" ],
		"description" : "Sets the brightness of the beam. Value is between 0-255."
	},
	"void CLaser::SetFrame(float frame)": {
		"prefix": "SetFrame",
		"body" : [ "SetFrame( ${1:float frame} )" ],
		"description" : "Sets the frame number of the beam."
	},
	"void CLaser::SetScrollRate(int speed)": {
		"prefix": "SetScrollRate",
		"body" : [ "SetScrollRate( ${1:int speed} )" ],
		"description" : "Sets the scroll rate of the beam."
	},
	"const Vector& CLaser::GetStartPos()": {
		"prefix": "GetStartPos",
		"body" : [ "GetStartPos()" ],
		"description" : "Gets the beam's starting position."
	},
	"const Vector& CLaser::GetEndPos()": {
		"prefix": "GetEndPos",
		"body" : [ "GetEndPos()" ],
		"description" : "Gets the beam's ending position."
	},
	"int CLaser::GetTexture()": {
		"prefix": "GetTexture",
		"body" : [ "GetTexture()" ],
		"description" : "Gets the beam's texture (sprite) index."
	},
	"int CLaser::GetWidth()": {
		"prefix": "GetWidth",
		"body" : [ "GetWidth()" ],
		"description" : "Gets the beam's width."
	},
	"int CLaser::GetNoise()": {
		"prefix": "GetNoise",
		"body" : [ "GetNoise()" ],
		"description" : "Gets the beam's noise."
	},
	"void CLaser::GetColor(int& out r, int& out g, int& out b)": {
		"prefix": "GetColor",
		"body" : [ "GetColor( ${1:int& out r}, ${2:int& out g}, ${3:int& out b} )" ],
		"description" : "Gets the beam's color."
	},
	"int CLaser::GetBrightness()": {
		"prefix": "GetBrightness",
		"body" : [ "GetBrightness()" ],
		"description" : "Gets the beam's brightness."
	},
	"int CLaser::GetFrame()": {
		"prefix": "GetFrame",
		"body" : [ "GetFrame()" ],
		"description" : "Gets the beam's frame number."
	},
	"int CLaser::GetScrollRate()": {
		"prefix": "GetScrollRate",
		"body" : [ "GetScrollRate()" ],
		"description" : "Gets the beam's scroll rate."
	},
	"void CLaser::RelinkBeam()": {
		"prefix": "RelinkBeam",
		"body" : [ "RelinkBeam()" ],
		"description" : "Call after you change start/end positions."
	},
	"void CLaser::DoSparks(const Vector& in vecStart, const Vector& in vecEnd)": {
		"prefix": "DoSparks",
		"body" : [ "DoSparks( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd} )" ],
		"description" : "Creates sparks at the given start and end points, if appropriate spawn flags are set."
	},
	"void CLaser::BeamDamage(TraceResult& in tr)": {
		"prefix": "BeamDamage",
		"body" : [ "BeamDamage( ${1:TraceResult& in tr} )" ],
		"description" : "Damages the entity hit by the given trace line with the amount set in this entity's pev->dmg variable. Also applies decals to BSP models if the appropriate spawnflag is set."
	},
	"void CLaser::BeamInit(const string& in szSpriteName, int iWidth)": {
		"prefix": "BeamInit",
		"body" : [ "BeamInit( ${1:const string& in szSpriteName}, ${2:int iWidth} )" ],
		"description" : "Initializes this beam with default values and sets the given sprite as the sprite used, with the given width."
	},
	"void CLaser::PointsInit(const Vector& in vecStart, const Vector& in vecEnd)": {
		"prefix": "PointsInit",
		"body" : [ "PointsInit( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd} )" ],
		"description" : "Initializes this beam to be a beam between 2 given points (BEAM_POINTS)."
	},
	"void CLaser::PointEntInit(const Vector& in vecStart, int endIndex)": {
		"prefix": "PointEntInit",
		"body" : [ "PointEntInit( ${1:const Vector& in vecStart}, ${2:int endIndex} )" ],
		"description" : "Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT)."
	},
	"void CLaser::PointEntInit(const Vector& in vecStart, CBaseEntity@ pEntEnd)": {
		"prefix": "PointEntInit",
		"body" : [ "PointEntInit( ${1:const Vector& in vecStart}, ${2:CBaseEntity@ pEntEnd} )" ],
		"description" : "Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT)."
	},
	"void CLaser::EntsInit(int startIndex, int endIndex)": {
		"prefix": "EntsInit",
		"body" : [ "EntsInit( ${1:int startIndex}, ${2:int endIndex} )" ],
		"description" : "Initializes this beam to be a beam between 2 given entities (BEAM_ENTS)."
	},
	"void CLaser::EntsInit(CBaseEntity@ pEntStart, CBaseEntity@ pEntEnd)": {
		"prefix": "EntsInit",
		"body" : [ "EntsInit( ${1:CBaseEntity@ pEntStart}, ${2:CBaseEntity@ pEntEnd} )" ],
		"description" : "Initializes this beam to be a beam between 2 given entities (BEAM_ENTS)."
	},
	"void CLaser::HoseInit(const Vector& in vecStart, const Vector& in vecDirection)": {
		"prefix": "HoseInit",
		"body" : [ "HoseInit( ${1:const Vector& in vecStart}, ${2:const Vector& in vecDirection} )" ],
		"description" : "Initializes this beam to be a beam going from a point in a given direction (BEAM_HOSE)."
	},
	"void CLaser::LiveForTime(float flTime)": {
		"prefix": "LiveForTime",
		"body" : [ "LiveForTime( ${1:float flTime} )" ],
		"description" : "Sets this beam to live for the given amount of time, after which it is removed."
	},
	"void CLaser::BeamDamageInstant(TraceResult& in tr, float flDamage)": {
		"prefix": "BeamDamageInstant",
		"body" : [ "BeamDamageInstant( ${1:TraceResult& in tr}, ${2:float flDamage} )" ],
		"description" : "Causes the given amount of damage to be done to the entity hit by the given traceresult, as if the damage occured one second ago."
	},
	"void CLaser::XenTeleportZap(const Vector& in vecSrc, const Vector& in vecDest)": {
		"prefix": "XenTeleportZap",
		"body" : [ "XenTeleportZap( ${1:const Vector& in vecSrc}, ${2:const Vector& in vecDest} )" ],
		"description" : "Creates a Xen teleport zap effect between the given points."
	},
	"void CLaser::XenTeleport(const Vector& in vecSrc, int iRadius = 256)": {
		"prefix": "XenTeleport",
		"body" : [ "XenTeleport( ${1:const Vector& in vecSrc}, ${2:int iRadius = 256} )" ],
		"description" : "Creates a Xen teleport effect at the given location, with zaps occuring within the given radius."
	},
	"void CLaser::TurnOn()": {
		"prefix": "TurnOn",
		"body" : [ "TurnOn()" ],
		"description" : "Turns the laser on"
	},
	"void CLaser::TurnOff()": {
		"prefix": "TurnOff",
		"body" : [ "TurnOff()" ],
		"description" : "Turns the laser off"
	},
	"bool CLaser::IsOn()": {
		"prefix": "IsOn",
		"body" : [ "IsOn()" ],
		"description" : "Returns whether the laser is on"
	},
	"void CLaser::FireAtPoint(TraceResult& in tr)": {
		"prefix": "FireAtPoint",
		"body" : [ "FireAtPoint( ${1:TraceResult& in tr} )" ],
		"description" : "Fires the laser at a point defined by where the TraceResult hit. Also causes beam damage as if CBeam::BeamDamage were used, and sparks at both ends, if the approprite spawn flags have been set."
	},
	"entvars_t@ CLaser::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CLaser::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CLaser::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CLaser::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CLaser::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CLaser::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CLaser::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CLaser::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CLaser::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CLaser::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CLaser::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CLaser::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CLaser::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CLaser::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CLaser::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CLaser::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"enum CLASS {..., CLASS_FORCE_NONE, ...}": {
		"prefix": "CLASS_FORCE_NONE",
		"body" : [ "CLASS_FORCE_NONE" ],
		"description" : "(-1) Forces class override to none"
	},
	"enum CLASS {..., CLASS_NONE, ...}": {
		"prefix": "CLASS_NONE",
		"body" : [ "CLASS_NONE" ],
		"description" : "(0) No classification"
	},
	"enum CLASS {..., CLASS_MACHINE, ...}": {
		"prefix": "CLASS_MACHINE",
		"body" : [ "CLASS_MACHINE" ],
		"description" : "(1) Is machine"
	},
	"enum CLASS {..., CLASS_PLAYER, ...}": {
		"prefix": "CLASS_PLAYER",
		"body" : [ "CLASS_PLAYER" ],
		"description" : "(2) Is player"
	},
	"enum CLASS {..., CLASS_HUMAN_PASSIVE, ...}": {
		"prefix": "CLASS_HUMAN_PASSIVE",
		"body" : [ "CLASS_HUMAN_PASSIVE" ],
		"description" : "(3) Is passive human"
	},
	"enum CLASS {..., CLASS_HUMAN_MILITARY, ...}": {
		"prefix": "CLASS_HUMAN_MILITARY",
		"body" : [ "CLASS_HUMAN_MILITARY" ],
		"description" : "(4) Is military human"
	},
	"enum CLASS {..., CLASS_ALIEN_MILITARY, ...}": {
		"prefix": "CLASS_ALIEN_MILITARY",
		"body" : [ "CLASS_ALIEN_MILITARY" ],
		"description" : "(5) Is military alien"
	},
	"enum CLASS {..., CLASS_ALIEN_PASSIVE, ...}": {
		"prefix": "CLASS_ALIEN_PASSIVE",
		"body" : [ "CLASS_ALIEN_PASSIVE" ],
		"description" : "(6) Is passive alien"
	},
	"enum CLASS {..., CLASS_ALIEN_MONSTER, ...}": {
		"prefix": "CLASS_ALIEN_MONSTER",
		"body" : [ "CLASS_ALIEN_MONSTER" ],
		"description" : "(7) Is monster alien"
	},
	"enum CLASS {..., CLASS_ALIEN_PREY, ...}": {
		"prefix": "CLASS_ALIEN_PREY",
		"body" : [ "CLASS_ALIEN_PREY" ],
		"description" : "(8) Is prey alien"
	},
	"enum CLASS {..., CLASS_ALIEN_PREDATOR, ...}": {
		"prefix": "CLASS_ALIEN_PREDATOR",
		"body" : [ "CLASS_ALIEN_PREDATOR" ],
		"description" : "(9) Is predator alien"
	},
	"enum CLASS {..., CLASS_INSECT, ...}": {
		"prefix": "CLASS_INSECT",
		"body" : [ "CLASS_INSECT" ],
		"description" : "(10) Is insect"
	},
	"enum CLASS {..., CLASS_PLAYER_ALLY, ...}": {
		"prefix": "CLASS_PLAYER_ALLY",
		"body" : [ "CLASS_PLAYER_ALLY" ],
		"description" : "(11) is player ally"
	},
	"enum CLASS {..., CLASS_PLAYER_BIOWEAPON, ...}": {
		"prefix": "CLASS_PLAYER_BIOWEAPON",
		"body" : [ "CLASS_PLAYER_BIOWEAPON" ],
		"description" : "(12) Is player bioweapon"
	},
	"enum CLASS {..., CLASS_ALIEN_BIOWEAPON, ...}": {
		"prefix": "CLASS_ALIEN_BIOWEAPON",
		"body" : [ "CLASS_ALIEN_BIOWEAPON" ],
		"description" : "(13) Is alien bioweapon"
	},
	"enum CLASS {..., CLASS_XRACE_PITDRONE, ...}": {
		"prefix": "CLASS_XRACE_PITDRONE",
		"body" : [ "CLASS_XRACE_PITDRONE" ],
		"description" : "(14) Is X-Race pitdrone"
	},
	"enum CLASS {..., CLASS_XRACE_SHOCK, ...}": {
		"prefix": "CLASS_XRACE_SHOCK",
		"body" : [ "CLASS_XRACE_SHOCK" ],
		"description" : "(15) Is X-Race shock trooper (also Voltigores)"
	},
	"enum CLASS {..., CLASS_TEAM1, ...}": {
		"prefix": "CLASS_TEAM1",
		"body" : [ "CLASS_TEAM1" ],
		"description" : "(16) Is on Team 1"
	},
	"enum CLASS {..., CLASS_TEAM2, ...}": {
		"prefix": "CLASS_TEAM2",
		"body" : [ "CLASS_TEAM2" ],
		"description" : "(17) Is on Team 2"
	},
	"enum CLASS {..., CLASS_TEAM3, ...}": {
		"prefix": "CLASS_TEAM3",
		"body" : [ "CLASS_TEAM3" ],
		"description" : "(18) Is on Team 3"
	},
	"enum CLASS {..., CLASS_TEAM4, ...}": {
		"prefix": "CLASS_TEAM4",
		"body" : [ "CLASS_TEAM4" ],
		"description" : "(19) Is on Team 4"
	},
	"enum CLASS {..., CLASS_BARNACLE, ...}": {
		"prefix": "CLASS_BARNACLE",
		"body" : [ "CLASS_BARNACLE" ],
		"description" : "(99) Is Barnacle"
	},
	"enum ClientSayType {..., CLIENTSAY_SAY, ...}": {
		"prefix": "CLIENTSAY_SAY",
		"body" : [ "CLIENTSAY_SAY" ],
		"description" : "(0) Say"
	},
	"enum ClientSayType {..., CLIENTSAY_SAYTEAM, ...}": {
		"prefix": "CLIENTSAY_SAYTEAM",
		"body" : [ "CLIENTSAY_SAYTEAM" ],
		"description" : "(1) Say team"
	},
	"bool CLog::PrintF(const string& in szFormat)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CLog::PrintF(const string& in szFormat, ?& in)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat}, ${2:?& in} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CLog::PrintF(const string& in szFormat, ?& in, ?& in)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat}, ${2:?& in}, ${3:?& in} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CLog::PrintF(const string& in szFormat, ?& in, ?& in, ?& in)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat}, ${2:?& in}, ${3:?& in}, ${4:?& in} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CLog::PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CLog::PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CLog::PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CLog::PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CLog::PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "PrintF",
		"body" : [ "PrintF( ${1:const string& in szFormat}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in} )" ],
		"description" : "Prints formatted data to the file. Uses SC printf formatting style."
	},
	"bool CMap::HasForcedPlayerModels() const": {
		"prefix": "HasForcedPlayerModels",
		"body" : [ "HasForcedPlayerModels()" ],
		"description" : "Get if player models are forced"
	},
	"bool CMap::LoadMapSkillFile()": {
		"prefix": "LoadMapSkillFile",
		"body" : [ "LoadMapSkillFile()" ],
		"description" : "Reload the standard map skill file (_skl.cfg)."
	},
	"bool CMap::LoadGlobalSkillFile()": {
		"prefix": "LoadGlobalSkillFile",
		"body" : [ "LoadGlobalSkillFile()" ],
		"description" : "Reload the global skill file."
	},
	"bool CMap::LoadSkillFile(const string& in szFileName)": {
		"prefix": "LoadSkillFile",
		"body" : [ "LoadSkillFile( ${1:const string& in szFileName} )" ],
		"description" : "Load a custom skill file."
	},
	"array<string>@ CMapCycle::GetMapCycle() const": {
		"prefix": "GetMapCycle",
		"body" : [ "GetMapCycle()" ],
		"description" : "Gets the map cycle as an array of strings."
	},
	"size_t CMapCycle::Count() const": {
		"prefix": "Count",
		"body" : [ "Count()" ],
		"description" : "Returns the number of maps in the map cycle."
	},
	"string CMapCycle::GetNextMap() const": {
		"prefix": "GetNextMap",
		"body" : [ "GetNextMap()" ],
		"description" : "Gets the next map in the cycle."
	},
	"string CMapCycle::GetNextMap(const string& in szMapName) const": {
		"prefix": "GetNextMap",
		"body" : [ "GetNextMap( ${1:const string& in szMapName} )" ],
		"description" : "Gets the next map in the cycle after the given one."
	},
	"int32 CMath::RandomLong(int32 low, int32 high)": {
		"prefix": "RandomLong",
		"body" : [ "RandomLong( ${1:int32 low}, ${2:int32 high} )" ],
		"description" : "Returns a random integer between low and high"
	},
	"float CMath::RandomFloat(float low, float high)": {
		"prefix": "RandomFloat",
		"body" : [ "RandomFloat( ${1:float low}, ${2:float high} )" ],
		"description" : "Returns a random float between low and high"
	},
	"void CMath::MakeVectors(const Vector& in vecAngles)": {
		"prefix": "MakeVectors",
		"body" : [ "MakeVectors( ${1:const Vector& in vecAngles} )" ],
		"description" : "Makes vectors"
	},
	"Vector CMath::RotateVector(Vector& in vecToRotate,const Vector& in vecAngles, const Vector& in vecOffset)": {
		"prefix": "RotateVector",
		"body" : [ "RotateVector( ${1:Vector& in vecToRotate,const Vector& in vecAngles}, ${2:const Vector& in vecOffset} )" ],
		"description" : "Rotate vector"
	},
	"void CMath::MakeAimVectors(const Vector& in vecAngles)": {
		"prefix": "MakeAimVectors",
		"body" : [ "MakeAimVectors( ${1:const Vector& in vecAngles} )" ],
		"description" : "Make aim vectors"
	},
	"void CMath::MakeInvVectors(const Vector& in vecAngles)": {
		"prefix": "MakeInvVectors",
		"body" : [ "MakeInvVectors( ${1:const Vector& in vecAngles} )" ],
		"description" : "Make inverted vectors"
	},
	"float CMath::VecToYaw(const Vector& in vec)": {
		"prefix": "VecToYaw",
		"body" : [ "VecToYaw( ${1:const Vector& in vec} )" ],
		"description" : "Transforms a vector to a yaw value"
	},
	"Vector CMath::VecToAngles(const Vector& in vec)": {
		"prefix": "VecToAngles",
		"body" : [ "VecToAngles( ${1:const Vector& in vec} )" ],
		"description" : "Transforms a vector to an angle"
	},
	"float CMath::AngleMod(float flAngle)": {
		"prefix": "AngleMod",
		"body" : [ "AngleMod( ${1:float flAngle} )" ],
		"description" : "Clamps the given angle between 0 and 360"
	},
	"float CMath::AngleDiff(float flDestAngle, float flSrcAngle)": {
		"prefix": "AngleDiff",
		"body" : [ "AngleDiff( ${1:float flDestAngle}, ${2:float flSrcAngle} )" ],
		"description" : "Returns the difference between 2 angles"
	},
	"float CMath::ApproachAngle(float target, float value, float speed)": {
		"prefix": "ApproachAngle",
		"body" : [ "ApproachAngle( ${1:float target}, ${2:float value}, ${3:float speed} )" ],
		"description" : "Given a target and current angle value, and a rotation speed, all in degrees, returns a new angle that is either between value and target, or target, depending on whether the speed is high enough to reach that angle."
	},
	"float CMath::AngleDistance(float flNext, float flCur)": {
		"prefix": "AngleDistance",
		"body" : [ "AngleDistance( ${1:float flNext}, ${2:float flCur} )" ],
		"description" : "Returns the distance between 2 angles"
	},
	"uint64 CMath::min(uint64 lhs, uint64 rhs) const": {
		"prefix": "min",
		"body" : [ "min( ${1:uint64 lhs}, ${2:uint64 rhs} )" ],
		"description" : "Returns the smaller of the two values"
	},
	"int64 CMath::min(int64 lhs, int64 rhs) const": {
		"prefix": "min",
		"body" : [ "min( ${1:int64 lhs}, ${2:int64 rhs} )" ],
		"description" : "Returns the smaller of the two values"
	},
	"float CMath::min(float lhs, float rhs) const": {
		"prefix": "min",
		"body" : [ "min( ${1:float lhs}, ${2:float rhs} )" ],
		"description" : "Returns the smaller of the two values"
	},
	"uint64 CMath::max(uint64 lhs, uint64 rhs) const": {
		"prefix": "max",
		"body" : [ "max( ${1:uint64 lhs}, ${2:uint64 rhs} )" ],
		"description" : "Returns the larger of the two values"
	},
	"int64 CMath::max(int64 lhs, int64 rhs) const": {
		"prefix": "max",
		"body" : [ "max( ${1:int64 lhs}, ${2:int64 rhs} )" ],
		"description" : "Returns the larger of the two values"
	},
	"float CMath::max(float lhs, float rhs) const": {
		"prefix": "max",
		"body" : [ "max( ${1:float lhs}, ${2:float rhs} )" ],
		"description" : "Returns the larger of the two values"
	},
	"int CMath::clamp(int min, int max, int value) const": {
		"prefix": "clamp",
		"body" : [ "clamp( ${1:int min}, ${2:int max}, ${3:int value} )" ],
		"description" : "Clamps a value between a range"
	},
	"float CMath::clamp(float min, float max, float value) const": {
		"prefix": "clamp",
		"body" : [ "clamp( ${1:float min}, ${2:float max}, ${3:float value} )" ],
		"description" : "Clamps a value between a range"
	},
	"float CMath::Floor(float flValue) const": {
		"prefix": "Floor",
		"body" : [ "Floor( ${1:float flValue} )" ],
		"description" : "Returns the float value, rounded down to the nearest whole number"
	},
	"float CMath::Ceil(float flValue) const": {
		"prefix": "Ceil",
		"body" : [ "Ceil( ${1:float flValue} )" ],
		"description" : "Returns the float value, rounded up to the nearest whole number"
	},
	"float CMath::DegreesToRadians(float flDegrees) const": {
		"prefix": "DegreesToRadians",
		"body" : [ "DegreesToRadians( ${1:float flDegrees} )" ],
		"description" : "Returns the given value in degrees as radians"
	},
	"float CMath::RadiansToDegrees(float flRadians) const": {
		"prefix": "RadiansToDegrees",
		"body" : [ "RadiansToDegrees( ${1:float flRadians} )" ],
		"description" : "Returns the given value in radians as degrees"
	},
	"bool CMath::Compare(float flLhs, float flRhs, float flEpsilon) const": {
		"prefix": "Compare",
		"body" : [ "Compare( ${1:float flLhs}, ${2:float flRhs}, ${3:float flEpsilon} )" ],
		"description" : "Compares the given floating point variables and returns whether they are equal, considering certain variance (epsilon) between them."
	},
	"bool CMath::Compare(double flLhs, double flRhs, double flEpsilon) const": {
		"prefix": "Compare",
		"body" : [ "Compare( ${1:double flLhs}, ${2:double flRhs}, ${3:double flEpsilon} )" ],
		"description" : "Compares the given floating point variables and returns whether they are equal, considering certain variance (epsilon) between them."
	},
	"const int8 CMath::INT8_MIN": {
		"prefix": "INT8_MIN",
		"body" : [ "INT8_MIN" ],
		"description" : "Int8 minimum value"
	},
	"const int16 CMath::INT16_MIN": {
		"prefix": "INT16_MIN",
		"body" : [ "INT16_MIN" ],
		"description" : "Int16 minimum value"
	},
	"const int32 CMath::INT32_MIN": {
		"prefix": "INT32_MIN",
		"body" : [ "INT32_MIN" ],
		"description" : "Int32 minimum value"
	},
	"const int64 CMath::INT64_MIN": {
		"prefix": "INT64_MIN",
		"body" : [ "INT64_MIN" ],
		"description" : "Int64 minimum value"
	},
	"const int8 CMath::INT8_MAX": {
		"prefix": "INT8_MAX",
		"body" : [ "INT8_MAX" ],
		"description" : "Int8 maximum value"
	},
	"const int16 CMath::INT16_MAX": {
		"prefix": "INT16_MAX",
		"body" : [ "INT16_MAX" ],
		"description" : "Int16 maximum value"
	},
	"const int32 CMath::INT32_MAX": {
		"prefix": "INT32_MAX",
		"body" : [ "INT32_MAX" ],
		"description" : "Int32 maximum value"
	},
	"const int64 CMath::INT64_MAX": {
		"prefix": "INT64_MAX",
		"body" : [ "INT64_MAX" ],
		"description" : "Int64 maximum value"
	},
	"const uint8 CMath::UINT8_MAX": {
		"prefix": "UINT8_MAX",
		"body" : [ "UINT8_MAX" ],
		"description" : "Uint8 maximum value"
	},
	"const uint16 CMath::UINT16_MAX": {
		"prefix": "UINT16_MAX",
		"body" : [ "UINT16_MAX" ],
		"description" : "Uint16 maximum value"
	},
	"const uint32 CMath::UINT32_MAX": {
		"prefix": "UINT32_MAX",
		"body" : [ "UINT32_MAX" ],
		"description" : "Uint32 maximum value"
	},
	"const uint64 CMath::UINT64_MAX": {
		"prefix": "UINT64_MAX",
		"body" : [ "UINT64_MAX" ],
		"description" : "Uint64 maximum value"
	},
	"const size_t CMath::SIZE_MAX": {
		"prefix": "SIZE_MAX",
		"body" : [ "SIZE_MAX" ],
		"description" : "Size_t maximum value"
	},
	"const float CMath::FLOAT_MIN": {
		"prefix": "FLOAT_MIN",
		"body" : [ "FLOAT_MIN" ],
		"description" : "Float minimum positive value"
	},
	"const double CMath::DOUBLE_MIN": {
		"prefix": "DOUBLE_MIN",
		"body" : [ "DOUBLE_MIN" ],
		"description" : "Double minimum positive value"
	},
	"const float CMath::FLOAT_MAX": {
		"prefix": "FLOAT_MAX",
		"body" : [ "FLOAT_MAX" ],
		"description" : "Float maximum positive value"
	},
	"const double CMath::DOUBLE_MAX": {
		"prefix": "DOUBLE_MAX",
		"body" : [ "DOUBLE_MAX" ],
		"description" : "Double maximum positive value"
	},
	"const double CMath::PI": {
		"prefix": "PI",
		"body" : [ "PI" ],
		"description" : "PI"
	},
	"int CModelFuncs::ModelIndex(const string& in szModelName)": {
		"prefix": "ModelIndex",
		"body" : [ "ModelIndex( ${1:const string& in szModelName} )" ],
		"description" : "Gets model index."
	},
	"int CModelFuncs::SetBodygroup(int iModelIndex, int iBody, int iGroup, int iValue)": {
		"prefix": "SetBodygroup",
		"body" : [ "SetBodygroup( ${1:int iModelIndex}, ${2:int iBody}, ${3:int iGroup}, ${4:int iValue} )" ],
		"description" : "Builds bodygroup configuration."
	},
	"int CModelFuncs::GetBodygroup(int iModelIndex, int iBody, int iGroup)": {
		"prefix": "GetBodygroup",
		"body" : [ "GetBodygroup( ${1:int iModelIndex}, ${2:int iBody}, ${3:int iGroup} )" ],
		"description" : "Gets bodygroup configuration."
	},
	"int CModelFuncs::GetBodygroupSubmodelCount(int iModelIndex, int iGroup)": {
		"prefix": "GetBodygroupSubmodelCount",
		"body" : [ "GetBodygroupSubmodelCount( ${1:int iModelIndex}, ${2:int iGroup} )" ],
		"description" : "Gets the number of submodels."
	},
	"int CModelFuncs::GetAttachmentCount(int iModelIndex)": {
		"prefix": "GetAttachmentCount",
		"body" : [ "GetAttachmentCount( ${1:int iModelIndex} )" ],
		"description" : "Gets the number of attachments in a model."
	},
	"string CModule::GetModuleName() const": {
		"prefix": "GetModuleName",
		"body" : [ "GetModuleName()" ],
		"description" : "Gets the name of this module."
	},
	"CScriptInfo@+ CModule::get_ScriptInfo()": {
		"prefix": "get_ScriptInfo",
		"body" : [ "get_ScriptInfo()" ],
		"description" : "Gets this module's script info object."
	},
	"bool CModuleHookManager::RegisterHook(uint uiHookCode, ?& in pHookFunction)": {
		"prefix": "RegisterHook",
		"body" : [ "RegisterHook( ${1:uint uiHookCode}, ${2:?& in pHookFunction} )" ],
		"description" : "Registers a hook. Pass in a hook function or delegate."
	},
	"void CModuleHookManager::RemoveHook(uint uiHookCode)": {
		"prefix": "RemoveHook",
		"body" : [ "RemoveHook( ${1:uint uiHookCode} )" ],
		"description" : "Removes all functions hooked into the given hook."
	},
	"void CModuleHookManager::RemoveHook(uint uiHookCode, ?& in pHookFunction)": {
		"prefix": "RemoveHook",
		"body" : [ "RemoveHook( ${1:uint uiHookCode}, ${2:?& in pHookFunction} )" ],
		"description" : "Removes a hook. Pass in the hook function or delegate to remove."
	},
	"enum CommonEntityFlags {..., SF_NORESPAWN, ...}": {
		"prefix": "SF_NORESPAWN",
		"body" : [ "SF_NORESPAWN" ],
		"description" : "(1024) set this bit on guns and stuff that should never respawn."
	},
	"enum CommonEntityFlags {..., SF_DELAYREMOVE, ...}": {
		"prefix": "SF_DELAYREMOVE",
		"body" : [ "SF_DELAYREMOVE" ],
		"description" : "(2048) A weapon will be removed from the map after 60sec"
	},
	"enum CommonEntityFlags {..., SF_CREATEDWEAPON, ...}": {
		"prefix": "SF_CREATEDWEAPON",
		"body" : [ "SF_CREATEDWEAPON" ],
		"description" : "(4096) this flag indicates that this entity is a weapon created for players,. as opposed to being created by being placed by a mapper"
	},
	"enum CommonEntityFlags {..., SF_DODAMAGE, ...}": {
		"prefix": "SF_DODAMAGE",
		"body" : [ "SF_DODAMAGE" ],
		"description" : "(8192) this flag indicates that a player thrown weapon should deal damage to things it hits"
	},
	"enum CommonEntityFlags {..., SF_GIVENITEM, ...}": {
		"prefix": "SF_GIVENITEM",
		"body" : [ "SF_GIVENITEM" ],
		"description" : "(16384) This item is being given to the player -- can't fall out of map"
	},
	"enum CommonEntityFlags {..., SF_NODEFAULTAMMO, ...}": {
		"prefix": "SF_NODEFAULTAMMO",
		"body" : [ "SF_NODEFAULTAMMO" ],
		"description" : "(32768) Don't allow default ammo to be set. Prevents players from getting too much ammo from cross map inventory"
	},
	"enum String::CompareType {..., CaseSensitive, ...}": {
		"prefix": "CaseSensitive",
		"body" : [ "String::CaseSensitive" ],
		"description" : "(0)"
	},
	"enum String::CompareType {..., CaseInsensitive, ...}": {
		"prefix": "CaseInsensitive",
		"body" : [ "String::CaseInsensitive" ],
		"description" : "(1)"
	},
	"enum ConCommandFlag::ConCommandFlag {..., None, ...}": {
		"prefix": "None",
		"body" : [ "ConCommandFlag::None" ],
		"description" : "(0) No flags to set"
	},
	"enum ConCommandFlag::ConCommandFlag {..., AdminOnly, ...}": {
		"prefix": "AdminOnly",
		"body" : [ "ConCommandFlag::AdminOnly" ],
		"description" : "(1) If set, the invoking player (if any) must have admin access."
	},
	"enum ConCommandFlag::ConCommandFlag {..., Cheat, ...}": {
		"prefix": "Cheat",
		"body" : [ "ConCommandFlag::Cheat" ],
		"description" : "(2) If set, the invoking player (if any) must have cheat access."
	},
	"enum CONTENTS {..., CONTENTS_EMPTY, ...}": {
		"prefix": "CONTENTS_EMPTY",
		"body" : [ "CONTENTS_EMPTY" ],
		"description" : "(-1)"
	},
	"enum CONTENTS {..., CONTENTS_SOLID, ...}": {
		"prefix": "CONTENTS_SOLID",
		"body" : [ "CONTENTS_SOLID" ],
		"description" : "(-2)"
	},
	"enum CONTENTS {..., CONTENTS_WATER, ...}": {
		"prefix": "CONTENTS_WATER",
		"body" : [ "CONTENTS_WATER" ],
		"description" : "(-3)"
	},
	"enum CONTENTS {..., CONTENTS_SLIME, ...}": {
		"prefix": "CONTENTS_SLIME",
		"body" : [ "CONTENTS_SLIME" ],
		"description" : "(-4)"
	},
	"enum CONTENTS {..., CONTENTS_LAVA, ...}": {
		"prefix": "CONTENTS_LAVA",
		"body" : [ "CONTENTS_LAVA" ],
		"description" : "(-5)"
	},
	"enum CONTENTS {..., CONTENTS_SKY, ...}": {
		"prefix": "CONTENTS_SKY",
		"body" : [ "CONTENTS_SKY" ],
		"description" : "(-6)"
	},
	"enum CONTENTS {..., CONTENTS_LADDER, ...}": {
		"prefix": "CONTENTS_LADDER",
		"body" : [ "CONTENTS_LADDER" ],
		"description" : "(-16)"
	},
	"CBaseEntity@ CPathTrack::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CPathTrack::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CPathTrack::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CPathTrack::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CPathTrack::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CPathTrack::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CPathTrack::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CPathTrack::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CPathTrack::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CPathTrack::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CPathTrack::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CPathTrack::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CPathTrack::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CPathTrack::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CPathTrack::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CPathTrack::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CPathTrack::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CPathTrack::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CPathTrack::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CPathTrack::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CPathTrack::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CPathTrack::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CPathTrack::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CPathTrack::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CPathTrack::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CPathTrack::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CPathTrack::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CPathTrack::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CPathTrack::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CPathTrack::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CPathTrack::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CPathTrack::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CPathTrack::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CPathTrack::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CPathTrack::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CPathTrack::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CPathTrack::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CPathTrack::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CPathTrack::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CPathTrack::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CPathTrack::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CPathTrack::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CPathTrack::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CPathTrack::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CPathTrack::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CPathTrack::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CPathTrack::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CPathTrack::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CPathTrack::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CPathTrack::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CPathTrack::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CPathTrack::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CPathTrack::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CPathTrack::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CPathTrack::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CPathTrack::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CPathTrack::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CPathTrack::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CPathTrack::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CPathTrack::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CPathTrack::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CPathTrack::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CPathTrack::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CPathTrack::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CPathTrack::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CPathTrack::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CPathTrack::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CPathTrack::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CPathTrack::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CPathTrack::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CPathTrack::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CPathTrack::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CPathTrack::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CPathTrack::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CPathTrack::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CPathTrack::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CPathTrack::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CPathTrack::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CPathTrack::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CPathTrack::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CPathTrack::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CPathTrack::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CPathTrack::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CPathTrack::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CPathTrack::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CPathTrack::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CPathTrack::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CPathTrack::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CPathTrack::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CPathTrack::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CPathTrack::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CPathTrack::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CPathTrack::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CPathTrack::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CPathTrack::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CPathTrack::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CPathTrack::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CPathTrack::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CPathTrack::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CPathTrack::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CPathTrack::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CPathTrack::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CPathTrack::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CPathTrack::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CPathTrack::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CPathTrack::SetPrevious(CPathTrack@ pPrevious)": {
		"prefix": "SetPrevious",
		"body" : [ "SetPrevious( ${1:CPathTrack@ pPrevious} )" ],
		"description" : "Sets the previous track in this path"
	},
	"void CPathTrack::Link()": {
		"prefix": "Link",
		"body" : [ "Link()" ],
		"description" : "Links the tracks together"
	},
	"CPathTrack@ CPathTrack::ValidPath(CPathTrack@ pPath, const bool testFlag)": {
		"prefix": "ValidPath",
		"body" : [ "ValidPath( ${1:CPathTrack@ pPath}, ${2:const bool testFlag} )" ],
		"description" : "Returns pPath if enabled, null otherwise."
	},
	"entvars_t@ CPathTrack::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CPathTrack::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CPathTrack::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CPathTrack::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CPathTrack::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CPathTrack::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CPathTrack::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CPathTrack::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CPathTrack::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CPathTrack::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CPathTrack::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CPathTrack::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CPathTrack::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CPathTrack::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CPathTrack::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CPathTrack::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"float CPathTrack::m_flMaxSpeed": {
		"prefix": "m_flMaxSpeed",
		"body" : [ "m_flMaxSpeed" ],
		"description" : "New maximum speed"
	},
	"float CPathTrack::m_flNewSpeed": {
		"prefix": "m_flNewSpeed",
		"body" : [ "m_flNewSpeed" ],
		"description" : "New train speed"
	},
	"bool CPersistence::Exists(const string& in szName) const": {
		"prefix": "Exists",
		"body" : [ "Exists( ${1:const string& in szName} )" ],
		"description" : "Returns whether the given persistence instance exists."
	},
	"bool CPersistence::IsValidHandle(const PersistID_t ID) const": {
		"prefix": "IsValidHandle",
		"body" : [ "IsValidHandle( ${1:const PersistID_t ID} )" ],
		"description" : "Returns whether the given persistence instance handle is valid."
	},
	"bool CPersistence::ShouldKeep() const": {
		"prefix": "ShouldKeep",
		"body" : [ "ShouldKeep()" ],
		"description" : "Returns whether the previous map's persistence instances will be kept."
	},
	"void CPersistence::SetKeep(bool fValue)": {
		"prefix": "SetKeep",
		"body" : [ "SetKeep( ${1:bool fValue} )" ],
		"description" : "Sets whether the previous map's persistence instances will be kept."
	},
	"bool CPersistence::KeepIfPrevious(const array<string>@ pArray)": {
		"prefix": "KeepIfPrevious",
		"body" : [ "KeepIfPrevious( ${1:const array<string>@ pArray} )" ],
		"description" : "Will make the persistence manager keep the previous map's persistence instancesif the previous map's name matches any of the elements in the array."
	},
	"bool CPersistence::KeepIfPrevious(const string& in szMapName)": {
		"prefix": "KeepIfPrevious",
		"body" : [ "KeepIfPrevious( ${1:const string& in szMapName} )" ],
		"description" : "Will make the persistence manager keep the previous map's persistence instancesif the previous map's name matches the given map name."
	},
	"PersistID_t CPersistence::RegisterInstance(const string& in szName)": {
		"prefix": "RegisterInstance",
		"body" : [ "RegisterInstance( ${1:const string& in szName} )" ],
		"description" : "Returns a persistence instance tied to the given name. Will be created if it does not already exist."
	},
	"const string& CPersistence::GetPreviousMapName() const": {
		"prefix": "GetPreviousMapName",
		"body" : [ "GetPreviousMapName()" ],
		"description" : "Returns the name of the previous map. Can be empty if the server has just started."
	},
	"const string& CPersistence::GetCurrentMapName() const": {
		"prefix": "GetCurrentMapName",
		"body" : [ "GetCurrentMapName()" ],
		"description" : "Returns the name of the current map."
	},
	"void CPersistence::ClearInstance(const string& in szName)": {
		"prefix": "ClearInstance",
		"body" : [ "ClearInstance( ${1:const string& in szName} )" ],
		"description" : "Clears the specified persistence instance."
	},
	"void CPersistence::ClearInstance(const PersistID_t ID)": {
		"prefix": "ClearInstance",
		"body" : [ "ClearInstance( ${1:const PersistID_t ID} )" ],
		"description" : "Clears the specified persistence instance."
	},
	"void CPersistence::Clear()": {
		"prefix": "Clear",
		"body" : [ "Clear()" ],
		"description" : "Clears all persistence instances. Make sure to avoid calling handles referencing the cleared instances."
	},
	"const string& CPersistence::GetName(const PersistID_t ID) const": {
		"prefix": "GetName",
		"body" : [ "GetName( ${1:const PersistID_t ID} )" ],
		"description" : "Returns the name of this instance."
	},
	"size_t CPersistence::Size(int iId) const": {
		"prefix": "Size",
		"body" : [ "Size( ${1:int iId} )" ],
		"description" : "Returns the number of persisted items in this instance."
	},
	"bool CPersistence::Exists(const PersistID_t ID, const string& in szKey)": {
		"prefix": "Exists",
		"body" : [ "Exists( ${1:const PersistID_t ID}, ${2:const string& in szKey} )" ],
		"description" : "Returns whether the given key exists in this instance."
	},
	"const string& CPersistence::GetString(const PersistID_t ID, const string& in szKey)": {
		"prefix": "GetString",
		"body" : [ "GetString( ${1:const PersistID_t ID}, ${2:const string& in szKey} )" ],
		"description" : "Returns the given value as a string, or  if it does not exist."
	},
	"bool CPersistence::GetBoolean(const PersistID_t ID, const string& in szKey)": {
		"prefix": "GetBoolean",
		"body" : [ "GetBoolean( ${1:const PersistID_t ID}, ${2:const string& in szKey} )" ],
		"description" : "Returns the given value as a boolean, or false if it does not exist."
	},
	"int32 CPersistence::GetLong(const PersistID_t ID, const string& in szKey, int iRadix = 10)": {
		"prefix": "GetLong",
		"body" : [ "GetLong( ${1:const PersistID_t ID}, ${2:const string& in szKey}, ${3:int iRadix = 10} )" ],
		"description" : "Returns the given value as a long, or 0 if it does not exist."
	},
	"uint32 CPersistence::GetUlong(const PersistID_t ID, const string& in szKey, int iRadix = 10)": {
		"prefix": "GetUlong",
		"body" : [ "GetUlong( ${1:const PersistID_t ID}, ${2:const string& in szKey}, ${3:int iRadix = 10} )" ],
		"description" : "Returns the given value as a unsigned long, or 0 if it does not exist."
	},
	"float CPersistence::GetFloat(const PersistID_t ID, const string& in szKey)": {
		"prefix": "GetFloat",
		"body" : [ "GetFloat( ${1:const PersistID_t ID}, ${2:const string& in szKey} )" ],
		"description" : "Returns the given value as a float, or 0.0 if it does not exist."
	},
	"void CPersistence::Set(const PersistID_t ID, const string& in szKey, const string& in szValue)": {
		"prefix": "Set",
		"body" : [ "Set( ${1:const PersistID_t ID}, ${2:const string& in szKey}, ${3:const string& in szValue} )" ],
		"description" : "Sets the given value as a string."
	},
	"void CPersistence::Set(const PersistID_t ID, const string& in szKey, bool fValue)": {
		"prefix": "Set",
		"body" : [ "Set( ${1:const PersistID_t ID}, ${2:const string& in szKey}, ${3:bool fValue} )" ],
		"description" : "Sets the given value as a boolean."
	},
	"void CPersistence::Set(const PersistID_t ID, const string& in szKey, int32 iValue)": {
		"prefix": "Set",
		"body" : [ "Set( ${1:const PersistID_t ID}, ${2:const string& in szKey}, ${3:int32 iValue} )" ],
		"description" : "Sets the given value as a string."
	},
	"void CPersistence::Set(const PersistID_t ID, const string& in szKey, uint32 uiValue)": {
		"prefix": "Set",
		"body" : [ "Set( ${1:const PersistID_t ID}, ${2:const string& in szKey}, ${3:uint32 uiValue} )" ],
		"description" : "Sets the given value as a string."
	},
	"void CPersistence::Set(const PersistID_t ID, const string& in szKey, float flValue)": {
		"prefix": "Set",
		"body" : [ "Set( ${1:const PersistID_t ID}, ${2:const string& in szKey}, ${3:float flValue} )" ],
		"description" : "Sets the given value as a string."
	},
	"void CPersistence::Clear(const PersistID_t ID, const string& in szKey)": {
		"prefix": "Clear",
		"body" : [ "Clear( ${1:const PersistID_t ID}, ${2:const string& in szKey} )" ],
		"description" : "Clears the given value."
	},
	"void CPersistence::Clear(const PersistID_t ID)": {
		"prefix": "Clear",
		"body" : [ "Clear( ${1:const PersistID_t ID} )" ],
		"description" : "Clears all values."
	},
	"const PersistID_t CPersistence::INVALID_ID": {
		"prefix": "INVALID_ID",
		"body" : [ "INVALID_ID" ],
		"description" : "Id used by invalid persistence objects."
	},
	"void CPlayerFuncs::SayText(CBasePlayer@ pTargetPlayer, const string& in szText)": {
		"prefix": "SayText",
		"body" : [ "SayText( ${1:CBasePlayer@ pTargetPlayer}, ${2:const string& in szText} )" ],
		"description" : "Says text to a specific player"
	},
	"void CPlayerFuncs::SayTextAll(CBasePlayer@ pOriginatingPlayer, const string& in szText)": {
		"prefix": "SayTextAll",
		"body" : [ "SayTextAll( ${1:CBasePlayer@ pOriginatingPlayer}, ${2:const string& in szText} )" ],
		"description" : "Says text to all players"
	},
	"void CPlayerFuncs::ClientPrint(CBasePlayer@ pTargetPlayer, HUD iMsgDest, const string& in szMessage, const string& in szLine2 = \"\", const string& in szLine3 = \"\", const string& in szLine4 = \"\", const string& in szLine5 = \"\")": {
		"prefix": "ClientPrint",
		"body" : [ "ClientPrint( ${1:CBasePlayer@ pTargetPlayer}, ${2:HUD iMsgDest}, ${3:const string& in szMessage}, ${4:const string& in szLine2 = \"\"}, ${5:const string& in szLine3 = \"\"}, ${6:const string& in szLine4 = \"\"}, ${7:const string& in szLine5 = \"\"} )" ],
		"description" : "Prints one or more messages on the HUD of the given player. See HUD enum."
	},
	"void CPlayerFuncs::ClientPrintAll(HUD iMsgDest, const string& in szMessage, const string& in szLine2 = \"\", const string& in szLine3 = \"\", const string& in szLine4 = \"\", const string& in szLine5 = \"\")": {
		"prefix": "ClientPrintAll",
		"body" : [ "ClientPrintAll( ${1:HUD iMsgDest}, ${2:const string& in szMessage}, ${3:const string& in szLine2 = \"\"}, ${4:const string& in szLine3 = \"\"}, ${5:const string& in szLine4 = \"\"}, ${6:const string& in szLine5 = \"\"} )" ],
		"description" : "Prints one or more messages on the HUD of all players. See HUD enum."
	},
	"void CPlayerFuncs::CenterPrintAll(const string& in szMessage, const string& in szLine2 = \"\", const string& in szLine3 = \"\", const string& in szLine4 = \"\", const string& in szLine5 = \"\")": {
		"prefix": "CenterPrintAll",
		"body" : [ "CenterPrintAll( ${1:const string& in szMessage}, ${2:const string& in szLine2 = \"\"}, ${3:const string& in szLine3 = \"\"}, ${4:const string& in szLine4 = \"\"}, ${5:const string& in szLine5 = \"\"} )" ],
		"description" : "Prints one or more messages centered on the HUD of all players."
	},
	"void CPlayerFuncs::ShowMessage(CBasePlayer@ pTargetPlayer, const string& in szString)": {
		"prefix": "ShowMessage",
		"body" : [ "ShowMessage( ${1:CBasePlayer@ pTargetPlayer}, ${2:const string& in szString} )" ],
		"description" : "Shows a message to the given player."
	},
	"void CPlayerFuncs::ShowMessageAll(const string& in szString)": {
		"prefix": "ShowMessageAll",
		"body" : [ "ShowMessageAll( ${1:const string& in szString} )" ],
		"description" : "Shows a message to all players."
	},
	"void CPlayerFuncs::HudMessage(CBasePlayer@ pTargetPlayer, const HUDTextParams& in textParams, const string& in szMessage)": {
		"prefix": "HudMessage",
		"body" : [ "HudMessage( ${1:CBasePlayer@ pTargetPlayer}, ${2:const HUDTextParams& in textParams}, ${3:const string& in szMessage} )" ],
		"description" : "Shows a HUD message to a given player."
	},
	"void CPlayerFuncs::HudMessageAll(const HUDTextParams& in textParams, const string& in szMessage)": {
		"prefix": "HudMessageAll",
		"body" : [ "HudMessageAll( ${1:const HUDTextParams& in textParams}, ${2:const string& in szMessage} )" ],
		"description" : "Shows a HUD message to all players."
	},
	"void CPlayerFuncs::PrintKeyBindingString(CBasePlayer@ pPlayer, const string& in szString)": {
		"prefix": "PrintKeyBindingString",
		"body" : [ "PrintKeyBindingString( ${1:CBasePlayer@ pPlayer}, ${2:const string& in szString} )" ],
		"description" : "Prints a string containing key bindings to the screen of the given player."
	},
	"void CPlayerFuncs::PrintKeyBindingStringAll(const string& in szString)": {
		"prefix": "PrintKeyBindingStringAll",
		"body" : [ "PrintKeyBindingStringAll( ${1:const string& in szString} )" ],
		"description" : "Prints a string containing key bindings to the screen of all players."
	},
	"void CPlayerFuncs::HudToggleElement(CBasePlayer@ pTargetPlayer, uint8 iChannel, bool fVisible)": {
		"prefix": "HudToggleElement",
		"body" : [ "HudToggleElement( ${1:CBasePlayer@ pTargetPlayer}, ${2:uint8 iChannel}, ${3:bool fVisible} )" ],
		"description" : "Shows or hides HUD element occupying a given channel."
	},
	"void CPlayerFuncs::HudCustomSprite(CBasePlayer@ pTargetPlayer, const HUDSpriteParams& in params)": {
		"prefix": "HudCustomSprite",
		"body" : [ "HudCustomSprite( ${1:CBasePlayer@ pTargetPlayer}, ${2:const HUDSpriteParams& in params} )" ],
		"description" : "Shows a custom HUD sprite to a given player or to all players if pTargetPlayer is not specified."
	},
	"void CPlayerFuncs::HudNumDisplay(CBasePlayer@ pTargetPlayer, const HUDNumDisplayParams& in params)": {
		"prefix": "HudNumDisplay",
		"body" : [ "HudNumDisplay( ${1:CBasePlayer@ pTargetPlayer}, ${2:const HUDNumDisplayParams& in params} )" ],
		"description" : "Shows a custom numeric display to a given player or to all players if pTargetPlayer is not specified."
	},
	"void CPlayerFuncs::HudUpdateNum(CBasePlayer@ pTargetPlayer, uint8 iChannel, float flValue)": {
		"prefix": "HudUpdateNum",
		"body" : [ "HudUpdateNum( ${1:CBasePlayer@ pTargetPlayer}, ${2:uint8 iChannel}, ${3:float flValue} )" ],
		"description" : "Updates value of a custom numberic display."
	},
	"void CPlayerFuncs::HudTimeDisplay(CBasePlayer@ pTargetPlayer, const HUDNumDisplayParams& in params)": {
		"prefix": "HudTimeDisplay",
		"body" : [ "HudTimeDisplay( ${1:CBasePlayer@ pTargetPlayer}, ${2:const HUDNumDisplayParams& in params} )" ],
		"description" : "Shows a custom time display to a given player or to all players if pTargetPlayer is not specified."
	},
	"void CPlayerFuncs::HudUpdateTime(CBasePlayer@ pTargetPlayer, uint8 iChannel, float flTime)": {
		"prefix": "HudUpdateTime",
		"body" : [ "HudUpdateTime( ${1:CBasePlayer@ pTargetPlayer}, ${2:uint8 iChannel}, ${3:float flTime} )" ],
		"description" : "Updates value of a custom time display."
	},
	"CBasePlayer@ CPlayerFuncs::FindPlayerByIndex(int index)": {
		"prefix": "FindPlayerByIndex",
		"body" : [ "FindPlayerByIndex( ${1:int index} )" ],
		"description" : "Finds a player by index"
	},
	"CBasePlayer@ CPlayerFuncs::FindPlayerByName(const string& in szName, bool bCaseSensitive = true)": {
		"prefix": "FindPlayerByName",
		"body" : [ "FindPlayerByName( ${1:const string& in szName}, ${2:bool bCaseSensitive = true} )" ],
		"description" : "Finds a player by name"
	},
	"int CPlayerFuncs::GetNumPlayers() const": {
		"prefix": "GetNumPlayers",
		"body" : [ "GetNumPlayers()" ],
		"description" : "Gets the number of players that are currently connected to the server."
	},
	"void CPlayerFuncs::ScreenShake(const Vector& in center, float amplitude, float frequency, float duration, float radius)": {
		"prefix": "ScreenShake",
		"body" : [ "ScreenShake( ${1:const Vector& in center}, ${2:float amplitude}, ${3:float frequency}, ${4:float duration}, ${5:float radius} )" ],
		"description" : "Shakes the screen for players near a certain location"
	},
	"void CPlayerFuncs::ScreenShakeAll(const Vector& in center, float amplitude, float frequency, float duration)": {
		"prefix": "ScreenShakeAll",
		"body" : [ "ScreenShakeAll( ${1:const Vector& in center}, ${2:float amplitude}, ${3:float frequency}, ${4:float duration} )" ],
		"description" : "Shakes the screen for all players"
	},
	"void CPlayerFuncs::ScreenFade(CBaseEntity@ pEntity, const Vector& in color, float fadeTime, float fadeHold, int alpha, int flags)": {
		"prefix": "ScreenFade",
		"body" : [ "ScreenFade( ${1:CBaseEntity@ pEntity}, ${2:const Vector& in color}, ${3:float fadeTime}, ${4:float fadeHold}, ${5:int alpha}, ${6:int flags} )" ],
		"description" : "Shows a message to a given player."
	},
	"void CPlayerFuncs::ScreenFadeAll(const Vector& in color, float fadeTime, float fadeHold, int alpha, int flags)": {
		"prefix": "ScreenFadeAll",
		"body" : [ "ScreenFadeAll( ${1:const Vector& in color}, ${2:float fadeTime}, ${3:float fadeHold}, ${4:int alpha}, ${5:int flags} )" ],
		"description" : "Shows a message to all players."
	},
	"void CPlayerFuncs::ConcussionEffect(CBaseEntity@ pEntity, float amplitude, float frequency, float fadeTime)": {
		"prefix": "ConcussionEffect",
		"body" : [ "ConcussionEffect( ${1:CBaseEntity@ pEntity}, ${2:float amplitude}, ${3:float frequency}, ${4:float fadeTime} )" ],
		"description" : "Applies concussion effect to a given player."
	},
	"bool CPlayerFuncs::GetNextBestWeapon(CBasePlayer@ pPlayer, CBasePlayerItem@ pCurrentWeapon)": {
		"prefix": "GetNextBestWeapon",
		"body" : [ "GetNextBestWeapon( ${1:CBasePlayer@ pPlayer}, ${2:CBasePlayerItem@ pCurrentWeapon} )" ],
		"description" : "Makes the given player select the next best weapon available, based on the current weapon."
	},
	"bool CPlayerFuncs::CheatsAllowed(CBasePlayer@ pPlayer, const string& in szCheatName, bool fMustBeAlive = true, bool fNoMessage = false) const": {
		"prefix": "CheatsAllowed",
		"body" : [ "CheatsAllowed( ${1:CBasePlayer@ pPlayer}, ${2:const string& in szCheatName}, ${3:bool fMustBeAlive = true}, ${4:bool fNoMessage = false} )" ],
		"description" : "Returns whether cheats are enabled for the given player."
	},
	"AdminLevel_t CPlayerFuncs::AdminLevel(CBasePlayer@ pPlayer) const": {
		"prefix": "AdminLevel",
		"body" : [ "AdminLevel( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Returns the admin level for a given player."
	},
	"string CPlayerFuncs::AdminLevelToString(const AdminLevel_t adminLevel) const": {
		"prefix": "AdminLevelToString",
		"body" : [ "AdminLevelToString( ${1:const AdminLevel_t adminLevel} )" ],
		"description" : "Converts the admin level to a string. If the level is an invalid value, an empty string is returned"
	},
	"AdminLevel_t CPlayerFuncs::StringToAdminLevel(const string& in szString) const": {
		"prefix": "StringToAdminLevel",
		"body" : [ "StringToAdminLevel( ${1:const string& in szString} )" ],
		"description" : "Converts a string containing one of AdminLevelToString's return values to an admin level.Returns ADMIN_NO if the string cannot be converted to a suitable constant"
	},
	"void CPlayerFuncs::ApplyMapCfgToPlayer(CBasePlayer@ pPlayer, bool fReEquip = false)": {
		"prefix": "ApplyMapCfgToPlayer",
		"body" : [ "ApplyMapCfgToPlayer( ${1:CBasePlayer@ pPlayer}, ${2:bool fReEquip = false} )" ],
		"description" : "Applies the map configuration on the given player. Will stack if called multiple times, unless fReEquip is true, in which case the player is stripped of all weapons and ammo first."
	},
	"void CPlayerFuncs::RespawnPlayer(CBasePlayer@ pPlayer, bool fMoveLivingPlayers = true, bool fRespawnDeadPlayers = false)": {
		"prefix": "RespawnPlayer",
		"body" : [ "RespawnPlayer( ${1:CBasePlayer@ pPlayer}, ${2:bool fMoveLivingPlayers = true}, ${3:bool fRespawnDeadPlayers = false} )" ],
		"description" : "Relocates the given player to an active spawn point. If the player is dead and fRespawnDeadPlayers is true, the player is respawned."
	},
	"void CPlayerFuncs::RespawnAllPlayers(bool fMoveLivingPlayers = true, bool fRespawnDeadPlayers = false)": {
		"prefix": "RespawnAllPlayers",
		"body" : [ "RespawnAllPlayers( ${1:bool fMoveLivingPlayers = true}, ${2:bool fRespawnDeadPlayers = false} )" ],
		"description" : "Relocates all players to active spawn points. If a player is dead and fRespawnDeadPlayers is true, the player is respawned."
	},
	"bool CPlayerFuncs::SpawnPointFilterPasses(CBaseEntity@ pSpawnEnt, CBaseEntity@ pPlayer)": {
		"prefix": "SpawnPointFilterPasses",
		"body" : [ "SpawnPointFilterPasses( ${1:CBaseEntity@ pSpawnEnt}, ${2:CBaseEntity@ pPlayer} )" ],
		"description" : "Returns whether the given player passes the given spawn point's filter"
	},
	"bool CPlayerFuncs::IsSpawnPointValid(CBaseEntity@ pSpawnEnt, CBaseEntity@ pPlayer)": {
		"prefix": "IsSpawnPointValid",
		"body" : [ "IsSpawnPointValid( ${1:CBaseEntity@ pSpawnEnt}, ${2:CBaseEntity@ pPlayer} )" ],
		"description" : "Returns whether the given spawn point is valid for the given player"
	},
	"bool CPlayerFuncs::IsSpawnPointOccupied(CBaseEntity@ pSpawnEnt)": {
		"prefix": "IsSpawnPointOccupied",
		"body" : [ "IsSpawnPointOccupied( ${1:CBaseEntity@ pSpawnEnt} )" ],
		"description" : "Returns whether the given spawn point entity is occupied"
	},
	"int CPlayerFuncs::SharedRandomLong(uint iRandomSeed, int iLow, int iHigh)": {
		"prefix": "SharedRandomLong",
		"body" : [ "SharedRandomLong( ${1:uint iRandomSeed}, ${2:int iLow}, ${3:int iHigh} )" ],
		"description" : "Gets a random long whose value is the same on both the client and server."
	},
	"float CPlayerFuncs::SharedRandomFloat(uint iRandomSeed, float iLow, float iHigh)": {
		"prefix": "SharedRandomFloat",
		"body" : [ "SharedRandomFloat( ${1:uint iRandomSeed}, ${2:float iLow}, ${3:float iHigh} )" ],
		"description" : "Gets a random float whose value is the same on both the client and server."
	},
	"int CPlayerFuncs::GetAmmoIndex(const string& in szAmmoName)": {
		"prefix": "GetAmmoIndex",
		"body" : [ "GetAmmoIndex( ${1:const string& in szAmmoName} )" ],
		"description" : "Gets the index of the given ammo, or -1 if it is invalid"
	},
	"CBasePlayer@ CPlayerFuncs::CreateBot(const string& in szName)": {
		"prefix": "CreateBot",
		"body" : [ "CreateBot( ${1:const string& in szName} )" ],
		"description" : "Creates a bot with the given name."
	},
	"void CPlayerFuncs::BotDisconnect(CBasePlayer@ pBot)": {
		"prefix": "BotDisconnect",
		"body" : [ "BotDisconnect( ${1:CBasePlayer@ pBot} )" ],
		"description" : "Disconnects the bot. This will call ClientDisconnect and removes the entity. Do not use the entity after this call."
	},
	"array<string>@ CPluginManager::GetPluginList() const": {
		"prefix": "GetPluginList",
		"body" : [ "GetPluginList()" ],
		"description" : "Gets the list of plugins as strings."
	},
	"IReflectionGroup Reflection::CReflection::Engine": {
		"prefix": "Engine",
		"body" : [ "Reflection::Engine" ],
		"description" : "Engine group"
	},
	"IReflectionGroup Reflection::CReflection::Module": {
		"prefix": "Module",
		"body" : [ "Reflection::Module" ],
		"description" : "Module group"
	},
	"float CScheduledFunction::GetNextCallTime() const": {
		"prefix": "GetNextCallTime",
		"body" : [ "GetNextCallTime()" ],
		"description" : "Gets the next call time, in seconds"
	},
	"void CScheduledFunction::SetNextCallTime(const float flNextCallTime)": {
		"prefix": "SetNextCallTime",
		"body" : [ "SetNextCallTime( ${1:const float flNextCallTime} )" ],
		"description" : "Sets the next call time, in seconds. Is an absolute value (g_Engine.time + RepeatTime by default).Times in the past will result in a call on the next frame."
	},
	"float CScheduledFunction::GetRepeatTime() const": {
		"prefix": "GetRepeatTime",
		"body" : [ "GetRepeatTime()" ],
		"description" : "Gets the repeat time, in seconds"
	},
	"void CScheduledFunction::SetRepeatTime(const float flRepeatTime)": {
		"prefix": "SetRepeatTime",
		"body" : [ "SetRepeatTime( ${1:const float flRepeatTime} )" ],
		"description" : "Sets the repeat time, in seconds. Must be a positive value (may be zero)"
	},
	"int CScheduledFunction::GetRepeatCount() const": {
		"prefix": "GetRepeatCount",
		"body" : [ "GetRepeatCount()" ],
		"description" : "Gets the repeat count"
	},
	"bool CScheduledFunction::IsInfiniteRepeat() const": {
		"prefix": "IsInfiniteRepeat",
		"body" : [ "IsInfiniteRepeat()" ],
		"description" : "Returns whether this function repeats infinitely"
	},
	"void CScheduledFunction::SetRepeatCount(const int iRepeatCount)": {
		"prefix": "SetRepeatCount",
		"body" : [ "SetRepeatCount( ${1:const int iRepeatCount} )" ],
		"description" : "Sets the repeat count. Must be a positive value (may be zero) or REPEAT_INFINITE_TIMES"
	},
	"void CScheduledFunction::MakeInfiniteRepeat()": {
		"prefix": "MakeInfiniteRepeat",
		"body" : [ "MakeInfiniteRepeat()" ],
		"description" : "Makes this an infinite repeat function"
	},
	"bool CScheduledFunction::HasBeenRemoved() const": {
		"prefix": "HasBeenRemoved",
		"body" : [ "HasBeenRemoved()" ],
		"description" : "Returns whether this function has been removed from the scheduler or not"
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay}, ${3:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay}, ${3:?& in}, ${4:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay}, ${3:?& in}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:const string& in szFunction}, ${2:float flDelay}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay}, ${4:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetTimeout",
		"body" : [ "SetTimeout( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flDelay}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in}, ${11:?& in} )" ],
		"description" : "Adds a timer that calls the given function after flDelay seconds. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). The given function is called an infinite number of times."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). The given function is called an infinite number of times. Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount}, ${4:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:const string& in szFunction}, ${2:float flRepeatTime}, ${3:int iRepeatCount}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in}, ${11:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES)."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount}, ${5:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in}, ${11:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"CScheduledFunction@ CScheduler::SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "SetInterval",
		"body" : [ "SetInterval( ${1:?& in thisObject}, ${2:const string& in szFunction}, ${3:float flRepeatTime}, ${4:int iRepeatCount}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in}, ${11:?& in}, ${12:?& in} )" ],
		"description" : "Adds a timer that calls the given function every flRepeatTime seconds,. for iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES). Calls object methods."
	},
	"void CScheduler::RemoveTimer(CScheduledFunction@ pFunction)": {
		"prefix": "RemoveTimer",
		"body" : [ "RemoveTimer( ${1:CScheduledFunction@ pFunction} )" ],
		"description" : "Removes the given function from the list of functions to call."
	},
	"CScheduledFunction@ CScheduler::GetCurrentFunction() const": {
		"prefix": "GetCurrentFunction",
		"body" : [ "GetCurrentFunction()" ],
		"description" : "Returns the function currently being executed, if any."
	},
	"void CScheduler::ClearTimerList()": {
		"prefix": "ClearTimerList",
		"body" : [ "ClearTimerList()" ],
		"description" : "Removes all queued functions from the list of functions to call."
	},
	"const int CScheduler::REPEAT_INFINITE_TIMES": {
		"prefix": "REPEAT_INFINITE_TIMES",
		"body" : [ "REPEAT_INFINITE_TIMES" ],
		"description" : "If passed to AddTimer, causes the given function to be called infinite times"
	},
	"const string& CScriptInfo::GetAuthor() const": {
		"prefix": "GetAuthor",
		"body" : [ "GetAuthor()" ],
		"description" : "Gets the author name."
	},
	"void CScriptInfo::SetAuthor(const string& in szAuthor)": {
		"prefix": "SetAuthor",
		"body" : [ "SetAuthor( ${1:const string& in szAuthor} )" ],
		"description" : "Sets the author name."
	},
	"const string& CScriptInfo::GetContactInfo() const": {
		"prefix": "GetContactInfo",
		"body" : [ "GetContactInfo()" ],
		"description" : "Gets the author's contact info."
	},
	"void CScriptInfo::SetContactInfo(const string& in szContactInfo)": {
		"prefix": "SetContactInfo",
		"body" : [ "SetContactInfo( ${1:const string& in szContactInfo} )" ],
		"description" : "Sets the author's contact info."
	},
	"AdminLevel_t CScriptInfo::GetMinimumAdminLevel() const": {
		"prefix": "GetMinimumAdminLevel",
		"body" : [ "GetMinimumAdminLevel()" ],
		"description" : "Gets the minimum admin level required for commands."
	},
	"void CScriptInfo::SetMinimumAdminLevel(const AdminLevel_t minimumAdminLevel)": {
		"prefix": "SetMinimumAdminLevel",
		"body" : [ "SetMinimumAdminLevel( ${1:const AdminLevel_t minimumAdminLevel} )" ],
		"description" : "Sets the minimum admin level required for commands. You cannot lower the minimum level."
	},
	"void CSound::Clear()": {
		"prefix": "Clear",
		"body" : [ "Clear()" ],
		"description" : "Clears the sound"
	},
	"void CSound::Reset()": {
		"prefix": "Reset",
		"body" : [ "Reset()" ],
		"description" : "Resets the sound"
	},
	"bool CSound::FIsSound()": {
		"prefix": "FIsSound",
		"body" : [ "FIsSound()" ],
		"description" : "Returns whether this is a sound"
	},
	"bool CSound::FIsScent()": {
		"prefix": "FIsScent",
		"body" : [ "FIsScent()" ],
		"description" : "Returns whether this is a scent"
	},
	"Vector CSound::m_vecOrigin": {
		"prefix": "m_vecOrigin",
		"body" : [ "m_vecOrigin" ],
		"description" : "Sound's location in space"
	},
	"int CSound::m_iType": {
		"prefix": "m_iType",
		"body" : [ "m_iType" ],
		"description" : "What type of sound this is"
	},
	"int CSound::m_iVolume": {
		"prefix": "m_iVolume",
		"body" : [ "m_iVolume" ],
		"description" : "How loud the sound is"
	},
	"float CSound::m_flExpireTime": {
		"prefix": "m_flExpireTime",
		"body" : [ "m_flExpireTime" ],
		"description" : "When the sound should be purged from the list"
	},
	"int CSound::m_iNext": {
		"prefix": "m_iNext",
		"body" : [ "m_iNext" ],
		"description" : "Index of next sound in this list (Active or Free)"
	},
	"int CSound::m_iNextAudible": {
		"prefix": "m_iNextAudible",
		"body" : [ "m_iNextAudible" ],
		"description" : "Temporary link that monsters use to build a list of audible sounds"
	},
	"EHandle CSound::hOwner": {
		"prefix": "hOwner",
		"body" : [ "hOwner" ],
		"description" : "Sounds now have OWNERS... (For various AI checks)"
	},
	"void CSoundEngine::PrecacheSound(const string& in szFilename)": {
		"prefix": "PrecacheSound",
		"body" : [ "PrecacheSound( ${1:const string& in szFilename} )" ],
		"description" : "Precaches the given sound. Must be called in MapInit"
	},
	"void CSoundEngine::PrecacheSound(CBaseEntity@ pEntity, const string& in szFilename)": {
		"prefix": "PrecacheSound",
		"body" : [ "PrecacheSound( ${1:CBaseEntity@ pEntity}, ${2:const string& in szFilename} )" ],
		"description" : "Precaches the given sound for the given entity. Supports entity sound replacement. Must be called in MapInit"
	},
	"string CSoundEngine::FindSoundReplacementSample(CBaseEntity@ pEntity, const string& in szSample) const": {
		"prefix": "FindSoundReplacementSample",
		"body" : [ "FindSoundReplacementSample( ${1:CBaseEntity@ pEntity}, ${2:const string& in szSample} )" ],
		"description" : "Finds the sound replacement sample for the given entity and sample.If the sample is replaced, it will return the sample used instead. Otherwise, szSample is returned."
	},
	"void CSoundEngine::PlaySound(edict_t@ entity, SOUND_CHANNEL channel, const string& in sample,float volume, float attenuation, int flags = 0, int pitch = PITCH_NORM,int target_ent_unreliable = 0, bool setOrigin = false, const Vector& in vecOrigin = g_vecZero)": {
		"prefix": "PlaySound",
		"body" : [ "PlaySound( ${1:edict_t@ entity}, ${2:SOUND_CHANNEL channel}, ${3:const string& in sample,float volume}, ${4:float attenuation}, ${5:int flags = 0}, ${6:int pitch = PITCH_NORM,int target_ent_unreliable = 0}, ${7:bool setOrigin = false}, ${8:const Vector& in vecOrigin = g_vecZero} )" ],
		"description" : "Plays the given sound with the given parameters. Sound replacement is not used here."
	},
	"void CSoundEngine::StopSound(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample, const bool fUseSoundReplacement = true)": {
		"prefix": "StopSound",
		"body" : [ "StopSound( ${1:edict_t@ entity}, ${2:SOUND_CHANNEL channel}, ${3:const string& in szSample}, ${4:const bool fUseSoundReplacement = true} )" ],
		"description" : "Stops the given sound on the given entity on the given channel. If the sound was started using PlaySound, set fUseSoundReplacement to false."
	},
	"void CSoundEngine::EmitSoundDyn(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample,float flVolume, float flAttenuation, int iFlags = 0, int iPitch = PITCH_NORM, int target_ent_unreliable = 0)": {
		"prefix": "EmitSoundDyn",
		"body" : [ "EmitSoundDyn( ${1:edict_t@ entity}, ${2:SOUND_CHANNEL channel}, ${3:const string& in szSample,float flVolume}, ${4:float flAttenuation}, ${5:int iFlags = 0}, ${6:int iPitch = PITCH_NORM}, ${7:int target_ent_unreliable = 0} )" ],
		"description" : "Plays the given sound with the given parameters. Sound replacement will affect this."
	},
	"void CSoundEngine::EmitSound(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample, float flVolume, float flAttenuation)": {
		"prefix": "EmitSound",
		"body" : [ "EmitSound( ${1:edict_t@ entity}, ${2:SOUND_CHANNEL channel}, ${3:const string& in szSample}, ${4:float flVolume}, ${5:float flAttenuation} )" ],
		"description" : "Plays the given sound with the given parameters. Sound replacement will affect this."
	},
	"void CSoundEngine::EmitSoundSuit(edict_t@ entity, const string& in szSample)": {
		"prefix": "EmitSoundSuit",
		"body" : [ "EmitSoundSuit( ${1:edict_t@ entity}, ${2:const string& in szSample} )" ],
		"description" : "Play a specific sentence over the HEV suit speaker - just pass player entity, and !sentencename."
	},
	"void CSoundEngine::EmitGroupIdSuit(edict_t@ entity, int isentencereg)": {
		"prefix": "EmitGroupIdSuit",
		"body" : [ "EmitGroupIdSuit( ${1:edict_t@ entity}, ${2:int isentencereg} )" ],
		"description" : "Play a sentence, randomly selected from the passed in group id, over the HEV suit speaker."
	},
	"void CSoundEngine::EmitGroupNameSuit(edict_t@ entity, const string& in szSample)": {
		"prefix": "EmitGroupNameSuit",
		"body" : [ "EmitGroupNameSuit( ${1:edict_t@ entity}, ${2:const string& in szSample} )" ],
		"description" : "Play a sentence, randomly selected from the passed in groupname."
	},
	"int CSoundEngine::LookupSentenceIndex(const string& in sentenceName)": {
		"prefix": "LookupSentenceIndex",
		"body" : [ "LookupSentenceIndex( ${1:const string& in sentenceName} )" ],
		"description" : "Looks up the sentence index of the given sentence"
	},
	"int CSoundEngine::LookupSentenceGroupIndex(const string& in szGroup)": {
		"prefix": "LookupSentenceGroupIndex",
		"body" : [ "LookupSentenceGroupIndex( ${1:const string& in szGroup} )" ],
		"description" : "Looks up the sentence group index of the given sentence"
	},
	"int CSoundEngine::PlaySentenceGroup(edict_t@ entity, const string& in szGroupName, float volume, float attenuation, int flags, int pitch)": {
		"prefix": "PlaySentenceGroup",
		"body" : [ "PlaySentenceGroup( ${1:edict_t@ entity}, ${2:const string& in szGroupName}, ${3:float volume}, ${4:float attenuation}, ${5:int flags}, ${6:int pitch} )" ],
		"description" : "Plays a sentence group"
	},
	"int CSoundEngine::PlaySentenceGroup(edict_t@ entity, int iGroupIndex, float volume, float attenuation, int flags, int pitch)": {
		"prefix": "PlaySentenceGroup",
		"body" : [ "PlaySentenceGroup( ${1:edict_t@ entity}, ${2:int iGroupIndex}, ${3:float volume}, ${4:float attenuation}, ${5:int flags}, ${6:int pitch} )" ],
		"description" : "Plays a sentence group"
	},
	"int CSoundEngine::PlaySentenceGroupSequential(edict_t@ entity, const string& in szGroupName,float volume, float attenuation, int flags, int pitch, int ipick, const bool bReset)": {
		"prefix": "PlaySentenceGroupSequential",
		"body" : [ "PlaySentenceGroupSequential( ${1:edict_t@ entity}, ${2:const string& in szGroupName,float volume}, ${3:float attenuation}, ${4:int flags}, ${5:int pitch}, ${6:int ipick}, ${7:const bool bReset} )" ],
		"description" : "Plays a sentence group sequentially"
	},
	"void CSoundEngine::EmitAmbientSound(edict_t@ entity, const Vector& in vecOrigin, const string& in szSample,float flVolume, float flAttenuation, int fFlags, int iPitch)": {
		"prefix": "EmitAmbientSound",
		"body" : [ "EmitAmbientSound( ${1:edict_t@ entity}, ${2:const Vector& in vecOrigin}, ${3:const string& in szSample,float flVolume}, ${4:float flAttenuation}, ${5:int fFlags}, ${6:int iPitch} )" ],
		"description" : "Plays a sentence group sequentially"
	},
	"float CSoundEngine::PlayHitSound(TraceResult& in tr, const Vector& in vecSrc, const Vector& in vecEnd, int iBulletType)": {
		"prefix": "PlayHitSound",
		"body" : [ "PlayHitSound( ${1:TraceResult& in tr}, ${2:const Vector& in vecSrc}, ${3:const Vector& in vecEnd}, ${4:int iBulletType} )" ],
		"description" : "Plays a hit sound based on the trace result's hit target. Returns the volume at which the hit is being played."
	},
	"char CSoundEngine::FindMaterialType(const string& in szMaterial) const": {
		"prefix": "FindMaterialType",
		"body" : [ "FindMaterialType( ${1:const string& in szMaterial} )" ],
		"description" : "Maps the texture name to a material type. See the TextureType enum."
	},
	"void CSoundEnt::InsertSound(int iType, const Vector& in vecOrigin, int iVolume, float flDuration, CBaseEntity@ pOwner)": {
		"prefix": "InsertSound",
		"body" : [ "InsertSound( ${1:int iType}, ${2:const Vector& in vecOrigin}, ${3:int iVolume}, ${4:float flDuration}, ${5:CBaseEntity@ pOwner} )" ],
		"description" : "Inserts a sound. iType is one of the bits_SOUND enum."
	},
	"int CSoundEnt::ActiveList()": {
		"prefix": "ActiveList",
		"body" : [ "ActiveList()" ],
		"description" : "Returns the head of the active list."
	},
	"int CSoundEnt::FreeList()": {
		"prefix": "FreeList",
		"body" : [ "FreeList()" ],
		"description" : "Returns the head of the free list."
	},
	"CSound@ CSoundEnt::SoundPointerForIndex(int iIndex)": {
		"prefix": "SoundPointerForIndex",
		"body" : [ "SoundPointerForIndex( ${1:int iIndex} )" ],
		"description" : "Return a pointer for this index in the sound list. Index must be between 0 and MAX_WORLD_SOUNDS."
	},
	"int CSoundEnt::ClientSoundIndex(edict_t@ pClient)": {
		"prefix": "ClientSoundIndex",
		"body" : [ "ClientSoundIndex( ${1:edict_t@ pClient} )" ],
		"description" : "Gets the index for the given client."
	},
	"bool CSoundEnt::IsEmpty()": {
		"prefix": "IsEmpty",
		"body" : [ "IsEmpty()" ],
		"description" : "Returns whether the sound list is empty."
	},
	"int CSoundEnt::ISoundsInList(int iListType)": {
		"prefix": "ISoundsInList",
		"body" : [ "ISoundsInList( ${1:int iListType} )" ],
		"description" : "Returns the number of sounds in the given list. Must be either SOUNDLISTTYPE_FREE or SOUNDLISTTYPE_ACTIVE."
	},
	"const int CSoundEnt::m_cLastActiveSounds": {
		"prefix": "m_cLastActiveSounds",
		"body" : [ "m_cLastActiveSounds" ],
		"description" : "keeps track of the number of active sounds at the last update. (for diagnostic work)"
	},
	"CBaseEntity@ CSprite::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"const Vector& CSprite::GetOrigin() const": {
		"prefix": "GetOrigin",
		"body" : [ "GetOrigin()" ],
		"description" : "Gets the entity's (absolute) origin."
	},
	"void CSprite::SetOrigin(const Vector& in vecOrigin)": {
		"prefix": "SetOrigin",
		"body" : [ "SetOrigin( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Sets this entity's (absolute) origin"
	},
	"bool CSprite::KeyValue(const string& in szKeyName, const string& in szValue)": {
		"prefix": "KeyValue",
		"body" : [ "KeyValue( ${1:const string& in szKeyName}, ${2:const string& in szValue} )" ],
		"description" : "Sets keyvalue data on this entity"
	},
	"void CSprite::TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceAttack",
		"body" : [ "TraceAttack( ${1:entvars_t@ pevAttacker}, ${2:float flDamage}, ${3:const Vector& in vecDir}, ${4:TraceResult& in traceResult}, ${5:int bitsDamageType} )" ],
		"description" : "Traces an attack by the given entity to this entity."
	},
	"void CSprite::TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType)": {
		"prefix": "TraceBleed",
		"body" : [ "TraceBleed( ${1:float flDamage}, ${2:const Vector& in vecDir}, ${3:TraceResult& in traceResult}, ${4:int bitsDamageType} )" ],
		"description" : "Traces entity bleed event."
	},
	"int CSprite::GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true)": {
		"prefix": "GiveAmmo",
		"body" : [ "GiveAmmo( ${1:int iAmount}, ${2:const string& in szName}, ${3:int iMax}, ${4:const bool fFromWeapon = true} )" ],
		"description" : "Gives ammo to this entity."
	},
	"bool CSprite::HasTarget(const string& in szTarget)": {
		"prefix": "HasTarget",
		"body" : [ "HasTarget( ${1:const string& in szTarget} )" ],
		"description" : "Returns whether this entity has the given target."
	},
	"string CSprite::TeamID()": {
		"prefix": "TeamID",
		"body" : [ "TeamID()" ],
		"description" : "Returns this entity's team ID."
	},
	"string CSprite::GetClassname() const": {
		"prefix": "GetClassname",
		"body" : [ "GetClassname()" ],
		"description" : "Returns this entity's class name."
	},
	"string CSprite::GetTargetname() const": {
		"prefix": "GetTargetname",
		"body" : [ "GetTargetname()" ],
		"description" : "Returns this entity's target name."
	},
	"bool CSprite::FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart)": {
		"prefix": "FVisibleFromPos",
		"body" : [ "FVisibleFromPos( ${1:const Vector& in vecTarget}, ${2:const Vector& in vecStart} )" ],
		"description" : "Returns whether this entity is visible from the given position."
	},
	"string CSprite::SOUNDREPLACEMENT_Find(const string& in szFilename)": {
		"prefix": "SOUNDREPLACEMENT_Find",
		"body" : [ "SOUNDREPLACEMENT_Find( ${1:const string& in szFilename} )" ],
		"description" : "Find sound replacement for the given file."
	},
	"int CSprite::FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask)": {
		"prefix": "FindMonstersInWorld",
		"body" : [ "FindMonstersInWorld( ${1:array<CBaseEntity@>@ pArray}, ${2:int flagMask} )" ],
		"description" : "Finds monsters in the world"
	},
	"bool CSprite::IsPlayerAlly() const": {
		"prefix": "IsPlayerAlly",
		"body" : [ "IsPlayerAlly()" ],
		"description" : "Returns whether this entity is allied to players."
	},
	"void CSprite::SetPlayerAlly(bool fState)": {
		"prefix": "SetPlayerAlly",
		"body" : [ "SetPlayerAlly( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status."
	},
	"void CSprite::SetPlayerAllyDirect(bool fState)": {
		"prefix": "SetPlayerAllyDirect",
		"body" : [ "SetPlayerAllyDirect( ${1:bool fState} )" ],
		"description" : "Sets this entity's player ally status. Use this only if you need the setting to be exactly what you give it (e.g. when copying from another monster)"
	},
	"bool CSprite::opEquals(CBaseEntity@ pOther)": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Compares 2 entities for equality."
	},
	"void CSprite::Precache()": {
		"prefix": "Precache",
		"body" : [ "Precache()" ],
		"description" : "Precaches the entity. Do not call directly."
	},
	"int CSprite::ObjectCaps()": {
		"prefix": "ObjectCaps",
		"body" : [ "ObjectCaps()" ],
		"description" : "Gets this entity's objects caps. See the FCAP enum."
	},
	"void CSprite::SetObjectCollisionBox()": {
		"prefix": "SetObjectCollisionBox",
		"body" : [ "SetObjectCollisionBox()" ],
		"description" : "Sets up the object collision box."
	},
	"int CSprite::GetClassification(int cl)": {
		"prefix": "GetClassification",
		"body" : [ "GetClassification( ${1:int cl} )" ],
		"description" : "Gets this entity's classification. Returns the given value if none is set. See the CLASSIFICATION enum."
	},
	"const string& CSprite::GetClassificationTag()": {
		"prefix": "GetClassificationTag",
		"body" : [ "GetClassificationTag()" ],
		"description" : "Gets this entity's classification tag."
	},
	"const string& CSprite::GetClassificationName()": {
		"prefix": "GetClassificationName",
		"body" : [ "GetClassificationName()" ],
		"description" : "Gets this entity's classification name."
	},
	"void CSprite::SetClassification(int cl)": {
		"prefix": "SetClassification",
		"body" : [ "SetClassification( ${1:int cl} )" ],
		"description" : "Sets this entity's classification override. Can override the entity's player ally setting."
	},
	"void CSprite::SetClassificationFromEntity(CBaseEntity@ pEntity)": {
		"prefix": "SetClassificationFromEntity",
		"body" : [ "SetClassificationFromEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Sets this entity's classification override to the classification override set on the given entity. Can override the entity's player ally setting."
	},
	"void CSprite::ClearClassification()": {
		"prefix": "ClearClassification",
		"body" : [ "ClearClassification()" ],
		"description" : "Clears this entity's classification override."
	},
	"int CSprite::IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false)": {
		"prefix": "IRelationship",
		"body" : [ "IRelationship( ${1:CBaseEntity@ other}, ${2:bool ignoreNoTarget = false} )" ],
		"description" : "Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum."
	},
	"int CSprite::IRelationshipByClass(CLASS iClass)": {
		"prefix": "IRelationshipByClass",
		"body" : [ "IRelationshipByClass( ${1:CLASS iClass} )" ],
		"description" : "Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum."
	},
	"int CSprite::Classify()": {
		"prefix": "Classify",
		"body" : [ "Classify()" ],
		"description" : "Gets this entity's classification."
	},
	"int CSprite::TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType)": {
		"prefix": "TakeDamage",
		"body" : [ "TakeDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise."
	},
	"bool CSprite::TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0)": {
		"prefix": "TakeHealth",
		"body" : [ "TakeHealth( ${1:float flHealth}, ${2:int bitsDamageType}, ${3:int health_cap = 0} )" ],
		"description" : "Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won't add more than health_cap. Returns true if it took damage, false otherwise."
	},
	"bool CSprite::TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0)": {
		"prefix": "TakeArmor",
		"body" : [ "TakeArmor( ${1:float flArmor}, ${2:int bitsDamageType}, ${3:int armor_cap = 0} )" ],
		"description" : "Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won't add more than armor_cap. Returns 1 if it took damage, 0 otherwise."
	},
	"void CSprite::Killed(entvars_t@pevAtttacker, int iGibbed)": {
		"prefix": "Killed",
		"body" : [ "Killed( ${1:entvars_t@pevAtttacker}, ${2:int iGibbed} )" ],
		"description" : "Tells this entity it's been killed. See the GIB enum for possible values."
	},
	"int CSprite::BloodColor()": {
		"prefix": "BloodColor",
		"body" : [ "BloodColor()" ],
		"description" : "Returns the blood color. See the BLOOD_COLOR enum."
	},
	"bool CSprite::IsTriggered(CBaseEntity@ pActivator)": {
		"prefix": "IsTriggered",
		"body" : [ "IsTriggered( ${1:CBaseEntity@ pActivator} )" ],
		"description" : "Returns whether this entity is triggered by the given entity."
	},
	"CBaseMonster@ CSprite::MyMonsterPointer()": {
		"prefix": "MyMonsterPointer",
		"body" : [ "MyMonsterPointer()" ],
		"description" : "Returns this entity as its monster entity, if it is a monster."
	},
	"CustomKeyvalues@ CSprite::GetCustomKeyvalues()": {
		"prefix": "GetCustomKeyvalues",
		"body" : [ "GetCustomKeyvalues()" ],
		"description" : "Gets this entity's custom keyvalues."
	},
	"bool CSprite::BlockedByEntity(CBaseEntity@ pOther, float flDamage)": {
		"prefix": "BlockedByEntity",
		"body" : [ "BlockedByEntity( ${1:CBaseEntity@ pOther}, ${2:float flDamage} )" ],
		"description" : "Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable."
	},
	"void CSprite::SUB_Remove()": {
		"prefix": "SUB_Remove",
		"body" : [ "SUB_Remove()" ],
		"description" : "Think function. Delay-removes this entity."
	},
	"void CSprite::SUB_DoNothing()": {
		"prefix": "SUB_DoNothing",
		"body" : [ "SUB_DoNothing()" ],
		"description" : "Think function. Explicitly does nothing."
	},
	"void CSprite::SUB_StartFadeOut()": {
		"prefix": "SUB_StartFadeOut",
		"body" : [ "SUB_StartFadeOut()" ],
		"description" : "Think function. Starts fading this entity."
	},
	"void CSprite::SUB_FadeOut()": {
		"prefix": "SUB_FadeOut",
		"body" : [ "SUB_FadeOut()" ],
		"description" : "Think function. Fades this entity."
	},
	"void CSprite::SUB_CallUseToggle()": {
		"prefix": "SUB_CallUseToggle",
		"body" : [ "SUB_CallUseToggle()" ],
		"description" : "Think function. Calls use toggle on this entity."
	},
	"bool CSprite::ShouldToggle(USE_TYPE useType, const bool currentState)": {
		"prefix": "ShouldToggle",
		"body" : [ "ShouldToggle( ${1:USE_TYPE useType}, ${2:const bool currentState} )" ],
		"description" : "Returns whether this entity should toggle."
	},
	"void CSprite::FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FBDM_DRAW)": {
		"prefix": "FireBullets",
		"body" : [ "FireBullets( ${1:uint cShots}, ${2:Vector vecSrc}, ${3:Vector vecDirShooting}, ${4:Vector vecSpread,float flDistance}, ${5:Bullet iBulletType}, ${6:int iTracerFreq = 4}, ${7:int iDamage = 0}, ${8:entvars_t@ pevAttacker = null}, ${9:FireBulletsDrawMode fDraw = FBDM_DRAW} )" ],
		"description" : "Fires bullets. Must call CMath::MakeAimVectors with an angle vector first."
	},
	"void CSprite::SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue)": {
		"prefix": "SUB_UseTargets",
		"body" : [ "SUB_UseTargets( ${1:CBaseEntity@ pActivator}, ${2:USE_TYPE useType}, ${3:float flValue} )" ],
		"description" : "Calls use on targets."
	},
	"bool CSprite::Intersects(CBaseEntity@ pOther)": {
		"prefix": "Intersects",
		"body" : [ "Intersects( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Returns whether this entity intersects with the given entity."
	},
	"void CSprite::MakeDormant()": {
		"prefix": "MakeDormant",
		"body" : [ "MakeDormant()" ],
		"description" : "Makes this entity dormant."
	},
	"bool CSprite::IsDormant()": {
		"prefix": "IsDormant",
		"body" : [ "IsDormant()" ],
		"description" : "Returns whether this entity is dormant."
	},
	"bool CSprite::IsLockedByMaster()": {
		"prefix": "IsLockedByMaster",
		"body" : [ "IsLockedByMaster()" ],
		"description" : "Returns whether this entity is locked by its master."
	},
	"edict_t@ CSprite::edict()": {
		"prefix": "edict",
		"body" : [ "edict()" ],
		"description" : "Returns this entity's edict."
	},
	"int CSprite::entindex()": {
		"prefix": "entindex",
		"body" : [ "entindex()" ],
		"description" : "Returns this entity's index."
	},
	"bool CSprite::SetupModel()": {
		"prefix": "SetupModel",
		"body" : [ "SetupModel()" ],
		"description" : "Sets up the model."
	},
	"int CSprite::GetToggleState()": {
		"prefix": "GetToggleState",
		"body" : [ "GetToggleState()" ],
		"description" : "Gets the toggle state. See the TOGGLE_STATE enum."
	},
	"void CSprite::AddPoints(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPoints",
		"body" : [ "AddPoints( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity."
	},
	"void CSprite::AddPointsToTeam(int score, const bool bAllowNegativeScore)": {
		"prefix": "AddPointsToTeam",
		"body" : [ "AddPointsToTeam( ${1:int score}, ${2:const bool bAllowNegativeScore} )" ],
		"description" : "Adds points to this entity's team."
	},
	"AddPlayerItemResult CSprite::AddPlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "AddPlayerItem",
		"body" : [ "AddPlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Adds the given player item to this entity."
	},
	"bool CSprite::RemovePlayerItem(CBasePlayerItem@ pItem)": {
		"prefix": "RemovePlayerItem",
		"body" : [ "RemovePlayerItem( ${1:CBasePlayerItem@ pItem} )" ],
		"description" : "Removes the given player item to this entity."
	},
	"float CSprite::GetDelay()": {
		"prefix": "GetDelay",
		"body" : [ "GetDelay()" ],
		"description" : "Gets this entity's trigger delay."
	},
	"bool CSprite::IsMoving()": {
		"prefix": "IsMoving",
		"body" : [ "IsMoving()" ],
		"description" : "Returns whether this entity is moving."
	},
	"void CSprite::OverrideReset()": {
		"prefix": "OverrideReset",
		"body" : [ "OverrideReset()" ],
		"description" : "Resets this entity."
	},
	"int CSprite::DamageDecal(int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:int bitsDamageType} )" ],
		"description" : "Returns the damage decal. See decal_e."
	},
	"void CSprite::SetToggleState(int state)": {
		"prefix": "SetToggleState",
		"body" : [ "SetToggleState( ${1:int state} )" ],
		"description" : "Sets this entity's toggle state."
	},
	"void CSprite::StartSneaking()": {
		"prefix": "StartSneaking",
		"body" : [ "StartSneaking()" ],
		"description" : "Starts sneaking."
	},
	"void CSprite::StopSneaking()": {
		"prefix": "StopSneaking",
		"body" : [ "StopSneaking()" ],
		"description" : "Stops sneaking."
	},
	"bool CSprite::OnControls(entvars_t@ pev)": {
		"prefix": "OnControls",
		"body" : [ "OnControls( ${1:entvars_t@ pev} )" ],
		"description" : "Reacts to controls set on the pev."
	},
	"bool CSprite::IsSneaking()": {
		"prefix": "IsSneaking",
		"body" : [ "IsSneaking()" ],
		"description" : "Returns whether this entity is sneaking."
	},
	"bool CSprite::IsAlive()": {
		"prefix": "IsAlive",
		"body" : [ "IsAlive()" ],
		"description" : "Returns whether this entity is alive."
	},
	"bool CSprite::IsBSPModel()": {
		"prefix": "IsBSPModel",
		"body" : [ "IsBSPModel()" ],
		"description" : "Returns whether this entity is a BSP model."
	},
	"bool CSprite::ReflectGauss()": {
		"prefix": "ReflectGauss",
		"body" : [ "ReflectGauss()" ],
		"description" : "Returns whether this entity reflects gauss shots."
	},
	"bool CSprite::IsInWorld()": {
		"prefix": "IsInWorld",
		"body" : [ "IsInWorld()" ],
		"description" : "Returns whether this entity is in the world."
	},
	"bool CSprite::IsMonster()": {
		"prefix": "IsMonster",
		"body" : [ "IsMonster()" ],
		"description" : "Returns whether this entity is a monster."
	},
	"bool CSprite::IsPlayer()": {
		"prefix": "IsPlayer",
		"body" : [ "IsPlayer()" ],
		"description" : "Returns whether this entity is a player."
	},
	"bool CSprite::IsNetClient()": {
		"prefix": "IsNetClient",
		"body" : [ "IsNetClient()" ],
		"description" : "Returns whether this is a net client."
	},
	"bool CSprite::IsPointEnt()": {
		"prefix": "IsPointEnt",
		"body" : [ "IsPointEnt()" ],
		"description" : "Returns whether this is a point entity."
	},
	"bool CSprite::IsBreakable()": {
		"prefix": "IsBreakable",
		"body" : [ "IsBreakable()" ],
		"description" : "Returns whether this is a breakable brush entity."
	},
	"bool CSprite::IsMachine()": {
		"prefix": "IsMachine",
		"body" : [ "IsMachine()" ],
		"description" : "Returns whether this is a machine."
	},
	"bool CSprite::CriticalRemove()": {
		"prefix": "CriticalRemove",
		"body" : [ "CriticalRemove()" ],
		"description" : "Removes this entity in critical situations."
	},
	"CBaseEntity@ CSprite::GetNextTarget()": {
		"prefix": "GetNextTarget",
		"body" : [ "GetNextTarget()" ],
		"description" : "Gets the next target to trigger."
	},
	"void CSprite::Think()": {
		"prefix": "Think",
		"body" : [ "Think()" ],
		"description" : "Makes this entity think. Do not call directly."
	},
	"void CSprite::Touch(CBaseEntity@ pOther)": {
		"prefix": "Touch",
		"body" : [ "Touch( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's touch function."
	},
	"void CSprite::Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f)": {
		"prefix": "Use",
		"body" : [ "Use( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue = 0.0f} )" ],
		"description" : "Trigger's this entity's use function."
	},
	"void CSprite::Blocked(CBaseEntity@ pOther)": {
		"prefix": "Blocked",
		"body" : [ "Blocked( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Triggers this entity's blocked function."
	},
	"void CSprite::UpdateOnRemove()": {
		"prefix": "UpdateOnRemove",
		"body" : [ "UpdateOnRemove()" ],
		"description" : "Updates this entity when removed."
	},
	"CBaseEntity@ CSprite::Respawn()": {
		"prefix": "Respawn",
		"body" : [ "Respawn()" ],
		"description" : "Respawns this entity."
	},
	"bool CSprite::FBecomeProne(CBaseEntity@ pOther)": {
		"prefix": "FBecomeProne",
		"body" : [ "FBecomeProne( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Makes this entity become prone."
	},
	"Vector CSprite::Center()": {
		"prefix": "Center",
		"body" : [ "Center()" ],
		"description" : "Returns this entity's center."
	},
	"Vector CSprite::EyePosition()": {
		"prefix": "EyePosition",
		"body" : [ "EyePosition()" ],
		"description" : "Returns this entity's eye position."
	},
	"Vector CSprite::EarPosition()": {
		"prefix": "EarPosition",
		"body" : [ "EarPosition()" ],
		"description" : "Returns this entity's ear position."
	},
	"Vector CSprite::BodyTarget(const Vector& in posSrc)": {
		"prefix": "BodyTarget",
		"body" : [ "BodyTarget( ${1:const Vector& in posSrc} )" ],
		"description" : "Returns this entity's body target for shooting."
	},
	"int CSprite::Illumination()": {
		"prefix": "Illumination",
		"body" : [ "Illumination()" ],
		"description" : "Returns this entity's illumination."
	},
	"bool CSprite::FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:CBaseEntity@ pEntity}, ${2:bool fIgnoreGlass} )" ],
		"description" : "Returns whether this entity is visible to the given entity."
	},
	"bool CSprite::FVisible(const Vector& in vecOrigin)": {
		"prefix": "FVisible",
		"body" : [ "FVisible( ${1:const Vector& in vecOrigin} )" ],
		"description" : "Returns whether this entity is visible from the given origin."
	},
	"bool CSprite::IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW)": {
		"prefix": "IsFacing",
		"body" : [ "IsFacing( ${1:entvars_t@ pevTest}, ${2:float flDotProduct = VIEW_FIELD_ULTRA_NARROW} )" ],
		"description" : "Returns whether this entity is facing the given entity, within the given view field."
	},
	"float CSprite::GetPointsForDamage(float flDamage)": {
		"prefix": "GetPointsForDamage",
		"body" : [ "GetPointsForDamage( ${1:float flDamage} )" ],
		"description" : "Returns the points received for damage done."
	},
	"void CSprite::GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage)": {
		"prefix": "GetDamagePoints",
		"body" : [ "GetDamagePoints( ${1:entvars_t@ pevAttacker}, ${2:entvars_t@ pevInflictor}, ${3:float flDamage} )" ],
		"description" : "Adds damage points to the inflicting entity."
	},
	"void CSprite::OnCreate()": {
		"prefix": "OnCreate",
		"body" : [ "OnCreate()" ],
		"description" : "Entity constructor."
	},
	"void CSprite::OnDestroy()": {
		"prefix": "OnDestroy",
		"body" : [ "OnDestroy()" ],
		"description" : "Entity destructor."
	},
	"bool CSprite::IsRevivable()": {
		"prefix": "IsRevivable",
		"body" : [ "IsRevivable()" ],
		"description" : "Returns whether this entity is revivable at this time."
	},
	"void CSprite::BeginRevive(float flTimeUntilRevive)": {
		"prefix": "BeginRevive",
		"body" : [ "BeginRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes."
	},
	"void CSprite::EndRevive(float flTimeUntilRevive)": {
		"prefix": "EndRevive",
		"body" : [ "EndRevive( ${1:float flTimeUntilRevive} )" ],
		"description" : "Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start."
	},
	"dictionary@ CSprite::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"dictionaryValue& CSprite::GetUserData(const string& in szKey)": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData( ${1:const string& in szKey} )" ],
		"description" : "Gets the user data stored under the specified key on this entity. Do not keep references to this data, the object might be removed from this entity. Only map scripts can use this."
	},
	"void CSprite::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data on this entity. WARNING: clears all data. Only map scripts can use this."
	},
	"void CSprite::Animate(float flFrames)": {
		"prefix": "Animate",
		"body" : [ "Animate( ${1:float flFrames} )" ],
		"description" : "Advances this sprite's frame by the given amount of frames."
	},
	"void CSprite::Expand(float flScaleSpeed, float flFadeSpeed)": {
		"prefix": "Expand",
		"body" : [ "Expand( ${1:float flScaleSpeed}, ${2:float flFadeSpeed} )" ],
		"description" : "Causes this sprite to scale up and fade at the given rates. This sprite will be removed once faded."
	},
	"void CSprite::SpriteInit(const string& in szSpriteName, const Vector& in vecOrigin)": {
		"prefix": "SpriteInit",
		"body" : [ "SpriteInit( ${1:const string& in szSpriteName}, ${2:const Vector& in vecOrigin} )" ],
		"description" : "Initializes this sprite."
	},
	"void CSprite::SetAttachment(edict_t@ pEntity, int iAttachment)": {
		"prefix": "SetAttachment",
		"body" : [ "SetAttachment( ${1:edict_t@ pEntity}, ${2:int iAttachment} )" ],
		"description" : "Makes this sprite follow the given entity."
	},
	"void CSprite::TurnOff()": {
		"prefix": "TurnOff",
		"body" : [ "TurnOff()" ],
		"description" : "Turns off this sprite."
	},
	"void CSprite::TurnOn()": {
		"prefix": "TurnOn",
		"body" : [ "TurnOn()" ],
		"description" : "Turns on this sprite."
	},
	"float CSprite::Frames() const": {
		"prefix": "Frames",
		"body" : [ "Frames()" ],
		"description" : "Gets the number of frames in this sprite."
	},
	"void CSprite::SetTransparency(int renderMode, int r, int g, int b, int renderAmount, int renderFx)": {
		"prefix": "SetTransparency",
		"body" : [ "SetTransparency( ${1:int renderMode}, ${2:int r}, ${3:int g}, ${4:int b}, ${5:int renderAmount}, ${6:int renderFx} )" ],
		"description" : "Sets the transparency of this sprite."
	},
	"void CSprite::SetTexture(int iSpriteIndex)": {
		"prefix": "SetTexture",
		"body" : [ "SetTexture( ${1:int iSpriteIndex} )" ],
		"description" : "Sets the texture used by this sprite. Is a model index returned by g_Game.PrecacheModel."
	},
	"void CSprite::SetScale(float flScale)": {
		"prefix": "SetScale",
		"body" : [ "SetScale( ${1:float flScale} )" ],
		"description" : "Sets the current scale."
	},
	"void CSprite::SetColor(int r, int g, int b)": {
		"prefix": "SetColor",
		"body" : [ "SetColor( ${1:int r}, ${2:int g}, ${3:int b} )" ],
		"description" : "Sets the color."
	},
	"void CSprite::SetBrightness(int brightness)": {
		"prefix": "SetBrightness",
		"body" : [ "SetBrightness( ${1:int brightness} )" ],
		"description" : "Sets the brightness (render amount)."
	},
	"void CSprite::AnimateAndDie(float flFramerate)": {
		"prefix": "AnimateAndDie",
		"body" : [ "AnimateAndDie( ${1:float flFramerate} )" ],
		"description" : "Makes this sprite play until time pev->dmgtime has been passed, then removes itself."
	},
	"entvars_t@ CSprite::pev": {
		"prefix": "pev",
		"body" : [ "pev" ],
		"description" : "Entity variables"
	},
	"bool CSprite::m_fOverrideClass": {
		"prefix": "m_fOverrideClass",
		"body" : [ "m_fOverrideClass" ],
		"description" : "Whether this entity overrides the classification."
	},
	"int CSprite::m_iClassSelection": {
		"prefix": "m_iClassSelection",
		"body" : [ "m_iClassSelection" ],
		"description" : "The overridden classification."
	},
	"float CSprite::m_flMaximumFadeWait": {
		"prefix": "m_flMaximumFadeWait",
		"body" : [ "m_flMaximumFadeWait" ],
		"description" : "Maximum fade wait time."
	},
	"float CSprite::m_flMaximumFadeWaitB": {
		"prefix": "m_flMaximumFadeWaitB",
		"body" : [ "m_flMaximumFadeWaitB" ],
		"description" : "Maximum fade wait time B."
	},
	"bool CSprite::m_fCanFadeStart": {
		"prefix": "m_fCanFadeStart",
		"body" : [ "m_fCanFadeStart" ],
		"description" : "Whether fading can start."
	},
	"bool CSprite::m_fCustomModel": {
		"prefix": "m_fCustomModel",
		"body" : [ "m_fCustomModel" ],
		"description" : "Whether a custom model is used."
	},
	"Vector CSprite::m_vecLastOrigin": {
		"prefix": "m_vecLastOrigin",
		"body" : [ "m_vecLastOrigin" ],
		"description" : "Last origin vector"
	},
	"string_t CSprite::targetnameOutFilterType": {
		"prefix": "targetnameOutFilterType",
		"body" : [ "targetnameOutFilterType" ],
		"description" : "Target name out filter type."
	},
	"string_t CSprite::classnameOutFilterType": {
		"prefix": "classnameOutFilterType",
		"body" : [ "classnameOutFilterType" ],
		"description" : "Class name out filter type."
	},
	"string_t CSprite::targetnameInFilterType": {
		"prefix": "targetnameInFilterType",
		"body" : [ "targetnameInFilterType" ],
		"description" : "Target name in filter type."
	},
	"string_t CSprite::classnameInFilterType": {
		"prefix": "classnameInFilterType",
		"body" : [ "classnameInFilterType" ],
		"description" : "Class name in filter type."
	},
	"int CSprite::m_iOriginalRenderMode": {
		"prefix": "m_iOriginalRenderMode",
		"body" : [ "m_iOriginalRenderMode" ],
		"description" : "Original render model."
	},
	"int CSprite::m_iOriginalRenderFX": {
		"prefix": "m_iOriginalRenderFX",
		"body" : [ "m_iOriginalRenderFX" ],
		"description" : "Original render FX."
	},
	"float CSprite::m_flOriginalRenderAmount": {
		"prefix": "m_flOriginalRenderAmount",
		"body" : [ "m_flOriginalRenderAmount" ],
		"description" : "Original render amount."
	},
	"Vector CSprite::m_vecOriginalRenderColor": {
		"prefix": "m_vecOriginalRenderColor",
		"body" : [ "m_vecOriginalRenderColor" ],
		"description" : "Original render color."
	},
	"bool CStartInventory::IsAvailable() const": {
		"prefix": "IsAvailable",
		"body" : [ "IsAvailable()" ],
		"description" : "Returns whether inventory modification is available."
	},
	"bool CStartInventory::Exists(const string& in szEntry) const": {
		"prefix": "Exists",
		"body" : [ "Exists( ${1:const string& in szEntry} )" ],
		"description" : "Returns whether the given entry is present in the inventory."
	},
	"void CStartInventory::Set(const string& in szItem, uint uiAmount)": {
		"prefix": "Set",
		"body" : [ "Set( ${1:const string& in szItem}, ${2:uint uiAmount} )" ],
		"description" : "Set an item in the inventory. Sets the amount if the item is already in the inventory."
	},
	"void CStartInventory::Set(const string& in szEntry)": {
		"prefix": "Set",
		"body" : [ "Set( ${1:const string& in szEntry} )" ],
		"description" : "Set an entry to the inventory."
	},
	"bool CStartInventory::Add(const string& in szEntry, uint uiAmount, bool fAdd = true)": {
		"prefix": "Add",
		"body" : [ "Add( ${1:const string& in szEntry}, ${2:uint uiAmount}, ${3:bool fAdd = true} )" ],
		"description" : "Add or subtract from an existing value. Inserts if the value is not already in the inventory."
	},
	"bool CStartInventory::Remove(const string& in szEntry)": {
		"prefix": "Remove",
		"body" : [ "Remove( ${1:const string& in szEntry} )" ],
		"description" : "Removes an entry from the inventory."
	},
	"bool CStartInventory::Restock(const string& in szItem, uint uiAmount)": {
		"prefix": "Restock",
		"body" : [ "Restock( ${1:const string& in szItem}, ${2:uint uiAmount} )" ],
		"description" : "Restocks the inventory with up to uiAmount of the given item. Does nothing if the current amount already exceeds the given amount."
	},
	"bool CStartInventory::Limit(const string& in szItem, uint uiAmount)": {
		"prefix": "Limit",
		"body" : [ "Limit( ${1:const string& in szItem}, ${2:uint uiAmount} )" ],
		"description" : "Limits the inventory content of the given item to at most uiAmount. Does nothing if there is less than uiAmount in the inventory."
	},
	"uint CStartInventory::GetAmount(const string& in szEntry) const": {
		"prefix": "GetAmount",
		"body" : [ "GetAmount( ${1:const string& in szEntry} )" ],
		"description" : "Gets the amount of a given entry. Returns 0 if the entry doesn't exist."
	},
	"bool CSurvivalMode::IsEnabled() const": {
		"prefix": "IsEnabled",
		"body" : [ "IsEnabled()" ],
		"description" : "Returns whether Survival Mode is enabled or not."
	},
	"void CSurvivalMode::Enable(bool fActivateNow = false)": {
		"prefix": "Enable",
		"body" : [ "Enable( ${1:bool fActivateNow = false} )" ],
		"description" : "Enable Survival Mode"
	},
	"void CSurvivalMode::Disable()": {
		"prefix": "Disable",
		"body" : [ "Disable()" ],
		"description" : "Disable Survival Mode"
	},
	"void CSurvivalMode::Toggle()": {
		"prefix": "Toggle",
		"body" : [ "Toggle()" ],
		"description" : "Toggles Survival Mode."
	},
	"bool CSurvivalMode::IsActive() const": {
		"prefix": "IsActive",
		"body" : [ "IsActive()" ],
		"description" : "Returns whether Survival Mode is active or not."
	},
	"void CSurvivalMode::Activate(bool fActivateNow = false)": {
		"prefix": "Activate",
		"body" : [ "Activate( ${1:bool fActivateNow = false} )" ],
		"description" : "Activate Survival Mode"
	},
	"int CSurvivalMode::GetVoteState()": {
		"prefix": "GetVoteState",
		"body" : [ "GetVoteState()" ],
		"description" : "Returns Survival Mode vote state."
	},
	"void CSurvivalMode::VoteToggle()": {
		"prefix": "VoteToggle",
		"body" : [ "VoteToggle()" ],
		"description" : "Toggles Survival Mode vote state."
	},
	"void CSurvivalMode::ResetVoteState()": {
		"prefix": "ResetVoteState",
		"body" : [ "ResetVoteState()" ],
		"description" : "Resets the Survival Mode vote state to undefined."
	},
	"void CSurvivalMode::EnableMapSupport()": {
		"prefix": "EnableMapSupport",
		"body" : [ "EnableMapSupport()" ],
		"description" : "Tells the game that the current map wants to use Survival Mode. Should be called in MapInit. Cannot be disabled once set."
	},
	"bool CSurvivalMode::MapSupportEnabled()": {
		"prefix": "MapSupportEnabled",
		"body" : [ "MapSupportEnabled()" ],
		"description" : "Returns whether the current map supports Survival Mode or not."
	},
	"void CSurvivalMode::SetStartOn(bool value)": {
		"prefix": "SetStartOn",
		"body" : [ "SetStartOn( ${1:bool value} )" ],
		"description" : "Sets whether Survival Mode should start when the map is loaded."
	},
	"bool CSurvivalMode::GetStartOn()": {
		"prefix": "GetStartOn",
		"body" : [ "GetStartOn()" ],
		"description" : "Returns whether Survival Mode should start when the map is loaded."
	},
	"const string& CSurvivalMode::GetNextMap(void) const": {
		"prefix": "GetNextMap",
		"body" : [ "GetNextMap( ${1:void} )" ],
		"description" : "Returns name of the next survival map."
	},
	"void CSurvivalMode::SetNextMap(const string& in szMapName)": {
		"prefix": "SetNextMap",
		"body" : [ "SetNextMap( ${1:const string& in szMapName} )" ],
		"description" : "Sets name of the next survival map."
	},
	"void CSurvivalMode::EndRound()": {
		"prefix": "EndRound",
		"body" : [ "EndRound()" ],
		"description" : "Can be used to end a round and force a retry to be used."
	},
	"float CSurvivalMode::GetDelayBeforeStart() const": {
		"prefix": "GetDelayBeforeStart",
		"body" : [ "GetDelayBeforeStart()" ],
		"description" : "Returns delay before survival mode starts."
	},
	"void CSurvivalMode::SetDelayBeforeStart(float value)": {
		"prefix": "SetDelayBeforeStart",
		"body" : [ "SetDelayBeforeStart( ${1:float value} )" ],
		"description" : "Sets delay before survival mode starts."
	},
	"CTextMenu@ CTextMenu::CTextMenu(TextMenuPlayerSlotCallback@ inputCB)": {
		"prefix": "CTextMenu",
		"body" : [ "CTextMenu( ${1:TextMenuPlayerSlotCallback@ inputCB} )" ],
		"description" : "Constructor. You must pass a player slot callback and handle the input yourself."
	},
	"TextMenuId_t CTextMenu::get_Id() const": {
		"prefix": "get_Id",
		"body" : [ "get_Id()" ],
		"description" : "Gets this text menu's id. If CTextMenus::INVALID_TEXT_MENU_ID, this is an unregistered menu."
	},
	"bool CTextMenu::IsRegistered() const": {
		"prefix": "IsRegistered",
		"body" : [ "IsRegistered()" ],
		"description" : "Returns whether this menu is registered or not."
	},
	"bool CTextMenu::Register()": {
		"prefix": "Register",
		"body" : [ "Register()" ],
		"description" : "Registers this text menu."
	},
	"void CTextMenu::Unregister()": {
		"prefix": "Unregister",
		"body" : [ "Unregister()" ],
		"description" : "Unregisters this text menu."
	},
	"void CTextMenu::Open(const int iDisplayTime, const uint page, array<edict_t@>@ pPlayers = null)": {
		"prefix": "Open",
		"body" : [ "Open( ${1:const int iDisplayTime}, ${2:const uint page}, ${3:array<edict_t@>@ pPlayers = null} )" ],
		"description" : "Opens the menu and keeps it open for the given amount of time. Time must be a positive value. Maximum 255 seconds. Pass 0 for infinite. You can optionally pass a list of players that receive this menu."
	},
	"void CTextMenu::Open(const int iDisplayTime, const uint page, CBasePlayer@ pPlayer)": {
		"prefix": "Open",
		"body" : [ "Open( ${1:const int iDisplayTime}, ${2:const uint page}, ${3:CBasePlayer@ pPlayer} )" ],
		"description" : "Opens the menu and keeps it open for the given amount of time. Time must be a positive value. Maximum 255 seconds. Pass 0 for infinite. You must pass the player that receives this menu."
	},
	"size_t CTextMenu::GetItemCount() const": {
		"prefix": "GetItemCount",
		"body" : [ "GetItemCount()" ],
		"description" : "Gets the number of items in this menu."
	},
	"uint CTextMenu::GetPageCount() const": {
		"prefix": "GetPageCount",
		"body" : [ "GetPageCount()" ],
		"description" : "Gets the number of pages in this menu."
	},
	"const CTextMenuItem@ CTextMenu::GetItem(const size_t uiIndex) const": {
		"prefix": "GetItem",
		"body" : [ "GetItem( ${1:const size_t uiIndex} )" ],
		"description" : "Gets the item at the given index."
	},
	"const string& CTextMenu::GetTitle() const": {
		"prefix": "GetTitle",
		"body" : [ "GetTitle()" ],
		"description" : "Gets the title."
	},
	"void CTextMenu::SetTitle(const string& in szTitle)": {
		"prefix": "SetTitle",
		"body" : [ "SetTitle( ${1:const string& in szTitle} )" ],
		"description" : "Sets the title."
	},
	"void CTextMenu::AddItem(const string& in szName, any@ pUserData = null)": {
		"prefix": "AddItem",
		"body" : [ "AddItem( ${1:const string& in szName}, ${2:any@ pUserData = null} )" ],
		"description" : "Adds an item to the menu."
	},
	"const string CTextMenuItem::m_szName": {
		"prefix": "m_szName",
		"body" : [ "m_szName" ],
		"description" : "Item name. Used for display."
	},
	"any@ CTextMenuItem::m_pUserData": {
		"prefix": "m_pUserData",
		"body" : [ "m_pUserData" ],
		"description" : "User data. For internal use."
	},
	"const TextMenuId_t CTextMenus::INVALID_TEXT_MENU_ID": {
		"prefix": "INVALID_TEXT_MENU_ID",
		"body" : [ "INVALID_TEXT_MENU_ID" ],
		"description" : "Invalid text menu id."
	},
	"void CustomEntityCallbackHandler::SetThinkFunction(ThinkFunction@ pFunction)": {
		"prefix": "SetThinkFunction",
		"body" : [ "SetThinkFunction( ${1:ThinkFunction@ pFunction} )" ],
		"description" : "Sets the think function for this handler's owning instance."
	},
	"void CustomEntityCallbackHandler::SetTouchFunction(TouchFunction@ pFunction)": {
		"prefix": "SetTouchFunction",
		"body" : [ "SetTouchFunction( ${1:TouchFunction@ pFunction} )" ],
		"description" : "Sets the touch function for this handler's owning instance."
	},
	"void CustomEntityCallbackHandler::SetBlockedFunction(BlockedFunction@ pFunction)": {
		"prefix": "SetBlockedFunction",
		"body" : [ "SetBlockedFunction( ${1:BlockedFunction@ pFunction} )" ],
		"description" : "Sets the blocked function for this handler's owning instance."
	},
	"void CustomEntityCallbackHandler::SetUseFunction(UseFunction@ pFunction)": {
		"prefix": "SetUseFunction",
		"body" : [ "SetUseFunction( ${1:UseFunction@ pFunction} )" ],
		"description" : "Sets the use function for this handler's owning instance."
	},
	"void CustomKeyvalue::CustomKeyvalue()": {
		"prefix": "CustomKeyvalue",
		"body" : [ "CustomKeyvalue()" ],
		"description" : "Constructor"
	},
	"void CustomKeyvalue::CustomKeyvalue(const CustomKeyvalue& in other)": {
		"prefix": "CustomKeyvalue",
		"body" : [ "CustomKeyvalue( ${1:const CustomKeyvalue& in other} )" ],
		"description" : "Constructor"
	},
	"bool CustomKeyvalue::Exists() const": {
		"prefix": "Exists",
		"body" : [ "Exists()" ],
		"description" : "Returns whether the value exists."
	},
	"Entvartype CustomKeyvalue::GetType() const": {
		"prefix": "GetType",
		"body" : [ "GetType()" ],
		"description" : "Gets the type of the keyvalue. Returns VAR_INVALID if this value does not exist."
	},
	"string CustomKeyvalue::GetString() const": {
		"prefix": "GetString",
		"body" : [ "GetString()" ],
		"description" : "Gets the value as a string."
	},
	"Vector CustomKeyvalue::GetVector() const": {
		"prefix": "GetVector",
		"body" : [ "GetVector()" ],
		"description" : "Gets the value as a vector."
	},
	"float CustomKeyvalue::GetFloat() const": {
		"prefix": "GetFloat",
		"body" : [ "GetFloat()" ],
		"description" : "Gets the value as a float."
	},
	"int CustomKeyvalue::GetInteger() const": {
		"prefix": "GetInteger",
		"body" : [ "GetInteger()" ],
		"description" : "Gets the value as an integer."
	},
	"bool CustomKeyvalues::SetKeyvalue(const string& in szKey, const string& in szValue)": {
		"prefix": "SetKeyvalue",
		"body" : [ "SetKeyvalue( ${1:const string& in szKey}, ${2:const string& in szValue} )" ],
		"description" : "Sets a custom keyvalue to the given string value. Returns true if the key existed and was overwritten."
	},
	"bool CustomKeyvalues::SetKeyvalue(const string& in szKey, const Vector& in vecValue)": {
		"prefix": "SetKeyvalue",
		"body" : [ "SetKeyvalue( ${1:const string& in szKey}, ${2:const Vector& in vecValue} )" ],
		"description" : "Sets a custom keyvalue to the given vector value. Returns true if the key existed and was overwritten."
	},
	"bool CustomKeyvalues::SetKeyvalue(const string& in szKey, float flValue)": {
		"prefix": "SetKeyvalue",
		"body" : [ "SetKeyvalue( ${1:const string& in szKey}, ${2:float flValue} )" ],
		"description" : "Sets a custom keyvalue to the given float value. Returns true if the key existed and was overwritten."
	},
	"bool CustomKeyvalues::SetKeyvalue(const string& in szKey, int iValue)": {
		"prefix": "SetKeyvalue",
		"body" : [ "SetKeyvalue( ${1:const string& in szKey}, ${2:int iValue} )" ],
		"description" : "Sets a custom keyvalue to the given integer value. Returns true if the key existed and was overwritten."
	},
	"void CustomKeyvalues::InitializeKeyvalueWithDefault(const string& in szKey)": {
		"prefix": "InitializeKeyvalueWithDefault",
		"body" : [ "InitializeKeyvalueWithDefault( ${1:const string& in szKey} )" ],
		"description" : "Initializes a keyvalue with the default value for its type."
	},
	"bool CustomKeyvalues::HasKeyvalue(const string& in szKey) const": {
		"prefix": "HasKeyvalue",
		"body" : [ "HasKeyvalue( ${1:const string& in szKey} )" ],
		"description" : "Returns whether the keyvalue with the given name exists."
	},
	"CustomKeyvalue CustomKeyvalues::GetKeyvalue(const string& in szKey) const": {
		"prefix": "GetKeyvalue",
		"body" : [ "GetKeyvalue( ${1:const string& in szKey} )" ],
		"description" : "Gets the keyvalue with the given name. Check if it exists by calling Exists."
	},
	"void CUtility::BloodStream(const Vector& in vecOrigin, const Vector& in vecDirection, int iColor, int iAmount)": {
		"prefix": "BloodStream",
		"body" : [ "BloodStream( ${1:const Vector& in vecOrigin}, ${2:const Vector& in vecDirection}, ${3:int iColor}, ${4:int iAmount} )" ],
		"description" : "Creates a blood stream. Use BLOOD_COLOR enum for the color."
	},
	"void CUtility::BloodDrips(const Vector& in vecOrigin, const Vector& in vecDirection, int iColor, int iAmount)": {
		"prefix": "BloodDrips",
		"body" : [ "BloodDrips( ${1:const Vector& in vecOrigin}, ${2:const Vector& in vecDirection}, ${3:int iColor}, ${4:int iAmount} )" ],
		"description" : "Creates blood drips. Use BLOOD_COLOR enum for the color."
	},
	"Vector CUtility::RandomBloodVector()": {
		"prefix": "RandomBloodVector",
		"body" : [ "RandomBloodVector()" ],
		"description" : "Returns a random blood direction vector"
	},
	"bool CUtility::ShouldShowBlood(int iBloodColor)": {
		"prefix": "ShouldShowBlood",
		"body" : [ "ShouldShowBlood( ${1:int iBloodColor} )" ],
		"description" : "Returns whether blood of the given type should be shown."
	},
	"void CUtility::BloodDecalTrace(TraceResult& in trace, int iBloodColor)": {
		"prefix": "BloodDecalTrace",
		"body" : [ "BloodDecalTrace( ${1:TraceResult& in trace}, ${2:int iBloodColor} )" ],
		"description" : "Applies blood decal to the trace hit location"
	},
	"void CUtility::DecalTrace(TraceResult& in trace, int iDecalNumber)": {
		"prefix": "DecalTrace",
		"body" : [ "DecalTrace( ${1:TraceResult& in trace}, ${2:int iDecalNumber} )" ],
		"description" : "Applies decal to the trace hit location"
	},
	"void CUtility::PlayerDecalTrace(TraceResult& in trace, int iPlayerNum, int iDecalNumber, const bool bIsCustom)": {
		"prefix": "PlayerDecalTrace",
		"body" : [ "PlayerDecalTrace( ${1:TraceResult& in trace}, ${2:int iPlayerNum}, ${3:int iDecalNumber}, ${4:const bool bIsCustom} )" ],
		"description" : "Applies player decal to the trace hit location"
	},
	"void CUtility::GunshotDecalTrace(TraceResult& in trace, int iDecalNumber)": {
		"prefix": "GunshotDecalTrace",
		"body" : [ "GunshotDecalTrace( ${1:TraceResult& in trace}, ${2:int iDecalNumber} )" ],
		"description" : "Applies gunshot decal to the trace hit location"
	},
	"void CUtility::Sparks(const Vector& in vecPosition)": {
		"prefix": "Sparks",
		"body" : [ "Sparks( ${1:const Vector& in vecPosition} )" ],
		"description" : "Creates sparks at the given location"
	},
	"void CUtility::Ricochet(const Vector& in vecPosition, float flScale)": {
		"prefix": "Ricochet",
		"body" : [ "Ricochet( ${1:const Vector& in vecPosition}, ${2:float flScale} )" ],
		"description" : "Creates a ricochet at the given location"
	},
	"float CUtility::WaterLevel(const Vector& in vecPosition, float minz, float maxz)": {
		"prefix": "WaterLevel",
		"body" : [ "WaterLevel( ${1:const Vector& in vecPosition}, ${2:float minz}, ${3:float maxz} )" ],
		"description" : "Determines the Z level at which a water surface level is, given a position to start searching from and a range to search."
	},
	"void CUtility::Bubbles(const Vector& in vecMins, const Vector& in vecMaxs, int iCount)": {
		"prefix": "Bubbles",
		"body" : [ "Bubbles( ${1:const Vector& in vecMins}, ${2:const Vector& in vecMaxs}, ${3:int iCount} )" ],
		"description" : "Creates a box filled with bubbles"
	},
	"void CUtility::BubbleTrail(const Vector& in vecFrom, const Vector& in vecTo, int iCount)": {
		"prefix": "BubbleTrail",
		"body" : [ "BubbleTrail( ${1:const Vector& in vecFrom}, ${2:const Vector& in vecTo}, ${3:int iCount} )" ],
		"description" : "Creates a trail of bubbles"
	},
	"void CUtility::StringToVector(Vector& out vecVector, const string& in szString, const char delimiter = char(' ')": {
		"prefix": "StringToVector",
		"body" : [ "StringToVector( ${1:Vector& out vecVector}, ${2:const string& in szString}, ${3:const char delimiter = char(' '} )" ],
		"description" : "Converts the given string to a vector"
	},
	"bool CUtility::IsStringInt(const string& in szString)": {
		"prefix": "IsStringInt",
		"body" : [ "IsStringInt( ${1:const string& in szString} )" ],
		"description" : "Returns whether the given string is an integer"
	},
	"bool CUtility::IsStringFloat(const string& in szString)": {
		"prefix": "IsStringFloat",
		"body" : [ "IsStringFloat( ${1:const string& in szString} )" ],
		"description" : "Returns whether the given string is a float"
	},
	"bool CUtility::IsWholeNumber(const float flNum, int& out iRounded)": {
		"prefix": "IsWholeNumber",
		"body" : [ "IsWholeNumber( ${1:const float flNum}, ${2:int& out iRounded} )" ],
		"description" : "Returns whether the given float is a whole number, and returns the rounded number"
	},
	"bool CUtility::IsString3DVec(const string& in szString)": {
		"prefix": "IsString3DVec",
		"body" : [ "IsString3DVec( ${1:const string& in szString} )" ],
		"description" : "Returns whether the given string is a 3D vector"
	},
	"void CUtility::TraceLine(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,edict_t@ pEntIgnore, TraceResult& out ptr)": {
		"prefix": "TraceLine",
		"body" : [ "TraceLine( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd}, ${3:IGNORE_MONSTERS igmon,edict_t@ pEntIgnore}, ${4:TraceResult& out ptr} )" ],
		"description" : "Calculates a trace along the given line, storing the results in ptr."
	},
	"void CUtility::TraceLine(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,IGNORE_GLASS ignoreGlass, edict_t@ pEntIgnore, TraceResult& out ptr)": {
		"prefix": "TraceLine",
		"body" : [ "TraceLine( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd}, ${3:IGNORE_MONSTERS igmon,IGNORE_GLASS ignoreGlass}, ${4:edict_t@ pEntIgnore}, ${5:TraceResult& out ptr} )" ],
		"description" : "Calculates a trace along the given line, storing the results in ptr."
	},
	"void CUtility::TraceHull(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,HULL_NUMBER hullNumber, edict_t@ pEntIgnore, TraceResult& out ptr)": {
		"prefix": "TraceHull",
		"body" : [ "TraceHull( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd}, ${3:IGNORE_MONSTERS igmon,HULL_NUMBER hullNumber}, ${4:edict_t@ pEntIgnore}, ${5:TraceResult& out ptr} )" ],
		"description" : "Calculates a trace along the given line, storing the results in ptr, using the specified hull type."
	},
	"void CUtility::TraceToss(edict_t@ pEntity, edict_t@ pEntityToIgnore, TraceResult& out traceResult)": {
		"prefix": "TraceToss",
		"body" : [ "TraceToss( ${1:edict_t@ pEntity}, ${2:edict_t@ pEntityToIgnore}, ${3:TraceResult& out traceResult} )" ],
		"description" : "Trace toss"
	},
	"bool CUtility::TraceMonsterHull(edict_t@ pEntity, const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon, edict_t@ pEntityToIgnore, TraceResult& out ptr)": {
		"prefix": "TraceMonsterHull",
		"body" : [ "TraceMonsterHull( ${1:edict_t@ pEntity}, ${2:const Vector& in vecStart}, ${3:const Vector& in vecEnd}, ${4:IGNORE_MONSTERS igmon}, ${5:edict_t@ pEntityToIgnore}, ${6:TraceResult& out ptr} )" ],
		"description" : "Trace monster hull. Returns true if the trace was entirely in a solid object, or hit something."
	},
	"void CUtility::TraceModel(const Vector& in vecStart, const Vector& in vecEnd, int iHullNumber, edict_t@ pEntityToIgnore, TraceResult& out ptr)": {
		"prefix": "TraceModel",
		"body" : [ "TraceModel( ${1:const Vector& in vecStart}, ${2:const Vector& in vecEnd}, ${3:int iHullNumber}, ${4:edict_t@ pEntityToIgnore}, ${5:TraceResult& out ptr} )" ],
		"description" : "TraceModel"
	},
	"string CUtility::TraceTexture(edict_t@ pEntity, const Vector& in vecStart, const Vector& in vecEnd)": {
		"prefix": "TraceTexture",
		"body" : [ "TraceTexture( ${1:edict_t@ pEntity}, ${2:const Vector& in vecStart}, ${3:const Vector& in vecEnd} )" ],
		"description" : "Trace texture"
	},
	"CBaseEntity@ CUtility::FindEntityForward(CBaseEntity@ pLooker, float flMaxDistance)": {
		"prefix": "FindEntityForward",
		"body" : [ "FindEntityForward( ${1:CBaseEntity@ pLooker}, ${2:float flMaxDistance} )" ],
		"description" : "Convience function that finds the entity that the given entity is currently looking at."
	},
	"CBaseEntity@ CUtility::FindEntityForward(CBaseEntity@ pLooker)": {
		"prefix": "FindEntityForward",
		"body" : [ "FindEntityForward( ${1:CBaseEntity@ pLooker} )" ],
		"description" : "Convience function that finds the entity that the given entity is currently looking at. Uses a maximum distance of 12048 units."
	},
	"TraceResult CUtility::GetGlobalTrace()": {
		"prefix": "GetGlobalTrace",
		"body" : [ "GetGlobalTrace()" ],
		"description" : "Gets the global trace data stored in g_Engine as a TraceResult object."
	},
	"bool CUtility::IsPlayerInVolume(CBasePlayer@ pPlayer, CBaseEntity@ pEntityVolume)": {
		"prefix": "IsPlayerInVolume",
		"body" : [ "IsPlayerInVolume( ${1:CBasePlayer@ pPlayer}, ${2:CBaseEntity@ pEntityVolume} )" ],
		"description" : "Returns whether the given player is in the given volume."
	},
	"bool CUtility::VoteActive() const": {
		"prefix": "VoteActive",
		"body" : [ "VoteActive()" ],
		"description" : "Returns whether a vote is active. This only covers the votes started using the in-game vote menu, trigger_vote and the Vote class."
	},
	"void CUtility::GetCircularGaussianSpread(float& out x, float& out y) const": {
		"prefix": "GetCircularGaussianSpread",
		"body" : [ "GetCircularGaussianSpread( ${1:float& out x}, ${2:float& out y} )" ],
		"description" : "Gets circular gaussian spread."
	},
	"int CUtility::CountPlayersInBrushVolume(const bool fIgnoreDeadPlayers, CBaseEntity@ pBrushVolume,int& out iOutPlayersInsideVolume, int& out iOutPlayersOutsideVolume, PlayerInVolumeListener@ pListener)": {
		"prefix": "CountPlayersInBrushVolume",
		"body" : [ "CountPlayersInBrushVolume( ${1:const bool fIgnoreDeadPlayers}, ${2:CBaseEntity@ pBrushVolume,int& out iOutPlayersInsideVolume}, ${3:int& out iOutPlayersOutsideVolume}, ${4:PlayerInVolumeListener@ pListener} )" ],
		"description" : "Counts the number of players inside and outside a brush volume."
	},
	"void CUtility::FindHullIntersection(const Vector& in vecSrc, TraceResult& in inTr, TraceResult& out outTr,const Vector& in vecMins, const Vector& in vecMaxs, edict_t@ pEntity, float flDistance = 1e6f)": {
		"prefix": "FindHullIntersection",
		"body" : [ "FindHullIntersection( ${1:const Vector& in vecSrc}, ${2:TraceResult& in inTr}, ${3:TraceResult& out outTr,const Vector& in vecMins}, ${4:const Vector& in vecMaxs}, ${5:edict_t@ pEntity}, ${6:float flDistance = 1e6f} )" ],
		"description" : "Finds the hull intersection from a traceline in a given set of bounds. The bounds are relative to the input traceline's endpoint. The given entity is the entity performing the traceline."
	},
	"string CUtility::BuildEntityLogString(const string& in szName, const string& in szUserID = NULL, const string& in szAuthID = NULL, const string& in szTeam = NULL) const": {
		"prefix": "BuildEntityLogString",
		"body" : [ "BuildEntityLogString( ${1:const string& in szName}, ${2:const string& in szUserID = NULL}, ${3:const string& in szAuthID = NULL}, ${4:const string& in szTeam = NULL} )" ],
		"description" : "Builds a generic entity log string."
	},
	"string CUtility::BuildPlayerLogString(const string& in szName, const string& in szUserID = NULL, const string& in szAuthID = NULL) const": {
		"prefix": "BuildPlayerLogString",
		"body" : [ "BuildPlayerLogString( ${1:const string& in szName}, ${2:const string& in szUserID = NULL}, ${3:const string& in szAuthID = NULL} )" ],
		"description" : "Builds a generic player log string."
	},
	"string CUtility::GetPlayerLog(edict_t@ pPlayerEdict) const": {
		"prefix": "GetPlayerLog",
		"body" : [ "GetPlayerLog( ${1:edict_t@ pPlayerEdict} )" ],
		"description" : "Get a player log string."
	},
	"string Cvar::GetName()": {
		"prefix": "GetName",
		"body" : [ "GetName()" ],
		"description" : "Gets the name of the cvar."
	},
	"string Cvar::GetString()": {
		"prefix": "GetString",
		"body" : [ "GetString()" ],
		"description" : "Gets the value of the cvar as a string."
	},
	"const int Cvar::flags": {
		"prefix": "flags",
		"body" : [ "flags" ],
		"description" : "The flags of this cvar."
	},
	"const float Cvar::value": {
		"prefix": "value",
		"body" : [ "value" ],
		"description" : "The value of this cvar as a float."
	},
	"const FileQuota@ CVirtualFileSystem::GetFileQuota() const": {
		"prefix": "GetFileQuota",
		"body" : [ "GetFileQuota()" ],
		"description" : "Gets the file system quota object. Do not store a handle to this object, as it may be replaced at any time."
	},
	"File@ CVirtualFileSystem::OpenFile(const string& in szFilename, const OpenFileFlags_t uiOpenFlags)": {
		"prefix": "OpenFile",
		"body" : [ "OpenFile( ${1:const string& in szFilename}, ${2:const OpenFileFlags_t uiOpenFlags} )" ],
		"description" : "Opens a file. Returns nullptr if the file could not be opened."
	},
	"void CVirtualFileSystem::RemoveFile(const string& in szFilename)": {
		"prefix": "RemoveFile",
		"body" : [ "RemoveFile( ${1:const string& in szFilename} )" ],
		"description" : "Removes a file."
	},
	"void CWeaponFuncs::ClearMultiDamage()": {
		"prefix": "ClearMultiDamage",
		"body" : [ "ClearMultiDamage()" ],
		"description" : "Clears the multi damage data."
	},
	"void CWeaponFuncs::ApplyMultiDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker)": {
		"prefix": "ApplyMultiDamage",
		"body" : [ "ApplyMultiDamage( ${1:entvars_t@ pevInflictor}, ${2:entvars_t@ pevAttacker} )" ],
		"description" : "Applies multi damage."
	},
	"void CWeaponFuncs::AddMultiDamage(entvars_t@ pevInflictor, CBaseEntity@ pEntity, float flDamage, int bitsDamageType)": {
		"prefix": "AddMultiDamage",
		"body" : [ "AddMultiDamage( ${1:entvars_t@ pevInflictor}, ${2:CBaseEntity@ pEntity}, ${3:float flDamage}, ${4:int bitsDamageType} )" ],
		"description" : "Add multi damage."
	},
	"float CWeaponFuncs::WeaponTimeBase()": {
		"prefix": "WeaponTimeBase",
		"body" : [ "WeaponTimeBase()" ],
		"description" : "Gets the weapon time base."
	},
	"void CWeaponFuncs::DecalGunshot(TraceResult& in trace, int iBulletType)": {
		"prefix": "DecalGunshot",
		"body" : [ "DecalGunshot( ${1:TraceResult& in trace}, ${2:int iBulletType} )" ],
		"description" : "Creates a gunshot decal at the trace hit point."
	},
	"void CWeaponFuncs::SpawnBlood(const Vector& in vecSpot, int bloodColor, float flDamage)": {
		"prefix": "SpawnBlood",
		"body" : [ "SpawnBlood( ${1:const Vector& in vecSpot}, ${2:int bloodColor}, ${3:float flDamage} )" ],
		"description" : "Spawns blood at the given location."
	},
	"int CWeaponFuncs::DamageDecal(CBaseEntity@ pEntity, int bitsDamageType)": {
		"prefix": "DamageDecal",
		"body" : [ "DamageDecal( ${1:CBaseEntity@ pEntity}, ${2:int bitsDamageType} )" ],
		"description" : "Creates a damage decal on the given entity."
	},
	"void CWeaponFuncs::RadiusDamage(const Vector& in vecSrc, entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, float flRadius, int iClassIgnore, int bitsDamageType)": {
		"prefix": "RadiusDamage",
		"body" : [ "RadiusDamage( ${1:const Vector& in vecSrc}, ${2:entvars_t@ pevInflictor}, ${3:entvars_t@ pevAttacker}, ${4:float flDamage}, ${5:float flRadius}, ${6:int iClassIgnore}, ${7:int bitsDamageType} )" ],
		"description" : "Deals radius damage."
	},
	"enum DAMAGE {..., DAMAGE_NO, ...}": {
		"prefix": "DAMAGE_NO",
		"body" : [ "DAMAGE_NO" ],
		"description" : "(0) Don't allow damage"
	},
	"enum DAMAGE {..., DAMAGE_YES, ...}": {
		"prefix": "DAMAGE_YES",
		"body" : [ "DAMAGE_YES" ],
		"description" : "(1) Allow damage"
	},
	"enum DAMAGE {..., DAMAGE_AIM, ...}": {
		"prefix": "DAMAGE_AIM",
		"body" : [ "DAMAGE_AIM" ],
		"description" : "(2) allow auto-aim"
	},
	"CBaseEntity@ DamageInfo::pVictim": {
		"prefix": "pVictim",
		"body" : [ "pVictim" ],
		"description" : "Victim entity."
	},
	"CBaseEntity@ DamageInfo::pInflictor": {
		"prefix": "pInflictor",
		"body" : [ "pInflictor" ],
		"description" : "Inflictor entity."
	},
	"CBaseEntity@ DamageInfo::pAttacker": {
		"prefix": "pAttacker",
		"body" : [ "pAttacker" ],
		"description" : "Attacker entity."
	},
	"float DamageInfo::flDamage": {
		"prefix": "flDamage",
		"body" : [ "flDamage" ],
		"description" : "Damage amount."
	},
	"int DamageInfo::bitsDamageType": {
		"prefix": "bitsDamageType",
		"body" : [ "bitsDamageType" ],
		"description" : "Damage type."
	},
	"void DateTime::DateTime()": {
		"prefix": "DateTime",
		"body" : [ "DateTime()" ],
		"description" : "Default constructor."
	},
	"void DateTime::DateTime(uint uiMilliseconds, int iSeconds, int iMinutes, int iHour, int iDayOfMonth, int iMonth, int iYear)": {
		"prefix": "DateTime",
		"body" : [ "DateTime( ${1:uint uiMilliseconds}, ${2:int iSeconds}, ${3:int iMinutes}, ${4:int iHour}, ${5:int iDayOfMonth}, ${6:int iMonth}, ${7:int iYear} )" ],
		"description" : "Init constructor."
	},
	"void DateTime::DateTime(time_t time)": {
		"prefix": "DateTime",
		"body" : [ "DateTime( ${1:time_t time} )" ],
		"description" : "Unix timestamp constructor."
	},
	"void DateTime::DateTime(const DateTime& in ref)": {
		"prefix": "DateTime",
		"body" : [ "DateTime( ${1:const DateTime& in ref} )" ],
		"description" : "Copy constructor."
	},
	"DateTime& DateTime::opAssign(const DateTime& in ref)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const DateTime& in ref} )" ],
		"description" : "Assignment operator."
	},
	"DateTime& DateTime::opAssign(time_t time)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:time_t time} )" ],
		"description" : "Assignment operator."
	},
	"time_t DateTime::ToUnixTimestamp() const": {
		"prefix": "ToUnixTimestamp",
		"body" : [ "ToUnixTimestamp()" ],
		"description" : "Get time as a unix timestamp."
	},
	"void DateTime::SetUnixTimestamp(time_t time)": {
		"prefix": "SetUnixTimestamp",
		"body" : [ "SetUnixTimestamp( ${1:time_t time} )" ],
		"description" : "Sets time as a unix timestamp."
	},
	"uint DateTime::GetMilliseconds() const": {
		"prefix": "GetMilliseconds",
		"body" : [ "GetMilliseconds()" ],
		"description" : "Get milliseconds."
	},
	"int DateTime::GetSeconds() const": {
		"prefix": "GetSeconds",
		"body" : [ "GetSeconds()" ],
		"description" : "Get seconds (0-59)."
	},
	"int DateTime::GetMinutes() const": {
		"prefix": "GetMinutes",
		"body" : [ "GetMinutes()" ],
		"description" : "Get minutes (0-59)."
	},
	"int DateTime::GetHour() const": {
		"prefix": "GetHour",
		"body" : [ "GetHour()" ],
		"description" : "Get hours (0-23)."
	},
	"int DateTime::GetDayOfMonth() const": {
		"prefix": "GetDayOfMonth",
		"body" : [ "GetDayOfMonth()" ],
		"description" : "Get day of month (0-30)."
	},
	"int DateTime::GetMonth() const": {
		"prefix": "GetMonth",
		"body" : [ "GetMonth()" ],
		"description" : "Get month (0-11)."
	},
	"int DateTime::GetYear() const": {
		"prefix": "GetYear",
		"body" : [ "GetYear()" ],
		"description" : "Get year."
	},
	"void DateTime::SetMilliseconds(uint uiMilliseconds)": {
		"prefix": "SetMilliseconds",
		"body" : [ "SetMilliseconds( ${1:uint uiMilliseconds} )" ],
		"description" : "Set milliseconds."
	},
	"void DateTime::SetSeconds(int iSeconds)": {
		"prefix": "SetSeconds",
		"body" : [ "SetSeconds( ${1:int iSeconds} )" ],
		"description" : "Set seconds (0-59)."
	},
	"void DateTime::SetMinutes(int iMinutes)": {
		"prefix": "SetMinutes",
		"body" : [ "SetMinutes( ${1:int iMinutes} )" ],
		"description" : "Set minutes (0-59)."
	},
	"void DateTime::SetHour(int iHours)": {
		"prefix": "SetHour",
		"body" : [ "SetHour( ${1:int iHours} )" ],
		"description" : "Set hours (0-23)."
	},
	"void DateTime::SetDayOfMonth(int iDay)": {
		"prefix": "SetDayOfMonth",
		"body" : [ "SetDayOfMonth( ${1:int iDay} )" ],
		"description" : "Set day of month (0-30)."
	},
	"void DateTime::SetMonth(int iMonth)": {
		"prefix": "SetMonth",
		"body" : [ "SetMonth( ${1:int iMonth} )" ],
		"description" : "Set month (0-11)."
	},
	"void DateTime::SetYear(int iYear)": {
		"prefix": "SetYear",
		"body" : [ "SetYear( ${1:int iYear} )" ],
		"description" : "Set year."
	},
	"int DateTime::Format(string& out szResult, const string& in szFormat) const": {
		"prefix": "Format",
		"body" : [ "Format( ${1:string& out szResult}, ${2:const string& in szFormat} )" ],
		"description" : "Formats this datetime as a string. Returns the length of the destination string, or 0 if the buffer was not large enough."
	},
	"void DateTime::ToString(string& out szResult) const": {
		"prefix": "ToString",
		"body" : [ "ToString( ${1:string& out szResult} )" ],
		"description" : "Returns a string representation of this datetime."
	},
	"bool DateTime::opEquals(const DateTime& in other) const": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:const DateTime& in other} )" ],
		"description" : "Returns whether these two DateTimes represent the same time."
	},
	"int DateTime::opCmp(const DateTime& in other) const": {
		"prefix": "opCmp",
		"body" : [ "opCmp( ${1:const DateTime& in other} )" ],
		"description" : "Comparison operator."
	},
	"TimeDifference DateTime::opSub(const DateTime& in other) const": {
		"prefix": "opSub",
		"body" : [ "opSub( ${1:const DateTime& in other} )" ],
		"description" : "Subtracts the given DateTime from this one, resulting in a TimeDifference object."
	},
	"DateTime& DateTime::opAddAssign(const TimeDifference& in diffTime)": {
		"prefix": "opAddAssign",
		"body" : [ "opAddAssign( ${1:const TimeDifference& in diffTime} )" ],
		"description" : "Adds the given TimeDifference to this one."
	},
	"DateTime DateTime::opAdd(const TimeDifference& in diffTime) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:const TimeDifference& in diffTime} )" ],
		"description" : "Adds this DateTime and the given TimeDifferene together, returning a copy containing the new time."
	},
	"enum DEAD {..., DEAD_NO, ...}": {
		"prefix": "DEAD_NO",
		"body" : [ "DEAD_NO" ],
		"description" : "(0) alive"
	},
	"enum DEAD {..., DEAD_DYING, ...}": {
		"prefix": "DEAD_DYING",
		"body" : [ "DEAD_DYING" ],
		"description" : "(1) playing death animation or still falling off of a ledge waiting to hit ground"
	},
	"enum DEAD {..., DEAD_DEAD, ...}": {
		"prefix": "DEAD_DEAD",
		"body" : [ "DEAD_DEAD" ],
		"description" : "(2) dead. lying still."
	},
	"enum DEAD {..., DEAD_RESPAWNABLE, ...}": {
		"prefix": "DEAD_RESPAWNABLE",
		"body" : [ "DEAD_RESPAWNABLE" ],
		"description" : "(3) The player is in a state where they can be respawned."
	},
	"enum DEAD {..., DEAD_DISCARDBODY, ...}": {
		"prefix": "DEAD_DISCARDBODY",
		"body" : [ "DEAD_DISCARDBODY" ],
		"description" : "(4) No direct use of this"
	},
	"enum decal_e {..., DECAL_GUNSHOT1, ...}": {
		"prefix": "DECAL_GUNSHOT1",
		"body" : [ "DECAL_GUNSHOT1" ],
		"description" : "(0) Gunshot 1"
	},
	"enum decal_e {..., DECAL_GUNSHOT2, ...}": {
		"prefix": "DECAL_GUNSHOT2",
		"body" : [ "DECAL_GUNSHOT2" ],
		"description" : "(1) Gunshot 2"
	},
	"enum decal_e {..., DECAL_GUNSHOT3, ...}": {
		"prefix": "DECAL_GUNSHOT3",
		"body" : [ "DECAL_GUNSHOT3" ],
		"description" : "(2) Gunshot 3"
	},
	"enum decal_e {..., DECAL_GUNSHOT4, ...}": {
		"prefix": "DECAL_GUNSHOT4",
		"body" : [ "DECAL_GUNSHOT4" ],
		"description" : "(3) Gunshot 4"
	},
	"enum decal_e {..., DECAL_GUNSHOT5, ...}": {
		"prefix": "DECAL_GUNSHOT5",
		"body" : [ "DECAL_GUNSHOT5" ],
		"description" : "(4) Gunshot 5"
	},
	"enum decal_e {..., DECAL_LAMBDA1, ...}": {
		"prefix": "DECAL_LAMBDA1",
		"body" : [ "DECAL_LAMBDA1" ],
		"description" : "(5) Lambda 1"
	},
	"enum decal_e {..., DECAL_LAMBDA2, ...}": {
		"prefix": "DECAL_LAMBDA2",
		"body" : [ "DECAL_LAMBDA2" ],
		"description" : "(6) Lambda 2"
	},
	"enum decal_e {..., DECAL_LAMBDA3, ...}": {
		"prefix": "DECAL_LAMBDA3",
		"body" : [ "DECAL_LAMBDA3" ],
		"description" : "(7) Lambda 3"
	},
	"enum decal_e {..., DECAL_LAMBDA4, ...}": {
		"prefix": "DECAL_LAMBDA4",
		"body" : [ "DECAL_LAMBDA4" ],
		"description" : "(8) Lambda 4"
	},
	"enum decal_e {..., DECAL_LAMBDA5, ...}": {
		"prefix": "DECAL_LAMBDA5",
		"body" : [ "DECAL_LAMBDA5" ],
		"description" : "(9) Lambda 5"
	},
	"enum decal_e {..., DECAL_LAMBDA6, ...}": {
		"prefix": "DECAL_LAMBDA6",
		"body" : [ "DECAL_LAMBDA6" ],
		"description" : "(10) Lambda 6"
	},
	"enum decal_e {..., DECAL_SCORCH1, ...}": {
		"prefix": "DECAL_SCORCH1",
		"body" : [ "DECAL_SCORCH1" ],
		"description" : "(11) Scorch 1"
	},
	"enum decal_e {..., DECAL_SCORCH2, ...}": {
		"prefix": "DECAL_SCORCH2",
		"body" : [ "DECAL_SCORCH2" ],
		"description" : "(12) Scorch 1"
	},
	"enum decal_e {..., DECAL_BLOOD1, ...}": {
		"prefix": "DECAL_BLOOD1",
		"body" : [ "DECAL_BLOOD1" ],
		"description" : "(13) (Red) Blood 1"
	},
	"enum decal_e {..., DECAL_BLOOD2, ...}": {
		"prefix": "DECAL_BLOOD2",
		"body" : [ "DECAL_BLOOD2" ],
		"description" : "(14) (Red) Blood 2"
	},
	"enum decal_e {..., DECAL_BLOOD3, ...}": {
		"prefix": "DECAL_BLOOD3",
		"body" : [ "DECAL_BLOOD3" ],
		"description" : "(15) (Red) Blood 3"
	},
	"enum decal_e {..., DECAL_BLOOD4, ...}": {
		"prefix": "DECAL_BLOOD4",
		"body" : [ "DECAL_BLOOD4" ],
		"description" : "(16) (Red) Blood 4"
	},
	"enum decal_e {..., DECAL_BLOOD5, ...}": {
		"prefix": "DECAL_BLOOD5",
		"body" : [ "DECAL_BLOOD5" ],
		"description" : "(17) (Red) Blood 5"
	},
	"enum decal_e {..., DECAL_BLOOD6, ...}": {
		"prefix": "DECAL_BLOOD6",
		"body" : [ "DECAL_BLOOD6" ],
		"description" : "(18) (Red) Blood 6"
	},
	"enum decal_e {..., DECAL_YBLOOD1, ...}": {
		"prefix": "DECAL_YBLOOD1",
		"body" : [ "DECAL_YBLOOD1" ],
		"description" : "(19) Yellow blood 1"
	},
	"enum decal_e {..., DECAL_YBLOOD2, ...}": {
		"prefix": "DECAL_YBLOOD2",
		"body" : [ "DECAL_YBLOOD2" ],
		"description" : "(20) Yellow blood 2"
	},
	"enum decal_e {..., DECAL_YBLOOD3, ...}": {
		"prefix": "DECAL_YBLOOD3",
		"body" : [ "DECAL_YBLOOD3" ],
		"description" : "(21) Yellow blood 3"
	},
	"enum decal_e {..., DECAL_YBLOOD4, ...}": {
		"prefix": "DECAL_YBLOOD4",
		"body" : [ "DECAL_YBLOOD4" ],
		"description" : "(22) Yellow blood 4"
	},
	"enum decal_e {..., DECAL_YBLOOD5, ...}": {
		"prefix": "DECAL_YBLOOD5",
		"body" : [ "DECAL_YBLOOD5" ],
		"description" : "(23) Yellow blood 5"
	},
	"enum decal_e {..., DECAL_YBLOOD6, ...}": {
		"prefix": "DECAL_YBLOOD6",
		"body" : [ "DECAL_YBLOOD6" ],
		"description" : "(24) Yellow blood 6"
	},
	"enum decal_e {..., DECAL_GLASSBREAK1, ...}": {
		"prefix": "DECAL_GLASSBREAK1",
		"body" : [ "DECAL_GLASSBREAK1" ],
		"description" : "(25) Glass break 1"
	},
	"enum decal_e {..., DECAL_GLASSBREAK2, ...}": {
		"prefix": "DECAL_GLASSBREAK2",
		"body" : [ "DECAL_GLASSBREAK2" ],
		"description" : "(26) Glass break 2"
	},
	"enum decal_e {..., DECAL_GLASSBREAK3, ...}": {
		"prefix": "DECAL_GLASSBREAK3",
		"body" : [ "DECAL_GLASSBREAK3" ],
		"description" : "(27) Glass break 3"
	},
	"enum decal_e {..., DECAL_BIGSHOT1, ...}": {
		"prefix": "DECAL_BIGSHOT1",
		"body" : [ "DECAL_BIGSHOT1" ],
		"description" : "(28) Big shot 1"
	},
	"enum decal_e {..., DECAL_BIGSHOT2, ...}": {
		"prefix": "DECAL_BIGSHOT2",
		"body" : [ "DECAL_BIGSHOT2" ],
		"description" : "(29) Big shot 2"
	},
	"enum decal_e {..., DECAL_BIGSHOT3, ...}": {
		"prefix": "DECAL_BIGSHOT3",
		"body" : [ "DECAL_BIGSHOT3" ],
		"description" : "(30) Big shot 3"
	},
	"enum decal_e {..., DECAL_BIGSHOT4, ...}": {
		"prefix": "DECAL_BIGSHOT4",
		"body" : [ "DECAL_BIGSHOT4" ],
		"description" : "(31) Big shot 4"
	},
	"enum decal_e {..., DECAL_BIGSHOT5, ...}": {
		"prefix": "DECAL_BIGSHOT5",
		"body" : [ "DECAL_BIGSHOT5" ],
		"description" : "(32) Big shot 5"
	},
	"enum decal_e {..., DECAL_SPIT1, ...}": {
		"prefix": "DECAL_SPIT1",
		"body" : [ "DECAL_SPIT1" ],
		"description" : "(33) Spit 1"
	},
	"enum decal_e {..., DECAL_SPIT2, ...}": {
		"prefix": "DECAL_SPIT2",
		"body" : [ "DECAL_SPIT2" ],
		"description" : "(34) Spit 2"
	},
	"enum decal_e {..., DECAL_BPROOF1, ...}": {
		"prefix": "DECAL_BPROOF1",
		"body" : [ "DECAL_BPROOF1" ],
		"description" : "(35) Bulletproof glass decal"
	},
	"enum decal_e {..., DECAL_GARGSTOMP1, ...}": {
		"prefix": "DECAL_GARGSTOMP1",
		"body" : [ "DECAL_GARGSTOMP1" ],
		"description" : "(36) gargantua stomp crack"
	},
	"enum decal_e {..., DECAL_SMALLSCORCH1, ...}": {
		"prefix": "DECAL_SMALLSCORCH1",
		"body" : [ "DECAL_SMALLSCORCH1" ],
		"description" : "(37) Small scorch 1"
	},
	"enum decal_e {..., DECAL_SMALLSCORCH2, ...}": {
		"prefix": "DECAL_SMALLSCORCH2",
		"body" : [ "DECAL_SMALLSCORCH2" ],
		"description" : "(38) Small scorch 2"
	},
	"enum decal_e {..., DECAL_SMALLSCORCH3, ...}": {
		"prefix": "DECAL_SMALLSCORCH3",
		"body" : [ "DECAL_SMALLSCORCH3" ],
		"description" : "(39) Small scorch 3"
	},
	"enum decal_e {..., DECAL_MOMMABIRTH, ...}": {
		"prefix": "DECAL_MOMMABIRTH",
		"body" : [ "DECAL_MOMMABIRTH" ],
		"description" : "(40) Big momma birth splatter"
	},
	"enum decal_e {..., DECAL_MOMMASPLAT, ...}": {
		"prefix": "DECAL_MOMMASPLAT",
		"body" : [ "DECAL_MOMMASPLAT" ],
		"description" : "(41) Big momma splat"
	},
	"enum decal_e {..., DECAL_OFSCORCH1, ...}": {
		"prefix": "DECAL_OFSCORCH1",
		"body" : [ "DECAL_OFSCORCH1" ],
		"description" : "(42) Opposing force scorch 1"
	},
	"enum decal_e {..., DECAL_OFSCORCH2, ...}": {
		"prefix": "DECAL_OFSCORCH2",
		"body" : [ "DECAL_OFSCORCH2" ],
		"description" : "(43) Opposing force scorch 2"
	},
	"enum decal_e {..., DECAL_OFSCORCH3, ...}": {
		"prefix": "DECAL_OFSCORCH3",
		"body" : [ "DECAL_OFSCORCH3" ],
		"description" : "(44) Opposing force scorch 3"
	},
	"enum decal_e {..., DECAL_SPORESPLAT1, ...}": {
		"prefix": "DECAL_SPORESPLAT1",
		"body" : [ "DECAL_SPORESPLAT1" ],
		"description" : "(45) Spore splat 1"
	},
	"enum decal_e {..., DECAL_SPORESPLAT2, ...}": {
		"prefix": "DECAL_SPORESPLAT2",
		"body" : [ "DECAL_SPORESPLAT2" ],
		"description" : "(46) Spore splat 2"
	},
	"enum decal_e {..., DECAL_SPORESPLAT3, ...}": {
		"prefix": "DECAL_SPORESPLAT3",
		"body" : [ "DECAL_SPORESPLAT3" ],
		"description" : "(47) Spore splat 3"
	},
	"enum DMG {..., DMG_GENERIC, ...}": {
		"prefix": "DMG_GENERIC",
		"body" : [ "DMG_GENERIC" ],
		"description" : "(0) Generic damage."
	},
	"enum DMG {..., DMG_CRUSH, ...}": {
		"prefix": "DMG_CRUSH",
		"body" : [ "DMG_CRUSH" ],
		"description" : "(1) Crush damage. By falling or moving object."
	},
	"enum DMG {..., DMG_BULLET, ...}": {
		"prefix": "DMG_BULLET",
		"body" : [ "DMG_BULLET" ],
		"description" : "(2) Bullet. Shot."
	},
	"enum DMG {..., DMG_SLASH, ...}": {
		"prefix": "DMG_SLASH",
		"body" : [ "DMG_SLASH" ],
		"description" : "(4) Slash. Cut, clawed, stabbed."
	},
	"enum DMG {..., DMG_BURN, ...}": {
		"prefix": "DMG_BURN",
		"body" : [ "DMG_BURN" ],
		"description" : "(8) Burn. Heat burned."
	},
	"enum DMG {..., DMG_FREEZE, ...}": {
		"prefix": "DMG_FREEZE",
		"body" : [ "DMG_FREEZE" ],
		"description" : "(16) Freeze. Frozen."
	},
	"enum DMG {..., DMG_FALL, ...}": {
		"prefix": "DMG_FALL",
		"body" : [ "DMG_FALL" ],
		"description" : "(32) Fall. Fell too far."
	},
	"enum DMG {..., DMG_BLAST, ...}": {
		"prefix": "DMG_BLAST",
		"body" : [ "DMG_BLAST" ],
		"description" : "(64) Blast. Explosive blast damage."
	},
	"enum DMG {..., DMG_CLUB, ...}": {
		"prefix": "DMG_CLUB",
		"body" : [ "DMG_CLUB" ],
		"description" : "(128) Club. Crowbar, punch, headbutt."
	},
	"enum DMG {..., DMG_SHOCK, ...}": {
		"prefix": "DMG_SHOCK",
		"body" : [ "DMG_SHOCK" ],
		"description" : "(256) Shock. Electric shock."
	},
	"enum DMG {..., DMG_SONIC, ...}": {
		"prefix": "DMG_SONIC",
		"body" : [ "DMG_SONIC" ],
		"description" : "(512) Sonic. Sound pulse shockwave."
	},
	"enum DMG {..., DMG_ENERGYBEAM, ...}": {
		"prefix": "DMG_ENERGYBEAM",
		"body" : [ "DMG_ENERGYBEAM" ],
		"description" : "(1024) Energy beam. Laser or other high energy beam."
	},
	"enum DMG {..., DMG_NEVERGIB, ...}": {
		"prefix": "DMG_NEVERGIB",
		"body" : [ "DMG_NEVERGIB" ],
		"description" : "(4096) Never gib. With this bit OR'd in, no damage type will be able to gib victims upon death."
	},
	"enum DMG {..., DMG_ALWAYSGIB, ...}": {
		"prefix": "DMG_ALWAYSGIB",
		"body" : [ "DMG_ALWAYSGIB" ],
		"description" : "(8192) Always gib. With this bit OR'd in, any damage type can be made to gib victims upon death."
	},
	"enum DMG {..., DMG_LAUNCH, ...}": {
		"prefix": "DMG_LAUNCH",
		"body" : [ "DMG_LAUNCH" ],
		"description" : "(67108864) Launch. Launch into air."
	},
	"enum DMG {..., DMG_DROWN, ...}": {
		"prefix": "DMG_DROWN",
		"body" : [ "DMG_DROWN" ],
		"description" : "(16384) Drown. Drowning."
	},
	"enum DMG {..., DMG_TIMEBASED, ...}": {
		"prefix": "DMG_TIMEBASED",
		"body" : [ "DMG_TIMEBASED" ],
		"description" : "(16760832) Mash for time-based damage."
	},
	"enum DMG {..., DMG_PARALYZE, ...}": {
		"prefix": "DMG_PARALYZE",
		"body" : [ "DMG_PARALYZE" ],
		"description" : "(32768) Paralyze. Slows affected creature down."
	},
	"enum DMG {..., DMG_NERVEGAS, ...}": {
		"prefix": "DMG_NERVEGAS",
		"body" : [ "DMG_NERVEGAS" ],
		"description" : "(65536) Nerve gas. Nerve toxins, very bad."
	},
	"enum DMG {..., DMG_POISON, ...}": {
		"prefix": "DMG_POISON",
		"body" : [ "DMG_POISON" ],
		"description" : "(131072) Poison. Blood poisoning."
	},
	"enum DMG {..., DMG_RADIATION, ...}": {
		"prefix": "DMG_RADIATION",
		"body" : [ "DMG_RADIATION" ],
		"description" : "(262144) Radiation. Radiation exposure."
	},
	"enum DMG {..., DMG_DROWNRECOVER, ...}": {
		"prefix": "DMG_DROWNRECOVER",
		"body" : [ "DMG_DROWNRECOVER" ],
		"description" : "(524288) Drown recover. Drowning recovery."
	},
	"enum DMG {..., DMG_ACID, ...}": {
		"prefix": "DMG_ACID",
		"body" : [ "DMG_ACID" ],
		"description" : "(1048576) Acid. Toxic chemicals or acid burns."
	},
	"enum DMG {..., DMG_SLOWBURN, ...}": {
		"prefix": "DMG_SLOWBURN",
		"body" : [ "DMG_SLOWBURN" ],
		"description" : "(2097152) Slow burn. In an oven."
	},
	"enum DMG {..., DMG_SLOWFREEZE, ...}": {
		"prefix": "DMG_SLOWFREEZE",
		"body" : [ "DMG_SLOWFREEZE" ],
		"description" : "(4194304) Slow freeze. In a subzero freezer."
	},
	"enum DMG {..., DMG_MORTAR, ...}": {
		"prefix": "DMG_MORTAR",
		"body" : [ "DMG_MORTAR" ],
		"description" : "(8388608) Mortar. Hit by air raid (done to distinguish grenade from mortar)"
	},
	"enum DMG {..., DMG_SNIPER, ...}": {
		"prefix": "DMG_SNIPER",
		"body" : [ "DMG_SNIPER" ],
		"description" : "(16777216) Sniper. Hit by a Sniper."
	},
	"enum DMG {..., DMG_MEDKITHEAL, ...}": {
		"prefix": "DMG_MEDKITHEAL",
		"body" : [ "DMG_MEDKITHEAL" ],
		"description" : "(33554432) Medkit heal. Medkit healing."
	},
	"enum DMG {..., DMG_SHOCK_GLOW, ...}": {
		"prefix": "DMG_SHOCK_GLOW",
		"body" : [ "DMG_SHOCK_GLOW" ],
		"description" : "(134217728) Shock glow. Flag for shock glow effect."
	},
	"enum DMG {..., DMG_GIB_CORPSE, ...}": {
		"prefix": "DMG_GIB_CORPSE",
		"body" : [ "DMG_GIB_CORPSE" ],
		"description" : "(993) Gib corpse. These are the damage types that are allowed to gib corpses."
	},
	"enum DMG {..., DMG_SHOWNHUD, ...}": {
		"prefix": "DMG_SHOWNHUD",
		"body" : [ "DMG_SHOWNHUD" ],
		"description" : "(7815448) Shown on HUD. These are the damage types that have clien hud art."
	},
	"enum DoorFlag {..., SF_DOOR_ROTATE_Y, ...}": {
		"prefix": "SF_DOOR_ROTATE_Y",
		"body" : [ "SF_DOOR_ROTATE_Y" ],
		"description" : "(0)"
	},
	"enum DoorFlag {..., SF_DOOR_START_OPEN, ...}": {
		"prefix": "SF_DOOR_START_OPEN",
		"body" : [ "SF_DOOR_START_OPEN" ],
		"description" : "(1)"
	},
	"enum DoorFlag {..., SF_DOOR_ROTATE_BACKWARDS, ...}": {
		"prefix": "SF_DOOR_ROTATE_BACKWARDS",
		"body" : [ "SF_DOOR_ROTATE_BACKWARDS" ],
		"description" : "(2)"
	},
	"enum DoorFlag {..., SF_DOOR_PASSABLE, ...}": {
		"prefix": "SF_DOOR_PASSABLE",
		"body" : [ "SF_DOOR_PASSABLE" ],
		"description" : "(8)"
	},
	"enum DoorFlag {..., SF_DOOR_ONEWAY, ...}": {
		"prefix": "SF_DOOR_ONEWAY",
		"body" : [ "SF_DOOR_ONEWAY" ],
		"description" : "(16)"
	},
	"enum DoorFlag {..., SF_DOOR_NO_AUTO_RETURN, ...}": {
		"prefix": "SF_DOOR_NO_AUTO_RETURN",
		"body" : [ "SF_DOOR_NO_AUTO_RETURN" ],
		"description" : "(32)"
	},
	"enum DoorFlag {..., SF_DOOR_ROTATE_Z, ...}": {
		"prefix": "SF_DOOR_ROTATE_Z",
		"body" : [ "SF_DOOR_ROTATE_Z" ],
		"description" : "(64)"
	},
	"enum DoorFlag {..., SF_DOOR_ROTATE_X, ...}": {
		"prefix": "SF_DOOR_ROTATE_X",
		"body" : [ "SF_DOOR_ROTATE_X" ],
		"description" : "(128)"
	},
	"enum DoorFlag {..., SF_DOOR_USE_ONLY, ...}": {
		"prefix": "SF_DOOR_USE_ONLY",
		"body" : [ "SF_DOOR_USE_ONLY" ],
		"description" : "(256) door must be opened by player's use button."
	},
	"enum DoorFlag {..., SF_DOOR_NOMONSTERS, ...}": {
		"prefix": "SF_DOOR_NOMONSTERS",
		"body" : [ "SF_DOOR_NOMONSTERS" ],
		"description" : "(512) Monster can't open"
	},
	"enum DoorFlag {..., SF_DOOR_SILENT, ...}": {
		"prefix": "SF_DOOR_SILENT",
		"body" : [ "SF_DOOR_SILENT" ],
		"description" : "(-2147483648)"
	},
	"enum DoorFlag {..., SF_DOOR_NO_LINK_CHECKING, ...}": {
		"prefix": "SF_DOOR_NO_LINK_CHECKING",
		"body" : [ "SF_DOOR_NO_LINK_CHECKING" ],
		"description" : "(1024) Don't make sure the doors are in-sync."
	},
	"int16 edict_t::get_leafnums(uint)": {
		"prefix": "get_leafnums",
		"body" : [ "get_leafnums( ${1:uint} )" ],
		"description" : "get leafnums"
	},
	"const int edict_t::free": {
		"prefix": "free",
		"body" : [ "free" ],
		"description" : "Flag telling whether this edict is free"
	},
	"const int edict_t::serialnumber": {
		"prefix": "serialnumber",
		"body" : [ "serialnumber" ],
		"description" : "Serial number"
	},
	"const int edict_t::headnode": {
		"prefix": "headnode",
		"body" : [ "headnode" ],
		"description" : "Head node"
	},
	"const int edict_t::num_leafs": {
		"prefix": "num_leafs",
		"body" : [ "num_leafs" ],
		"description" : "Number of leafs"
	},
	"const float edict_t::freetime": {
		"prefix": "freetime",
		"body" : [ "freetime" ],
		"description" : "When this edict was last freed"
	},
	"entvars_t edict_t::vars": {
		"prefix": "vars",
		"body" : [ "vars" ],
		"description" : "Entity variables instance"
	},
	"enum EdictFlags {..., FL_FLY, ...}": {
		"prefix": "FL_FLY",
		"body" : [ "FL_FLY" ],
		"description" : "(1) Changes the SV_Movestep() behavior to not need to be on ground"
	},
	"enum EdictFlags {..., FL_SWIM, ...}": {
		"prefix": "FL_SWIM",
		"body" : [ "FL_SWIM" ],
		"description" : "(2) Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)"
	},
	"enum EdictFlags {..., FL_CONVEYOR, ...}": {
		"prefix": "FL_CONVEYOR",
		"body" : [ "FL_CONVEYOR" ],
		"description" : "(4) If set, entities standing on this entity are moved as if this were a conveyor"
	},
	"enum EdictFlags {..., FL_CLIENT, ...}": {
		"prefix": "FL_CLIENT",
		"body" : [ "FL_CLIENT" ],
		"description" : "(8) If set, this is a player"
	},
	"enum EdictFlags {..., FL_INWATER, ...}": {
		"prefix": "FL_INWATER",
		"body" : [ "FL_INWATER" ],
		"description" : "(16) If set, this entity is in water. Only applies to players"
	},
	"enum EdictFlags {..., FL_MONSTER, ...}": {
		"prefix": "FL_MONSTER",
		"body" : [ "FL_MONSTER" ],
		"description" : "(32) If set, this is a monster"
	},
	"enum EdictFlags {..., FL_GODMODE, ...}": {
		"prefix": "FL_GODMODE",
		"body" : [ "FL_GODMODE" ],
		"description" : "(64) If set, this entity is invincible. Only applies to players"
	},
	"enum EdictFlags {..., FL_NOTARGET, ...}": {
		"prefix": "FL_NOTARGET",
		"body" : [ "FL_NOTARGET" ],
		"description" : "(128) If set, this entity will not be targeted by monster AI"
	},
	"enum EdictFlags {..., FL_SKIPLOCALHOST, ...}": {
		"prefix": "FL_SKIPLOCALHOST",
		"body" : [ "FL_SKIPLOCALHOST" ],
		"description" : "(256) Don't send entity to local host, it's predicting this entity itself"
	},
	"enum EdictFlags {..., FL_ONGROUND, ...}": {
		"prefix": "FL_ONGROUND",
		"body" : [ "FL_ONGROUND" ],
		"description" : "(512) At rest / on the ground"
	},
	"enum EdictFlags {..., FL_PARTIALGROUND, ...}": {
		"prefix": "FL_PARTIALGROUND",
		"body" : [ "FL_PARTIALGROUND" ],
		"description" : "(1024) not all corners are valid"
	},
	"enum EdictFlags {..., FL_WATERJUMP, ...}": {
		"prefix": "FL_WATERJUMP",
		"body" : [ "FL_WATERJUMP" ],
		"description" : "(2048) player jumping out of water"
	},
	"enum EdictFlags {..., FL_FROZEN, ...}": {
		"prefix": "FL_FROZEN",
		"body" : [ "FL_FROZEN" ],
		"description" : "(4096) Player is frozen for 3rd person camera"
	},
	"enum EdictFlags {..., FL_FAKECLIENT, ...}": {
		"prefix": "FL_FAKECLIENT",
		"body" : [ "FL_FAKECLIENT" ],
		"description" : "(8192) JAC: fake client, simulated server side; don't send network messages to them"
	},
	"enum EdictFlags {..., FL_DUCKING, ...}": {
		"prefix": "FL_DUCKING",
		"body" : [ "FL_DUCKING" ],
		"description" : "(16384) Player flag -- Player is fully crouched"
	},
	"enum EdictFlags {..., FL_FLOAT, ...}": {
		"prefix": "FL_FLOAT",
		"body" : [ "FL_FLOAT" ],
		"description" : "(32768) Apply floating force to this entity when in water"
	},
	"enum EdictFlags {..., FL_GRAPHED, ...}": {
		"prefix": "FL_GRAPHED",
		"body" : [ "FL_GRAPHED" ],
		"description" : "(65536) worldgraph has this ent listed as something that blocks a connection"
	},
	"enum EdictFlags {..., FL_IMMUNE_WATER, ...}": {
		"prefix": "FL_IMMUNE_WATER",
		"body" : [ "FL_IMMUNE_WATER" ],
		"description" : "(131072) If set, players don't take drown damage"
	},
	"enum EdictFlags {..., FL_IMMUNE_SLIME, ...}": {
		"prefix": "FL_IMMUNE_SLIME",
		"body" : [ "FL_IMMUNE_SLIME" ],
		"description" : "(262144) If set, players don't take damage from slime"
	},
	"enum EdictFlags {..., FL_IMMUNE_LAVA, ...}": {
		"prefix": "FL_IMMUNE_LAVA",
		"body" : [ "FL_IMMUNE_LAVA" ],
		"description" : "(524288) If set, players don't take damage from lava"
	},
	"enum EdictFlags {..., FL_PROXY, ...}": {
		"prefix": "FL_PROXY",
		"body" : [ "FL_PROXY" ],
		"description" : "(1048576) This is a spectator proxy"
	},
	"enum EdictFlags {..., FL_ALWAYSTHINK, ...}": {
		"prefix": "FL_ALWAYSTHINK",
		"body" : [ "FL_ALWAYSTHINK" ],
		"description" : "(2097152) Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path)"
	},
	"enum EdictFlags {..., FL_BASEVELOCITY, ...}": {
		"prefix": "FL_BASEVELOCITY",
		"body" : [ "FL_BASEVELOCITY" ],
		"description" : "(4194304) Base velocity has been applied this frame (used to convert base velocity into momentum)"
	},
	"enum EdictFlags {..., FL_MONSTERCLIP, ...}": {
		"prefix": "FL_MONSTERCLIP",
		"body" : [ "FL_MONSTERCLIP" ],
		"description" : "(8388608) Only collide in with monsters who have FL_MONSTERCLIP set"
	},
	"enum EdictFlags {..., FL_ONTRAIN, ...}": {
		"prefix": "FL_ONTRAIN",
		"body" : [ "FL_ONTRAIN" ],
		"description" : "(16777216) Player is _controlling_ a train, so movement commands should be ignored on client during prediction."
	},
	"enum EdictFlags {..., FL_WORLDBRUSH, ...}": {
		"prefix": "FL_WORLDBRUSH",
		"body" : [ "FL_WORLDBRUSH" ],
		"description" : "(33554432) Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)"
	},
	"enum EdictFlags {..., FL_SPECTATOR, ...}": {
		"prefix": "FL_SPECTATOR",
		"body" : [ "FL_SPECTATOR" ],
		"description" : "(67108864) This client is a spectator, don't run touch functions, etc."
	},
	"enum EdictFlags {..., FL_NOWEAPONS, ...}": {
		"prefix": "FL_NOWEAPONS",
		"body" : [ "FL_NOWEAPONS" ],
		"description" : "(134217728) This client is being denied weapon usage"
	},
	"enum EdictFlags {..., FL_CUSTOMENTITY, ...}": {
		"prefix": "FL_CUSTOMENTITY",
		"body" : [ "FL_CUSTOMENTITY" ],
		"description" : "(536870912) This is a custom entity"
	},
	"enum EdictFlags {..., FL_KILLME, ...}": {
		"prefix": "FL_KILLME",
		"body" : [ "FL_KILLME" ],
		"description" : "(1073741824) This entity is marked for death -- This allows the engine to kill ents at the appropriate time"
	},
	"enum EdictFlags {..., FL_DORMANT, ...}": {
		"prefix": "FL_DORMANT",
		"body" : [ "FL_DORMANT" ],
		"description" : "(2147483648) Entity is dormant, no updates to client"
	},
	"enum EFFECTS {..., EF_BRIGHTFIELD, ...}": {
		"prefix": "EF_BRIGHTFIELD",
		"body" : [ "EF_BRIGHTFIELD" ],
		"description" : "(1) swirling cloud of particles"
	},
	"enum EFFECTS {..., EF_MUZZLEFLASH, ...}": {
		"prefix": "EF_MUZZLEFLASH",
		"body" : [ "EF_MUZZLEFLASH" ],
		"description" : "(2) single frame ELIGHT on entity attachment 0"
	},
	"enum EFFECTS {..., EF_BRIGHTLIGHT, ...}": {
		"prefix": "EF_BRIGHTLIGHT",
		"body" : [ "EF_BRIGHTLIGHT" ],
		"description" : "(4) DLIGHT centered at entity origin"
	},
	"enum EFFECTS {..., EF_DIMLIGHT, ...}": {
		"prefix": "EF_DIMLIGHT",
		"body" : [ "EF_DIMLIGHT" ],
		"description" : "(8) player flashlight"
	},
	"enum EFFECTS {..., EF_INVLIGHT, ...}": {
		"prefix": "EF_INVLIGHT",
		"body" : [ "EF_INVLIGHT" ],
		"description" : "(16) get lighting from ceiling"
	},
	"enum EFFECTS {..., EF_NOINTERP, ...}": {
		"prefix": "EF_NOINTERP",
		"body" : [ "EF_NOINTERP" ],
		"description" : "(32) don't interpolate the next frame"
	},
	"enum EFFECTS {..., EF_LIGHT, ...}": {
		"prefix": "EF_LIGHT",
		"body" : [ "EF_LIGHT" ],
		"description" : "(64) rocket flare glow sprite"
	},
	"enum EFFECTS {..., EF_NODRAW, ...}": {
		"prefix": "EF_NODRAW",
		"body" : [ "EF_NODRAW" ],
		"description" : "(128) don't draw entity"
	},
	"enum EFFECTS {..., EF_NODECALS, ...}": {
		"prefix": "EF_NODECALS",
		"body" : [ "EF_NODECALS" ],
		"description" : "(2048) don't draw decals on this entity"
	},
	"enum EFFECTS {..., EF_NOANIMTEXTURES, ...}": {
		"prefix": "EF_NOANIMTEXTURES",
		"body" : [ "EF_NOANIMTEXTURES" ],
		"description" : "(256) Don't animate brush entities"
	},
	"enum EFFECTS {..., EF_FRAMEANIMTEXTURES, ...}": {
		"prefix": "EF_FRAMEANIMTEXTURES",
		"body" : [ "EF_FRAMEANIMTEXTURES" ],
		"description" : "(512) Use the value in pev->frame to set the texture on a brush entity"
	},
	"void EHandle::EHandle()": {
		"prefix": "EHandle",
		"body" : [ "EHandle()" ],
		"description" : "Default constructs this handle."
	},
	"void EHandle::EHandle(const EHandle& in other)": {
		"prefix": "EHandle",
		"body" : [ "EHandle( ${1:const EHandle& in other} )" ],
		"description" : "Copy constructs this handle."
	},
	"void EHandle::EHandle(CBaseEntity@ pEntity)": {
		"prefix": "EHandle",
		"body" : [ "EHandle( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Constructs this handle with a reference to the given entity."
	},
	"bool EHandle::IsValid() const": {
		"prefix": "IsValid",
		"body" : [ "IsValid()" ],
		"description" : "Returns whether this handle is valid."
	},
	"bool EHandle::opImplConv() const": {
		"prefix": "opImplConv",
		"body" : [ "opImplConv()" ],
		"description" : "Returns whether this handle is valid."
	},
	"CBaseEntity@ EHandle::GetEntity() const": {
		"prefix": "GetEntity",
		"body" : [ "GetEntity()" ],
		"description" : "Gets the Entity this handle refers to. Returns null if invalid."
	},
	"CBaseEntity@ EHandle::opImplCast() const": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Gets the Entity this handle refers to. Returns null if invalid."
	},
	"CBaseEntity@ EHandle::opAssign(CBaseEntity@ pEntity)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Assigns the given entity to this handle."
	},
	"EHandle& EHandle::opAssign(const EHandle& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const EHandle& in other} )" ],
		"description" : "Makes this handle refer to the same entity as the given handle."
	},
	"int EHandle::GetSerialNumber() const": {
		"prefix": "GetSerialNumber",
		"body" : [ "GetSerialNumber()" ],
		"description" : "CBaseEntity serial number. Used to determine if the entity is still valid."
	},
	"bool entvars_t::ClassNameIs(const string& in szClassName)": {
		"prefix": "ClassNameIs",
		"body" : [ "ClassNameIs( ${1:const string& in szClassName} )" ],
		"description" : "Returns whether the given class name is this entity's class name"
	},
	"int8 entvars_t::get_controller(uint)": {
		"prefix": "get_controller",
		"body" : [ "get_controller( ${1:uint} )" ],
		"description" : "Get entity controller by index (0..3). Used by entities with studio models to get bone controller settings."
	},
	"void entvars_t::set_controller(uint, int8)": {
		"prefix": "set_controller",
		"body" : [ "set_controller( ${1:uint}, ${2:int8} )" ],
		"description" : "Set entity controller by index (0..3, 0..255) Used by entities with studio models to set bone controller settings."
	},
	"int8 entvars_t::get_blending(uint)": {
		"prefix": "get_blending",
		"body" : [ "get_blending( ${1:uint} )" ],
		"description" : "Get entity blending by index (0..1). Used by entities with models to get x or y axis blending."
	},
	"void entvars_t::set_blending(uint, int8)": {
		"prefix": "set_blending",
		"body" : [ "set_blending( ${1:uint}, ${2:int8} )" ],
		"description" : "Set entity blending by index (0..1, 0..255). Used by entities with models to set x or y axis blending."
	},
	"bool entvars_t::SpawnFlagBitSet(int iFlags)": {
		"prefix": "SpawnFlagBitSet",
		"body" : [ "SpawnFlagBitSet( ${1:int iFlags} )" ],
		"description" : "Returns whether the given flag(s) are set on the entvars spawnflags variable"
	},
	"bool entvars_t::FlagBitSet(int iFlags)": {
		"prefix": "FlagBitSet",
		"body" : [ "FlagBitSet( ${1:int iFlags} )" ],
		"description" : "Returns whether the given flag(s) are set on the entvars flags variable"
	},
	"edict_t@ entvars_t::get_pContainingEntity() const": {
		"prefix": "get_pContainingEntity",
		"body" : [ "get_pContainingEntity()" ],
		"description" : "Entity containing entity. pContainingEntity.vars equals this entvars instance."
	},
	"const string_t entvars_t::classname": {
		"prefix": "classname",
		"body" : [ "classname" ],
		"description" : "The entity class name"
	},
	"string_t entvars_t::globalname": {
		"prefix": "globalname",
		"body" : [ "globalname" ],
		"description" : "The entity global name"
	},
	"Vector entvars_t::origin": {
		"prefix": "origin",
		"body" : [ "origin" ],
		"description" : "Entity origin. Must be set using g_EntityFuncs.SetOrigin."
	},
	"Vector entvars_t::oldorigin": {
		"prefix": "oldorigin",
		"body" : [ "oldorigin" ],
		"description" : "Old entity origin. Used by some entities to store off their original origin before moving to a different location."
	},
	"Vector entvars_t::velocity": {
		"prefix": "velocity",
		"body" : [ "velocity" ],
		"description" : "Entity velocity"
	},
	"Vector entvars_t::basevelocity": {
		"prefix": "basevelocity",
		"body" : [ "basevelocity" ],
		"description" : "Entity base velocity. Used when standing on another entity that applies velocity to entities standing on it, for instance conveyors."
	},
	"Vector entvars_t::movedir": {
		"prefix": "movedir",
		"body" : [ "movedir" ],
		"description" : "Entity move direction. Used by some entities for movement directions, but some entities use it for other purposes."
	},
	"Vector entvars_t::angles": {
		"prefix": "angles",
		"body" : [ "angles" ],
		"description" : "Entity angles, in degrees."
	},
	"Vector entvars_t::avelocity": {
		"prefix": "avelocity",
		"body" : [ "avelocity" ],
		"description" : "Entity angular velocity, in degrees/sec. Applied to the entity's angles."
	},
	"Vector entvars_t::punchangle": {
		"prefix": "punchangle",
		"body" : [ "punchangle" ],
		"description" : "Player punch angle. These angles are applied to players when they are 'punched'.These angles are automatically interpolated back to the null vector over time."
	},
	"Vector entvars_t::v_angle": {
		"prefix": "v_angle",
		"body" : [ "v_angle" ],
		"description" : "Player view angle. These are the angles used for the player's view, and differ from the regular angles variable."
	},
	"Vector entvars_t::endpos": {
		"prefix": "endpos",
		"body" : [ "endpos" ],
		"description" : "Entity end position. Reserved for future use."
	},
	"Vector entvars_t::startpos": {
		"prefix": "startpos",
		"body" : [ "startpos" ],
		"description" : "Entity start position. Reserved for future use."
	},
	"float entvars_t::impacttime": {
		"prefix": "impacttime",
		"body" : [ "impacttime" ],
		"description" : "Entity impact time. Reserved for future use."
	},
	"float entvars_t::starttime": {
		"prefix": "starttime",
		"body" : [ "starttime" ],
		"description" : "Entity start time. Reserved for future use."
	},
	"int entvars_t::fixangle": {
		"prefix": "fixangle",
		"body" : [ "fixangle" ],
		"description" : "Entity fix angle. Engine uses this value to change player view angles, and then resets it to FAM_NOTHING. See FixAngleMode enum."
	},
	"float entvars_t::idealpitch": {
		"prefix": "idealpitch",
		"body" : [ "idealpitch" ],
		"description" : "Entity ideal pitch. Used in conjunction with pitch_speed to interpolate the entity's current pitch angle to this value."
	},
	"float entvars_t::pitch_speed": {
		"prefix": "pitch_speed",
		"body" : [ "pitch_speed" ],
		"description" : "Entity pitch speed. See idealpitch."
	},
	"float entvars_t::ideal_yaw": {
		"prefix": "ideal_yaw",
		"body" : [ "ideal_yaw" ],
		"description" : "Entity ideal yaw. Used in conjunction with yaw_speed to interpolate the entity's current yaw angle to this value."
	},
	"float entvars_t::yaw_speed": {
		"prefix": "yaw_speed",
		"body" : [ "yaw_speed" ],
		"description" : "Entity yaw speed. See ideal_yaw."
	},
	"const int entvars_t::modelindex": {
		"prefix": "modelindex",
		"body" : [ "modelindex" ],
		"description" : "Entity model index. If this entity has a model, is the unique index of the model. Otherwise, is 0."
	},
	"string_t entvars_t::model": {
		"prefix": "model",
		"body" : [ "model" ],
		"description" : "The entity model name. If this entity has a model, is the name of that model. Otherwise, is an empty string.Use g_EntityFuncs.SetModel to set this variable."
	},
	"string_t entvars_t::viewmodel": {
		"prefix": "viewmodel",
		"body" : [ "viewmodel" ],
		"description" : "Player view model index. If this player has a visible weapon, is the name of that view (v_) model. Otherwise, is an empty string."
	},
	"string_t entvars_t::weaponmodel": {
		"prefix": "weaponmodel",
		"body" : [ "weaponmodel" ],
		"description" : "Entity weapon model index. If this player has a visible weapon, is the name of that third person (p_) model. Otherwise, is an empty string."
	},
	"Vector entvars_t::absmin": {
		"prefix": "absmin",
		"body" : [ "absmin" ],
		"description" : "Entity absolute minimum size. Is an absolute position in the world. Automatically updated by the engine."
	},
	"Vector entvars_t::absmax": {
		"prefix": "absmax",
		"body" : [ "absmax" ],
		"description" : "Entity absolute maximum size. Is an absolute position in the world. Automatically updated by the engine."
	},
	"Vector entvars_t::mins": {
		"prefix": "mins",
		"body" : [ "mins" ],
		"description" : "Entity minimum size. Relative to the player's origin."
	},
	"Vector entvars_t::maxs": {
		"prefix": "maxs",
		"body" : [ "maxs" ],
		"description" : "Entity maximum size. Relative to the player's origin."
	},
	"Vector entvars_t::size": {
		"prefix": "size",
		"body" : [ "size" ],
		"description" : "Entity size. Equivalent to maxs - mins"
	},
	"float entvars_t::ltime": {
		"prefix": "ltime",
		"body" : [ "ltime" ],
		"description" : "Entity ltime. The last time this entity has executed its think function. Otherwise, is 0."
	},
	"float entvars_t::nextthink": {
		"prefix": "nextthink",
		"body" : [ "nextthink" ],
		"description" : "Entity next think time. The next time this entity will execute its think function, as an absolute time value. Otherwise, is 0."
	},
	"int entvars_t::movetype": {
		"prefix": "movetype",
		"body" : [ "movetype" ],
		"description" : "Entity movetype. See MOVETYPE enum."
	},
	"int entvars_t::solid": {
		"prefix": "solid",
		"body" : [ "solid" ],
		"description" : "Entity solid flag. See SOLID enum."
	},
	"int entvars_t::skin": {
		"prefix": "skin",
		"body" : [ "skin" ],
		"description" : "Entity skin index. Used by entities with studio models to set which skin to use."
	},
	"int entvars_t::body": {
		"prefix": "body",
		"body" : [ "body" ],
		"description" : "Entity body index. Used by entities with studio models to set which body to use."
	},
	"int entvars_t::effects": {
		"prefix": "effects",
		"body" : [ "effects" ],
		"description" : "Entity effects. See EFFECTS enum."
	},
	"float entvars_t::gravity": {
		"prefix": "gravity",
		"body" : [ "gravity" ],
		"description" : "Entity gravity. Is a scalar between 0 and 1, inclusive."
	},
	"float entvars_t::friction": {
		"prefix": "friction",
		"body" : [ "friction" ],
		"description" : "Entity friction. Is a scalar between 0 and 1, inclusive."
	},
	"int entvars_t::light_level": {
		"prefix": "light_level",
		"body" : [ "light_level" ],
		"description" : "Player only light level. This is a single value between 0 and 255 inclusive. Use g_EngineFuncs.GetEntityIllum to retrieve this value."
	},
	"int entvars_t::sequence": {
		"prefix": "sequence",
		"body" : [ "sequence" ],
		"description" : "Entity sequence. Used by entities with studio models to set which sequence to use."
	},
	"int entvars_t::gaitsequence": {
		"prefix": "gaitsequence",
		"body" : [ "gaitsequence" ],
		"description" : "Entity gait sequence. Used by entities with studio models for walking sequences."
	},
	"float entvars_t::frame": {
		"prefix": "frame",
		"body" : [ "frame" ],
		"description" : "Entity frame. Used by entities with studio models to set the current frame that a sequence is using. Automatically incremented.Used by brush models for animated textures: 1 for animated, 0 for off."
	},
	"float entvars_t::animtime": {
		"prefix": "animtime",
		"body" : [ "animtime" ],
		"description" : "Entity animation time. Used for internal operations."
	},
	"float entvars_t::framerate": {
		"prefix": "framerate",
		"body" : [ "framerate" ],
		"description" : "Entity framerate. used by entities with studio models to control sequence frame rate."
	},
	"float entvars_t::scale": {
		"prefix": "scale",
		"body" : [ "scale" ],
		"description" : "Entity rendering scale (0..255). Applies to studio and sprite models."
	},
	"int entvars_t::rendermode": {
		"prefix": "rendermode",
		"body" : [ "rendermode" ],
		"description" : "Entity render mode. See RenderModes enum."
	},
	"float entvars_t::renderamt": {
		"prefix": "renderamt",
		"body" : [ "renderamt" ],
		"description" : "Entity render amount (0..255)"
	},
	"Vector entvars_t::rendercolor": {
		"prefix": "rendercolor",
		"body" : [ "rendercolor" ],
		"description" : "Entity render color (rgb)"
	},
	"int entvars_t::renderfx": {
		"prefix": "renderfx",
		"body" : [ "renderfx" ],
		"description" : "Entity render fx"
	},
	"float entvars_t::health": {
		"prefix": "health",
		"body" : [ "health" ],
		"description" : "Entity health. Do not set directly unless you are absolutely sure you know what you are doing."
	},
	"float entvars_t::frags": {
		"prefix": "frags",
		"body" : [ "frags" ],
		"description" : "Entity frags. Usually used for the number of kills or score."
	},
	"int entvars_t::weapons": {
		"prefix": "weapons",
		"body" : [ "weapons" ],
		"description" : "Entity weapons bit vector. Largely used by monsters to track which weapons they have, and by players for internal purposes."
	},
	"float entvars_t::takedamage": {
		"prefix": "takedamage",
		"body" : [ "takedamage" ],
		"description" : "Entity take damage flag. See DAMAGE enum."
	},
	"int entvars_t::deadflag": {
		"prefix": "deadflag",
		"body" : [ "deadflag" ],
		"description" : "Entity dead flag. See DEAD enum."
	},
	"Vector entvars_t::view_ofs": {
		"prefix": "view_ofs",
		"body" : [ "view_ofs" ],
		"description" : "Entity view offset. Used to set an eye offset."
	},
	"int entvars_t::button": {
		"prefix": "button",
		"body" : [ "button" ],
		"description" : "Entity button bit vector. Usually used to track which buttons the player is currently pressing."
	},
	"int entvars_t::impulse": {
		"prefix": "impulse",
		"body" : [ "impulse" ],
		"description" : "Entity impulse bit vector. Used for various internal operations."
	},
	"edict_t@ entvars_t::chain": {
		"prefix": "chain",
		"body" : [ "chain" ],
		"description" : "Entity pointer when linked into a linked list. Used for temporary lists."
	},
	"edict_t@ entvars_t::dmg_inflictor": {
		"prefix": "dmg_inflictor",
		"body" : [ "dmg_inflictor" ],
		"description" : "Entity damage inflictor"
	},
	"edict_t@ entvars_t::enemy": {
		"prefix": "enemy",
		"body" : [ "enemy" ],
		"description" : "Entity enemy"
	},
	"edict_t@ entvars_t::aiment": {
		"prefix": "aiment",
		"body" : [ "aiment" ],
		"description" : "Entity pointer when MOVETYPE_FOLLOW"
	},
	"edict_t@ entvars_t::owner": {
		"prefix": "owner",
		"body" : [ "owner" ],
		"description" : "Entity owner"
	},
	"edict_t@ entvars_t::groundentity": {
		"prefix": "groundentity",
		"body" : [ "groundentity" ],
		"description" : "Entity ground entity"
	},
	"int entvars_t::spawnflags": {
		"prefix": "spawnflags",
		"body" : [ "spawnflags" ],
		"description" : "Entity spawn flags"
	},
	"int entvars_t::flags": {
		"prefix": "flags",
		"body" : [ "flags" ],
		"description" : "Entity flags. See EdictFlags enum."
	},
	"int entvars_t::colormap": {
		"prefix": "colormap",
		"body" : [ "colormap" ],
		"description" : "Entity color map. Used for player model colors."
	},
	"int entvars_t::team": {
		"prefix": "team",
		"body" : [ "team" ],
		"description" : "Entity team. Reserved for future use."
	},
	"float entvars_t::max_health": {
		"prefix": "max_health",
		"body" : [ "max_health" ],
		"description" : "Entity maximum health"
	},
	"float entvars_t::teleport_time": {
		"prefix": "teleport_time",
		"body" : [ "teleport_time" ],
		"description" : "Entity teleport time. Intended for internal operations."
	},
	"float entvars_t::armortype": {
		"prefix": "armortype",
		"body" : [ "armortype" ],
		"description" : "Entity armor type. Represents maximum armor (similar to max_health)."
	},
	"float entvars_t::armorvalue": {
		"prefix": "armorvalue",
		"body" : [ "armorvalue" ],
		"description" : "Entity armor value"
	},
	"int entvars_t::waterlevel": {
		"prefix": "waterlevel",
		"body" : [ "waterlevel" ],
		"description" : "Entity water level. See WATERLEVEL enum."
	},
	"int entvars_t::watertype": {
		"prefix": "watertype",
		"body" : [ "watertype" ],
		"description" : "Player only. Contains the type of water contents the player is currently in. See CONTENTS enum."
	},
	"string_t entvars_t::target": {
		"prefix": "target",
		"body" : [ "target" ],
		"description" : "The entity target. If set, is the name of one or more targets to trigger. Otherwise, is empty."
	},
	"string_t entvars_t::targetname": {
		"prefix": "targetname",
		"body" : [ "targetname" ],
		"description" : "The entity target name"
	},
	"string_t entvars_t::netname": {
		"prefix": "netname",
		"body" : [ "netname" ],
		"description" : "The entity net name. Used for various things, such as the player's name."
	},
	"string_t entvars_t::message": {
		"prefix": "message",
		"body" : [ "message" ],
		"description" : "The entity message. Used for various things."
	},
	"float entvars_t::dmg_take": {
		"prefix": "dmg_take",
		"body" : [ "dmg_take" ],
		"description" : "Entity damage take. Used for internal operations."
	},
	"float entvars_t::dmg_save": {
		"prefix": "dmg_save",
		"body" : [ "dmg_save" ],
		"description" : "Entity damage save. Used for internal operations."
	},
	"float entvars_t::dmg": {
		"prefix": "dmg",
		"body" : [ "dmg" ],
		"description" : "Entity damage. Usually stores how much damage this entity can do to other entities."
	},
	"float entvars_t::dmgtime": {
		"prefix": "dmgtime",
		"body" : [ "dmgtime" ],
		"description" : "Entity damage time. Time at which this entity last took damage. Usually used to limit damage effects from being shown too often."
	},
	"string_t entvars_t::noise": {
		"prefix": "noise",
		"body" : [ "noise" ],
		"description" : "Entity noise. Usually used to store a sound name."
	},
	"string_t entvars_t::noise1": {
		"prefix": "noise1",
		"body" : [ "noise1" ],
		"description" : "Entity noise 1. Usually used to store a sound name."
	},
	"string_t entvars_t::noise2": {
		"prefix": "noise2",
		"body" : [ "noise2" ],
		"description" : "Entity noise 2. Usually used to store a sound name."
	},
	"string_t entvars_t::noise3": {
		"prefix": "noise3",
		"body" : [ "noise3" ],
		"description" : "Entity noise 3. Usually used to store a sound name."
	},
	"float entvars_t::speed": {
		"prefix": "speed",
		"body" : [ "speed" ],
		"description" : "Entity speed"
	},
	"float entvars_t::air_finished": {
		"prefix": "air_finished",
		"body" : [ "air_finished" ],
		"description" : "Player air finished. Time at which the player runs out of air when underwater."
	},
	"float entvars_t::pain_finished": {
		"prefix": "pain_finished",
		"body" : [ "pain_finished" ],
		"description" : "Player pain finished. Time at which the player can take damage again while drowning."
	},
	"float entvars_t::radsuit_finished": {
		"prefix": "radsuit_finished",
		"body" : [ "radsuit_finished" ],
		"description" : "Entity radiation suit finished. Reserved for future use."
	},
	"int entvars_t::playerclass": {
		"prefix": "playerclass",
		"body" : [ "playerclass" ],
		"description" : "Entity player class. Reserved for future use."
	},
	"float entvars_t::maxspeed": {
		"prefix": "maxspeed",
		"body" : [ "maxspeed" ],
		"description" : "Entity maximum speed"
	},
	"float entvars_t::fov": {
		"prefix": "fov",
		"body" : [ "fov" ],
		"description" : "Player field of view"
	},
	"int entvars_t::weaponanim": {
		"prefix": "weaponanim",
		"body" : [ "weaponanim" ],
		"description" : "Player weapon animation"
	},
	"int entvars_t::pushmsec": {
		"prefix": "pushmsec",
		"body" : [ "pushmsec" ],
		"description" : "Entity push milliseconds. Used for internal operations."
	},
	"int entvars_t::bInDuck": {
		"prefix": "bInDuck",
		"body" : [ "bInDuck" ],
		"description" : "Entity ducking flag. Used for internal operations."
	},
	"int entvars_t::flTimeStepSound": {
		"prefix": "flTimeStepSound",
		"body" : [ "flTimeStepSound" ],
		"description" : "Entity time of step sound. Used for internal operations."
	},
	"int entvars_t::flSwimTime": {
		"prefix": "flSwimTime",
		"body" : [ "flSwimTime" ],
		"description" : "Entity swim time. Used for internal operations."
	},
	"int entvars_t::flDuckTime": {
		"prefix": "flDuckTime",
		"body" : [ "flDuckTime" ],
		"description" : "Entity duck time. Used for internal operations."
	},
	"int entvars_t::iStepLeft": {
		"prefix": "iStepLeft",
		"body" : [ "iStepLeft" ],
		"description" : "Entity step left flag. Used for internal operations."
	},
	"float entvars_t::flFallVelocity": {
		"prefix": "flFallVelocity",
		"body" : [ "flFallVelocity" ],
		"description" : "Player fall velocity."
	},
	"int entvars_t::gamestate": {
		"prefix": "gamestate",
		"body" : [ "gamestate" ],
		"description" : "Entity gamestate. Reserved for future use."
	},
	"int entvars_t::oldbuttons": {
		"prefix": "oldbuttons",
		"body" : [ "oldbuttons" ],
		"description" : "Player old buttons. Previous frame's contents of buttons."
	},
	"int entvars_t::groupinfo": {
		"prefix": "groupinfo",
		"body" : [ "groupinfo" ],
		"description" : "Entity group info. Used for internal operations."
	},
	"int entvars_t::iuser1": {
		"prefix": "iuser1",
		"body" : [ "iuser1" ],
		"description" : "User variable 1 (integer)"
	},
	"int entvars_t::iuser2": {
		"prefix": "iuser2",
		"body" : [ "iuser2" ],
		"description" : "User variable 2 (integer)"
	},
	"int entvars_t::iuser3": {
		"prefix": "iuser3",
		"body" : [ "iuser3" ],
		"description" : "User variable 3 (integer)"
	},
	"int entvars_t::iuser4": {
		"prefix": "iuser4",
		"body" : [ "iuser4" ],
		"description" : "User variable 4 (integer)"
	},
	"float entvars_t::fuser1": {
		"prefix": "fuser1",
		"body" : [ "fuser1" ],
		"description" : "User variable 1 (float)"
	},
	"float entvars_t::fuser2": {
		"prefix": "fuser2",
		"body" : [ "fuser2" ],
		"description" : "User variable 2 (float)"
	},
	"float entvars_t::fuser3": {
		"prefix": "fuser3",
		"body" : [ "fuser3" ],
		"description" : "User variable 3 (float)"
	},
	"float entvars_t::fuser4": {
		"prefix": "fuser4",
		"body" : [ "fuser4" ],
		"description" : "User variable 4 (float)"
	},
	"Vector entvars_t::vuser1": {
		"prefix": "vuser1",
		"body" : [ "vuser1" ],
		"description" : "User variable 1 (Vector)"
	},
	"Vector entvars_t::vuser2": {
		"prefix": "vuser2",
		"body" : [ "vuser2" ],
		"description" : "User variable 2 (Vector)"
	},
	"Vector entvars_t::vuser3": {
		"prefix": "vuser3",
		"body" : [ "vuser3" ],
		"description" : "User variable 3 (Vector)"
	},
	"Vector entvars_t::vuser4": {
		"prefix": "vuser4",
		"body" : [ "vuser4" ],
		"description" : "User variable 4 (Vector)"
	},
	"edict_t@ entvars_t::euser1": {
		"prefix": "euser1",
		"body" : [ "euser1" ],
		"description" : "User variable 1 (Edict)"
	},
	"edict_t@ entvars_t::euser2": {
		"prefix": "euser2",
		"body" : [ "euser2" ],
		"description" : "User variable 2 (Edict)"
	},
	"edict_t@ entvars_t::euser3": {
		"prefix": "euser3",
		"body" : [ "euser3" ],
		"description" : "User variable 3 (Edict)"
	},
	"edict_t@ entvars_t::euser4": {
		"prefix": "euser4",
		"body" : [ "euser4" ],
		"description" : "User variable 4 (Edict)"
	},
	"enum Entvartype {..., VAR_INVALID, ...}": {
		"prefix": "VAR_INVALID",
		"body" : [ "VAR_INVALID" ],
		"description" : "(0) Invalid type"
	},
	"enum Entvartype {..., VAR_STRING, ...}": {
		"prefix": "VAR_STRING",
		"body" : [ "VAR_STRING" ],
		"description" : "(1) String type"
	},
	"enum Entvartype {..., VAR_VECTOR, ...}": {
		"prefix": "VAR_VECTOR",
		"body" : [ "VAR_VECTOR" ],
		"description" : "(2) Vector type"
	},
	"enum Entvartype {..., VAR_FLOAT, ...}": {
		"prefix": "VAR_FLOAT",
		"body" : [ "VAR_FLOAT" ],
		"description" : "(3) Float type"
	},
	"enum Entvartype {..., VAR_INTEGER, ...}": {
		"prefix": "VAR_INTEGER",
		"body" : [ "VAR_INTEGER" ],
		"description" : "(4) Integer type"
	},
	"enum Entvartype {..., VAR_EDICT, ...}": {
		"prefix": "VAR_EDICT",
		"body" : [ "VAR_EDICT" ],
		"description" : "(5) Edict type"
	},
	"enum Entvartype {..., VAR_BYTE4, ...}": {
		"prefix": "VAR_BYTE4",
		"body" : [ "VAR_BYTE4" ],
		"description" : "(6) 4 byte array type"
	},
	"enum Entvartype {..., VAR_BYTE2, ...}": {
		"prefix": "VAR_BYTE2",
		"body" : [ "VAR_BYTE2" ],
		"description" : "(7) 2 byte array type"
	},
	"enum Entvartype {..., VAR_CUSTOM, ...}": {
		"prefix": "VAR_CUSTOM",
		"body" : [ "VAR_CUSTOM" ],
		"description" : "(8) Custom type"
	},
	"enum FCAP {..., FCAP_CUSTOMSAVE, ...}": {
		"prefix": "FCAP_CUSTOMSAVE",
		"body" : [ "FCAP_CUSTOMSAVE" ],
		"description" : "(1) Custom save method"
	},
	"enum FCAP {..., FCAP_ACROSS_TRANSITION, ...}": {
		"prefix": "FCAP_ACROSS_TRANSITION",
		"body" : [ "FCAP_ACROSS_TRANSITION" ],
		"description" : "(2) Across transition"
	},
	"enum FCAP {..., FCAP_MUST_SPAWN, ...}": {
		"prefix": "FCAP_MUST_SPAWN",
		"body" : [ "FCAP_MUST_SPAWN" ],
		"description" : "(4) Must spawn"
	},
	"enum FCAP {..., FCAP_DONT_SAVE, ...}": {
		"prefix": "FCAP_DONT_SAVE",
		"body" : [ "FCAP_DONT_SAVE" ],
		"description" : "(-2147483648) Don't save"
	},
	"enum FCAP {..., FCAP_IMPULSE_USE, ...}": {
		"prefix": "FCAP_IMPULSE_USE",
		"body" : [ "FCAP_IMPULSE_USE" ],
		"description" : "(8) Impulse use"
	},
	"enum FCAP {..., FCAP_CONTINUOUS_USE, ...}": {
		"prefix": "FCAP_CONTINUOUS_USE",
		"body" : [ "FCAP_CONTINUOUS_USE" ],
		"description" : "(16) Continuous use"
	},
	"enum FCAP {..., FCAP_ONOFF_USE, ...}": {
		"prefix": "FCAP_ONOFF_USE",
		"body" : [ "FCAP_ONOFF_USE" ],
		"description" : "(32) On/off use"
	},
	"enum FCAP {..., FCAP_DIRECTIONAL_USE, ...}": {
		"prefix": "FCAP_DIRECTIONAL_USE",
		"body" : [ "FCAP_DIRECTIONAL_USE" ],
		"description" : "(64) Directional use"
	},
	"enum FCAP {..., FCAP_MASTER, ...}": {
		"prefix": "FCAP_MASTER",
		"body" : [ "FCAP_MASTER" ],
		"description" : "(128) Is a master"
	},
	"enum FCAP {..., FCAP_FORCE_TRANSITION, ...}": {
		"prefix": "FCAP_FORCE_TRANSITION",
		"body" : [ "FCAP_FORCE_TRANSITION" ],
		"description" : "(128) Force transition"
	},
	"enum FCVAR {..., FCVAR_ARCHIVE, ...}": {
		"prefix": "FCVAR_ARCHIVE",
		"body" : [ "FCVAR_ARCHIVE" ],
		"description" : "(1) Save this cvar."
	},
	"enum FCVAR {..., FCVAR_USERINFO, ...}": {
		"prefix": "FCVAR_USERINFO",
		"body" : [ "FCVAR_USERINFO" ],
		"description" : "(2) Changes the client's info string."
	},
	"enum FCVAR {..., FCVAR_SERVER, ...}": {
		"prefix": "FCVAR_SERVER",
		"body" : [ "FCVAR_SERVER" ],
		"description" : "(4) Notifies players when changed."
	},
	"enum FCVAR {..., FCVAR_EXTDLL, ...}": {
		"prefix": "FCVAR_EXTDLL",
		"body" : [ "FCVAR_EXTDLL" ],
		"description" : "(8) Defined by external dll."
	},
	"enum FCVAR {..., FCVAR_CLIENTDLL, ...}": {
		"prefix": "FCVAR_CLIENTDLL",
		"body" : [ "FCVAR_CLIENTDLL" ],
		"description" : "(16) Defined by the client dll."
	},
	"enum FCVAR {..., FCVAR_PROTECTED, ...}": {
		"prefix": "FCVAR_PROTECTED",
		"body" : [ "FCVAR_PROTECTED" ],
		"description" : "(32) It's a server cvar, but we don't send the data since it's a password, etc."
	},
	"enum FCVAR {..., FCVAR_SPONLY, ...}": {
		"prefix": "FCVAR_SPONLY",
		"body" : [ "FCVAR_SPONLY" ],
		"description" : "(64) This cvar cannot be changed by clients connected to a multiplayer server."
	},
	"enum FCVAR {..., FCVAR_PRINTABLEONLY, ...}": {
		"prefix": "FCVAR_PRINTABLEONLY",
		"body" : [ "FCVAR_PRINTABLEONLY" ],
		"description" : "(128) This cvar's string cannot contain unprintable characters (e.g. used for player name etc)"
	},
	"enum FCVAR {..., FCVAR_UNLOGGED, ...}": {
		"prefix": "FCVAR_UNLOGGED",
		"body" : [ "FCVAR_UNLOGGED" ],
		"description" : "(256) If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log"
	},
	"enum FFADE {..., FFADE_IN, ...}": {
		"prefix": "FFADE_IN",
		"body" : [ "FFADE_IN" ],
		"description" : "(0) Just here so we don't pass 0 into the function"
	},
	"enum FFADE {..., FFADE_OUT, ...}": {
		"prefix": "FFADE_OUT",
		"body" : [ "FFADE_OUT" ],
		"description" : "(1) Fade out (not in)"
	},
	"enum FFADE {..., FFADE_MODULATE, ...}": {
		"prefix": "FFADE_MODULATE",
		"body" : [ "FFADE_MODULATE" ],
		"description" : "(2) Modulate (don't blend)"
	},
	"enum FFADE {..., FFADE_STAYOUT, ...}": {
		"prefix": "FFADE_STAYOUT",
		"body" : [ "FFADE_STAYOUT" ],
		"description" : "(4) ignores the duration, stays faded out until new ScreenFade message received"
	},
	"bool File::IsOpen() const": {
		"prefix": "IsOpen",
		"body" : [ "IsOpen()" ],
		"description" : "Returns whether the file was successfully opened."
	},
	"void File::Close()": {
		"prefix": "Close",
		"body" : [ "Close()" ],
		"description" : "Closes the file if it is open."
	},
	"void File::Remove()": {
		"prefix": "Remove",
		"body" : [ "Remove()" ],
		"description" : "Removes the file. The file must be open, and you must have write access."
	},
	"size_t File::GetSize() const": {
		"prefix": "GetSize",
		"body" : [ "GetSize()" ],
		"description" : "Returns the size of the file."
	},
	"size_t File::Tell() const": {
		"prefix": "Tell",
		"body" : [ "Tell()" ],
		"description" : "Tells the position of the read/write pointer."
	},
	"size_t File::Seek(const size_t uiPosition, const SeekFileFlags_t uiSeekMode)": {
		"prefix": "Seek",
		"body" : [ "Seek( ${1:const size_t uiPosition}, ${2:const SeekFileFlags_t uiSeekMode} )" ],
		"description" : "Sets the read/write pointer to a new position. Returns the new position within the file."
	},
	"bool File::EOFReached() const": {
		"prefix": "EOFReached",
		"body" : [ "EOFReached()" ],
		"description" : "Returns whether end of file was reached."
	},
	"string File::ReadCharacter()": {
		"prefix": "ReadCharacter",
		"body" : [ "ReadCharacter()" ],
		"description" : "Reads a single character."
	},
	"void File::ReadLine(string& out szOutLine, const string& in szDelim = '\\n')": {
		"prefix": "ReadLine",
		"body" : [ "ReadLine( ${1:string& out szOutLine}, ${2:const string& in szDelim = '\\n'} )" ],
		"description" : "Reads a line from the file."
	},
	"bool File::Read(BLOB@ pBlob, size_t uiSizeInBytes)": {
		"prefix": "Read",
		"body" : [ "Read( ${1:BLOB@ pBlob}, ${2:size_t uiSizeInBytes} )" ],
		"description" : "Reads a number of bytes into the given BLOB."
	},
	"bool File::Read(BLOB@ pBlob)": {
		"prefix": "Read",
		"body" : [ "Read( ${1:BLOB@ pBlob} )" ],
		"description" : "Reads as much as possible data into the given BLOB."
	},
	"BLOB@ File::ReadBlob(size_t uiSizeInBytes, bool fCanResize = true)": {
		"prefix": "ReadBlob",
		"body" : [ "ReadBlob( ${1:size_t uiSizeInBytes}, ${2:bool fCanResize = true} )" ],
		"description" : "Reads a number of bytes into a BLOB."
	},
	"BLOB@ File::ReadBlob()": {
		"prefix": "ReadBlob",
		"body" : [ "ReadBlob()" ],
		"description" : "Reads as much as possible data into a BLOB."
	},
	"void File::Write(const string& in szString)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:const string& in szString} )" ],
		"description" : "Writes a string to the file."
	},
	"void File::Write(const BLOB@ pBlob)": {
		"prefix": "Write",
		"body" : [ "Write( ${1:const BLOB@ pBlob} )" ],
		"description" : "Writes a blob to the file."
	},
	"size_t FileQuota::GetTotalSize() const": {
		"prefix": "GetTotalSize",
		"body" : [ "GetTotalSize()" ],
		"description" : "Gets the total size, in bytes, that is allowed to be used by filesystems using this quota object."
	},
	"size_t FileQuota::GetSizeInUse() const": {
		"prefix": "GetSizeInUse",
		"body" : [ "GetSizeInUse()" ],
		"description" : "Gets the size, in bytes, that is in use."
	},
	"size_t FileQuota::GetSizeLeft() const": {
		"prefix": "GetSizeLeft",
		"body" : [ "GetSizeLeft()" ],
		"description" : "Gets the amount of size, in bytes, left that can be written to."
	},
	"bool FileQuota::CanWriteAmount(size_t uiSizeInBytes) const": {
		"prefix": "CanWriteAmount",
		"body" : [ "CanWriteAmount( ${1:size_t uiSizeInBytes} )" ],
		"description" : "Returns whether the given amount of bytes can be written."
	},
	"size_t FileQuota::SizeLeftAfterWrite(size_t uiSizeInBytes) const": {
		"prefix": "SizeLeftAfterWrite",
		"body" : [ "SizeLeftAfterWrite( ${1:size_t uiSizeInBytes} )" ],
		"description" : "Returns the size that is left after the given amount of bytes have been written."
	},
	"enum FireBulletsDrawMode {..., FBDM_DONTDRAW, ...}": {
		"prefix": "FBDM_DONTDRAW",
		"body" : [ "FBDM_DONTDRAW" ],
		"description" : "(0) Don't draw impact decal"
	},
	"enum FireBulletsDrawMode {..., FBDM_DRAW, ...}": {
		"prefix": "FBDM_DRAW",
		"body" : [ "FBDM_DRAW" ],
		"description" : "(2) Draw impact decal"
	},
	"enum FixAngleMode {..., FAM_NOTHING, ...}": {
		"prefix": "FAM_NOTHING",
		"body" : [ "FAM_NOTHING" ],
		"description" : "(0) Do nothing"
	},
	"enum FixAngleMode {..., FAM_FORCEVIEWANGLES, ...}": {
		"prefix": "FAM_FORCEVIEWANGLES",
		"body" : [ "FAM_FORCEVIEWANGLES" ],
		"description" : "(1) Force player view angles to entvars_t::angles"
	},
	"enum FixAngleMode {..., FAM_ADDAVELOCITY, ...}": {
		"prefix": "FAM_ADDAVELOCITY",
		"body" : [ "FAM_ADDAVELOCITY" ],
		"description" : "(2) Add avelocity to player view angles"
	},
	"enum Regex::FlagType {..., icase, ...}": {
		"prefix": "icase",
		"body" : [ "Regex::icase" ],
		"description" : "(256)"
	},
	"enum Regex::FlagType {..., nosubs, ...}": {
		"prefix": "nosubs",
		"body" : [ "Regex::nosubs" ],
		"description" : "(512)"
	},
	"enum Regex::FlagType {..., optimize, ...}": {
		"prefix": "optimize",
		"body" : [ "Regex::optimize" ],
		"description" : "(1024)"
	},
	"enum Regex::FlagType {..., collate, ...}": {
		"prefix": "collate",
		"body" : [ "Regex::collate" ],
		"description" : "(2048)"
	},
	"enum Regex::FlagType {..., ECMAScript, ...}": {
		"prefix": "ECMAScript",
		"body" : [ "Regex::ECMAScript" ],
		"description" : "(1)"
	},
	"enum Regex::FlagType {..., basic, ...}": {
		"prefix": "basic",
		"body" : [ "Regex::basic" ],
		"description" : "(2)"
	},
	"enum Regex::FlagType {..., extended, ...}": {
		"prefix": "extended",
		"body" : [ "Regex::extended" ],
		"description" : "(4)"
	},
	"enum Regex::FlagType {..., awk, ...}": {
		"prefix": "awk",
		"body" : [ "Regex::awk" ],
		"description" : "(8)"
	},
	"enum Regex::FlagType {..., grep, ...}": {
		"prefix": "grep",
		"body" : [ "Regex::grep" ],
		"description" : "(16)"
	},
	"enum Regex::FlagType {..., egrep, ...}": {
		"prefix": "egrep",
		"body" : [ "Regex::egrep" ],
		"description" : "(32)"
	},
	"void ThinkFunction()": {
		"prefix": "ThinkFunction",
		"body" : [ "ThinkFunction()" ],
		"description" : "Function definition for custom entity Think functions"
	},
	"void UseFunction(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue)": {
		"prefix": "UseFunction",
		"body" : [ "UseFunction( ${1:CBaseEntity@ pActivator}, ${2:CBaseEntity@ pCaller}, ${3:USE_TYPE useType}, ${4:float flValue} )" ],
		"description" : "Function definition for custom entity Use functions"
	},
	"void TouchFunction(CBaseEntity@ pOther)": {
		"prefix": "TouchFunction",
		"body" : [ "TouchFunction( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Function definition for custom entity Touch functions"
	},
	"void BlockedFunction(CBaseEntity@ pOther)": {
		"prefix": "BlockedFunction",
		"body" : [ "BlockedFunction( ${1:CBaseEntity@ pOther} )" ],
		"description" : "Function definition for custom entity Blocked functions"
	},
	"void TextMenuPlayerSlotCallback(CTextMenu@ menu, CBasePlayer@ pPlayer, int iSlot, const CTextMenuItem@ pItem)": {
		"prefix": "TextMenuPlayerSlotCallback",
		"body" : [ "TextMenuPlayerSlotCallback( ${1:CTextMenu@ menu}, ${2:CBasePlayer@ pPlayer}, ${3:int iSlot}, ${4:const CTextMenuItem@ pItem} )" ],
		"description" : "Player slot callback for text menus."
	},
	"void VoteBlocked(Vote@ pVote, float flTime)": {
		"prefix": "VoteBlocked",
		"body" : [ "VoteBlocked( ${1:Vote@ pVote}, ${2:float flTime} )" ],
		"description" : "Funcdef for vote blocked callbacks. The given time is when the active vote has ended."
	},
	"void VoteEnd(Vote@ pVote, bool fResult, int iVoters)": {
		"prefix": "VoteEnd",
		"body" : [ "VoteEnd( ${1:Vote@ pVote}, ${2:bool fResult}, ${3:int iVoters} )" ],
		"description" : "Funcdef for vote ended callbacks. If fResult is true, users voted for yes. Otherwise, voted for no."
	},
	"void ConCommandCallback(const CCommand@ args)": {
		"prefix": "ConCommandCallback",
		"body" : [ "ConCommandCallback( ${1:const CCommand@ args} )" ],
		"description" : "Callback for server console commands."
	},
	"void ClientCommandCallback(const CCommand@ args)": {
		"prefix": "ClientCommandCallback",
		"body" : [ "ClientCommandCallback( ${1:const CCommand@ args} )" ],
		"description" : "Callback for client console commands."
	},
	"void CVarCallback(CCVar@ cvar, const string& in szOldValue, float flOldValue)": {
		"prefix": "CVarCallback",
		"body" : [ "CVarCallback( ${1:CCVar@ cvar}, ${2:const string& in szOldValue}, ${3:float flOldValue} )" ],
		"description" : "Callback for cvars."
	},
	"HookReturnCode WeaponTertiaryAttackHook(CBasePlayer@ pPlayer, CBasePlayerWeapon@ pWeapon)": {
		"prefix": "WeaponTertiaryAttackHook",
		"body" : [ "WeaponTertiaryAttackHook( ${1:CBasePlayer@ pPlayer}, ${2:CBasePlayerWeapon@ pWeapon} )" ],
		"description" : "Called when a player fires a weapon's tertiary attack."
	},
	"HookReturnCode WeaponSecondaryAttackHook(CBasePlayer@ pPlayer, CBasePlayerWeapon@ pWeapon)": {
		"prefix": "WeaponSecondaryAttackHook",
		"body" : [ "WeaponSecondaryAttackHook( ${1:CBasePlayer@ pPlayer}, ${2:CBasePlayerWeapon@ pWeapon} )" ],
		"description" : "Called when a player fires a weapon's secondary attack."
	},
	"HookReturnCode WeaponPrimaryAttackHook(CBasePlayer@ pPlayer, CBasePlayerWeapon@ pWeapon)": {
		"prefix": "WeaponPrimaryAttackHook",
		"body" : [ "WeaponPrimaryAttackHook( ${1:CBasePlayer@ pPlayer}, ${2:CBasePlayerWeapon@ pWeapon} )" ],
		"description" : "Called when a player fires a weapon's primary attack."
	},
	"HookReturnCode PlayerPreDecalHook(CBasePlayer@ pPlayer, const TraceResult& in trace, bool& out bResult)": {
		"prefix": "PlayerPreDecalHook",
		"body" : [ "PlayerPreDecalHook( ${1:CBasePlayer@ pPlayer}, ${2:const TraceResult& in trace}, ${3:bool& out bResult} )" ],
		"description" : "Called when a player attempts to spraypaint a decal onto a surface. The given trace result contains the surface information. Set bResult to false if the player shouldn't be able to spray."
	},
	"HookReturnCode PlayerDecalHook(CBasePlayer@ pPlayer, const TraceResult& in trace)": {
		"prefix": "PlayerDecalHook",
		"body" : [ "PlayerDecalHook( ${1:CBasePlayer@ pPlayer}, ${2:const TraceResult& in trace} )" ],
		"description" : "Called when a player is spraypainting a decal onto a surface. The given trace result contains the surface information."
	},
	"HookReturnCode GetPlayerSpawnSpotHook(CBasePlayer@ pPlayer, CBaseEntity@& out ppEntSpawnSpot)": {
		"prefix": "GetPlayerSpawnSpotHook",
		"body" : [ "GetPlayerSpawnSpotHook( ${1:CBasePlayer@ pPlayer}, ${2:CBaseEntity@& out ppEntSpawnSpot} )" ],
		"description" : "Called when a player is about to get a spawn point before (re)spawning."
	},
	"HookReturnCode PlayerPostThinkHook(CBasePlayer@ pPlayer)": {
		"prefix": "PlayerPostThinkHook",
		"body" : [ "PlayerPostThinkHook( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Called when the player is processing post think events."
	},
	"HookReturnCode PlayerPreThinkHook(CBasePlayer@ pPlayer, uint& out uiFlags)": {
		"prefix": "PlayerPreThinkHook",
		"body" : [ "PlayerPreThinkHook( ${1:CBasePlayer@ pPlayer}, ${2:uint& out uiFlags} )" ],
		"description" : "Called when the player is processing pre think events."
	},
	"HookReturnCode PlayerUseHook(CBasePlayer@ pPlayer, uint& out uiFlags)": {
		"prefix": "PlayerUseHook",
		"body" : [ "PlayerUseHook( ${1:CBasePlayer@ pPlayer}, ${2:uint& out uiFlags} )" ],
		"description" : "Called when the game is processing player use input. Note that this occurs even if the player has not pressed their use key."
	},
	"HookReturnCode PlayerLeftObserverHook(CBasePlayer@ pPlayer)": {
		"prefix": "PlayerLeftObserverHook",
		"body" : [ "PlayerLeftObserverHook( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Called when a player leaves observer mode."
	},
	"HookReturnCode PlayerEnteredObserverHook(CBasePlayer@ pPlayer)": {
		"prefix": "PlayerEnteredObserverHook",
		"body" : [ "PlayerEnteredObserverHook( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Called when a player enters observer mode."
	},
	"HookReturnCode PlayerKilledHook(CBasePlayer@ pPlayer, CBaseEntity@ pAttacker, int iGib)": {
		"prefix": "PlayerKilledHook",
		"body" : [ "PlayerKilledHook( ${1:CBasePlayer@ pPlayer}, ${2:CBaseEntity@ pAttacker}, ${3:int iGib} )" ],
		"description" : "Called when a player is killed."
	},
	"HookReturnCode PlayerTakeDamageHook(DamageInfo@ pDamageInfo)": {
		"prefix": "PlayerTakeDamageHook",
		"body" : [ "PlayerTakeDamageHook( ${1:DamageInfo@ pDamageInfo} )" ],
		"description" : "Called when a player takes damage. Note that the victim entity can't be changed at this point."
	},
	"HookReturnCode PlayerCanRespawnHook(CBasePlayer@ pPlayer, bool& out bCanRespawn)": {
		"prefix": "PlayerCanRespawnHook",
		"body" : [ "PlayerCanRespawnHook( ${1:CBasePlayer@ pPlayer}, ${2:bool& out bCanRespawn} )" ],
		"description" : "Called when the game wants to know if the player should be able to respawn or not.Set bCanRespawn to false to disallow, default true."
	},
	"HookReturnCode PlayerSpawnHook(CBasePlayer@ pPlayer)": {
		"prefix": "PlayerSpawnHook",
		"body" : [ "PlayerSpawnHook( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Called when a player (re)spawns."
	},
	"HookReturnCode ClientConnectedHook(edict_t@ pEntity, const string& in szPlayerName, const string& in szIPAddress, bool& out bDisallowJoin, string& out szRejectReason)": {
		"prefix": "ClientConnectedHook",
		"body" : [ "ClientConnectedHook( ${1:edict_t@ pEntity}, ${2:const string& in szPlayerName}, ${3:const string& in szIPAddress}, ${4:bool& out bDisallowJoin}, ${5:string& out szRejectReason} )" ],
		"description" : "Called when a player connects to the server. if bDisallowJoin is set to false, the player is disconnected. szRejectReason is shown to the player if disconnected. The maximum length of the reject reason string is 127 characters."
	},
	"HookReturnCode CollectedHook(CBaseEntity@ pPickup, CBaseEntity@ pOther)": {
		"prefix": "CollectedHook",
		"body" : [ "CollectedHook( ${1:CBaseEntity@ pPickup}, ${2:CBaseEntity@ pOther} )" ],
		"description" : "Called when a pickup object is collected by a player."
	},
	"HookReturnCode MaterializeHook(CBaseEntity@ pPickup)": {
		"prefix": "MaterializeHook",
		"body" : [ "MaterializeHook( ${1:CBaseEntity@ pPickup} )" ],
		"description" : "Called when a pickup object materializes."
	},
	"HookReturnCode CanCollectHook(CBaseEntity@ pPickup, CBaseEntity@ pOther, bool& out bResult )": {
		"prefix": "CanCollectHook",
		"body" : [ "CanCollectHook( ${1:CBaseEntity@ pPickup}, ${2:CBaseEntity@ pOther}, ${3:bool& out bResult } )" ],
		"description" : "Called when a pickup object is about to be collected by a player. Note that basic checks are done before this hook is called."
	},
	"HookReturnCode CanPlayerUseReservedSlotHook(edict_t@ pEntity, const string& in szPlayerName, const string& in szIPAddress, bool& out bAllowJoin)": {
		"prefix": "CanPlayerUseReservedSlotHook",
		"body" : [ "CanPlayerUseReservedSlotHook( ${1:edict_t@ pEntity}, ${2:const string& in szPlayerName}, ${3:const string& in szIPAddress}, ${4:bool& out bAllowJoin} )" ],
		"description" : "Called when a player connects to the server, and the number of slots left on the server is <= the number of reserved slots. Set bAllowJoin to true to allow the player to join (default false)."
	},
	"HookReturnCode ClientSayHook(SayParameters@ pParams)": {
		"prefix": "ClientSayHook",
		"body" : [ "ClientSayHook( ${1:SayParameters@ pParams} )" ],
		"description" : "Called when a player says something in game chat. The SayParameters class can be used to manipulate input and veto the message."
	},
	"HookReturnCode ClientPutInServerHook(CBasePlayer@ pPlayer)": {
		"prefix": "ClientPutInServerHook",
		"body" : [ "ClientPutInServerHook( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Called when a player has finished connecting and is put into the world. It is safe to send network messages to the player at this point."
	},
	"HookReturnCode ClientDisconnectHook(CBasePlayer@ pPlayer)": {
		"prefix": "ClientDisconnectHook",
		"body" : [ "ClientDisconnectHook( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Called when a player disconnects. Note that this is only called if the player was fully connected, meaning the player went through ClientPutInServer. This is never called for the local host."
	},
	"HookReturnCode EntityCreatedHook(CBaseEntity@ pEntity)": {
		"prefix": "EntityCreatedHook",
		"body" : [ "EntityCreatedHook( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Called when a new entity is created. At this point the entity is not spawned yet and may not be fully initialized."
	},
	"HookReturnCode MapChangeHook()": {
		"prefix": "MapChangeHook",
		"body" : [ "MapChangeHook()" ],
		"description" : "Called when the map changes. This happens when the world is destroyed. There may still be entities that exist at this point."
	},
	"Callable@ Reflection::Function::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"string Reflection::Function::GetNamespace() const": {
		"prefix": "GetNamespace",
		"body" : [ "GetNamespace()" ],
		"description" : "Gets this instance's namespace."
	},
	"string Reflection::Function::GetName() const": {
		"prefix": "GetName",
		"body" : [ "GetName()" ],
		"description" : "Gets this instance's name."
	},
	"bool Reflection::Function::Equals(const Callable@ pCallable) const": {
		"prefix": "Equals",
		"body" : [ "Equals( ${1:const Callable@ pCallable} )" ],
		"description" : "Returns whether the given callable type is identical to this one."
	},
	"bool Reflection::Function::IsCompatible(const Callable@ pCallable) const": {
		"prefix": "IsCompatible",
		"body" : [ "IsCompatible( ${1:const Callable@ pCallable} )" ],
		"description" : "Returns whether the given object type is compatible with this one."
	},
	"ReturnValue@ Reflection::Function::Call(Arguments@ pArguments)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:Arguments@ pArguments} )" ],
		"description" : "Calls this function. pArguments must be valid."
	},
	"ReturnValue@ Reflection::Function::Call()": {
		"prefix": "Call",
		"body" : [ "Call()" ],
		"description" : "Calls this function."
	},
	"ReturnValue@ Reflection::Function::Call(?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in} )" ],
		"description" : "Calls this function."
	},
	"ReturnValue@ Reflection::Function::Call(?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in}, ${2:?& in} )" ],
		"description" : "Calls this function."
	},
	"ReturnValue@ Reflection::Function::Call(?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in}, ${2:?& in}, ${3:?& in} )" ],
		"description" : "Calls this function."
	},
	"ReturnValue@ Reflection::Function::Call(?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in} )" ],
		"description" : "Calls this function."
	},
	"ReturnValue@ Reflection::Function::Call(?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Calls this function."
	},
	"ReturnValue@ Reflection::Function::Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Calls this function."
	},
	"ReturnValue@ Reflection::Function::Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Calls this function."
	},
	"ReturnValue@ Reflection::Function::Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Calls this function."
	},
	"bool isalnum(char character)": {
		"prefix": "isalnum",
		"body" : [ "isalnum( ${1:char character} )" ],
		"description" : "Returns whether character is alphanumeric."
	},
	"bool isalpha(char character)": {
		"prefix": "isalpha",
		"body" : [ "isalpha( ${1:char character} )" ],
		"description" : "Returns whether character is alphabetic."
	},
	"bool iscntrl(char character)": {
		"prefix": "iscntrl",
		"body" : [ "iscntrl( ${1:char character} )" ],
		"description" : "Returns whether character is control."
	},
	"bool isdigit(char character)": {
		"prefix": "isdigit",
		"body" : [ "isdigit( ${1:char character} )" ],
		"description" : "Returns whether character is a decimal digit character."
	},
	"bool isgraph(char character)": {
		"prefix": "isgraph",
		"body" : [ "isgraph( ${1:char character} )" ],
		"description" : "Returns whether character is graph."
	},
	"bool islower(char character)": {
		"prefix": "islower",
		"body" : [ "islower( ${1:char character} )" ],
		"description" : "Returns whether character is lower."
	},
	"bool isprint(char character)": {
		"prefix": "isprint",
		"body" : [ "isprint( ${1:char character} )" ],
		"description" : "Returns whether character is print."
	},
	"bool ispunct(char character)": {
		"prefix": "ispunct",
		"body" : [ "ispunct( ${1:char character} )" ],
		"description" : "Returns whether character is punctuality."
	},
	"bool isspace(char character)": {
		"prefix": "isspace",
		"body" : [ "isspace( ${1:char character} )" ],
		"description" : "Returns whether character is space."
	},
	"bool isupper(char character)": {
		"prefix": "isupper",
		"body" : [ "isupper( ${1:char character} )" ],
		"description" : "Returns whether character is upper."
	},
	"bool isxdigit(char character)": {
		"prefix": "isxdigit",
		"body" : [ "isxdigit( ${1:char character} )" ],
		"description" : "Returns whether character is a hexadecimal numeric character."
	},
	"char tolower(char character)": {
		"prefix": "tolower",
		"body" : [ "tolower( ${1:char character} )" ],
		"description" : "Converts the given character to lower case."
	},
	"char toupper(char character)": {
		"prefix": "toupper",
		"body" : [ "toupper( ${1:char character} )" ],
		"description" : "Converts the given character to upper case."
	},
	"float atof(const string& in)": {
		"prefix": "atof",
		"body" : [ "atof( ${1:const string& in} )" ],
		"description" : "Converts the given string to a float."
	},
	"double atod(const string& in)": {
		"prefix": "atod",
		"body" : [ "atod( ${1:const string& in} )" ],
		"description" : "Converts the given string to a double."
	},
	"int atoi(const string& in, int radix = 10)": {
		"prefix": "atoi",
		"body" : [ "atoi( ${1:const string& in}, ${2:int radix = 10} )" ],
		"description" : "Converts the given string to an integer."
	},
	"int64 atoi64(const string& in, int radix = 10)": {
		"prefix": "atoi64",
		"body" : [ "atoi64( ${1:const string& in}, ${2:int radix = 10} )" ],
		"description" : "Converts the given string to a 64 bit integer."
	},
	"uint atoui(const string& in, int radix = 10)": {
		"prefix": "atoui",
		"body" : [ "atoui( ${1:const string& in}, ${2:int radix = 10} )" ],
		"description" : "Converts the given string to an unsigned integer."
	},
	"uint64 atoui64(const string& in, int radix = 10)": {
		"prefix": "atoui64",
		"body" : [ "atoui64( ${1:const string& in}, ${2:int radix = 10} )" ],
		"description" : "Converts the given string to a 64 bit unsigned integer."
	},
	"bool atobool(const string& in)": {
		"prefix": "atobool",
		"body" : [ "atobool( ${1:const string& in} )" ],
		"description" : "Converts the given string to a boolean."
	},
	"bool atobool(const string& in, bool& out fIsValid)": {
		"prefix": "atobool",
		"body" : [ "atobool( ${1:const string& in}, ${2:bool& out fIsValid} )" ],
		"description" : "Converts the given string to a boolean. fIsValid is true if the given string was a valid boolean value."
	},
	"bool isalnum(const string& in)": {
		"prefix": "isalnum",
		"body" : [ "isalnum( ${1:const string& in} )" ],
		"description" : "Returns whether character is alphanumeric."
	},
	"bool isalpha(const string& in)": {
		"prefix": "isalpha",
		"body" : [ "isalpha( ${1:const string& in} )" ],
		"description" : "Returns whether character is alphabetic."
	},
	"bool iscntrl(const string& in)": {
		"prefix": "iscntrl",
		"body" : [ "iscntrl( ${1:const string& in} )" ],
		"description" : "Returns whether character is control."
	},
	"bool isdigit(const string& in)": {
		"prefix": "isdigit",
		"body" : [ "isdigit( ${1:const string& in} )" ],
		"description" : "Returns whether character is digit."
	},
	"bool isgraph(const string& in)": {
		"prefix": "isgraph",
		"body" : [ "isgraph( ${1:const string& in} )" ],
		"description" : "Returns whether character is graph."
	},
	"bool islower(const string& in)": {
		"prefix": "islower",
		"body" : [ "islower( ${1:const string& in} )" ],
		"description" : "Returns whether character is lower."
	},
	"bool isprint(const string& in)": {
		"prefix": "isprint",
		"body" : [ "isprint( ${1:const string& in} )" ],
		"description" : "Returns whether character is print."
	},
	"bool ispunct(const string& in)": {
		"prefix": "ispunct",
		"body" : [ "ispunct( ${1:const string& in} )" ],
		"description" : "Returns whether character is punctuality."
	},
	"bool isspace(const string& in)": {
		"prefix": "isspace",
		"body" : [ "isspace( ${1:const string& in} )" ],
		"description" : "Returns whether character is space."
	},
	"bool isupper(const string& in)": {
		"prefix": "isupper",
		"body" : [ "isupper( ${1:const string& in} )" ],
		"description" : "Returns whether character is upper."
	},
	"bool isxdigit(const string& in)": {
		"prefix": "isxdigit",
		"body" : [ "isxdigit( ${1:const string& in} )" ],
		"description" : "Returns whether character is xdigit."
	},
	"string tolower(const string& in)": {
		"prefix": "tolower",
		"body" : [ "tolower( ${1:const string& in} )" ],
		"description" : "Converts the given character to lower case."
	},
	"string toupper(const string& in)": {
		"prefix": "toupper",
		"body" : [ "toupper( ${1:const string& in} )" ],
		"description" : "Converts the given character to upper case."
	},
	"string formatInt(int64 value, const string &in options = \"\", uint width = 0)": {
		"prefix": "formatInt",
		"body" : [ "formatInt( ${1:int64 value}, ${2:const string &in options = \"\"}, ${3:uint width = 0} )" ],
		"description" : "Formats a signed integer into a string. The options string is a combination of the following characters:. 'l' = left justify. '0' = pad with zeroes. '+' = always include the sign, even if positive. ' ' = add a space in case of positive number. 'h' = hexadecimal integer small letters. 'H' = hexadecimal integer capital letters. "
	},
	"string formatUInt(uint64 value, const string &in options = \"\", uint width = 0)": {
		"prefix": "formatUInt",
		"body" : [ "formatUInt( ${1:uint64 value}, ${2:const string &in options = \"\"}, ${3:uint width = 0} )" ],
		"description" : "Formats a unsigned integer into a string. The options string is a combination of the following characters:. 'l' = left justify. '0' = pad with zeroes. '+' = always include the sign, even if positive. ' ' = add a space in case of positive number. 'h' = hexadecimal integer small letters. 'H' = hexadecimal integer capital letters. "
	},
	"string formatFloat(double value, const string &in options = \"\", uint width = 0, uint precision = 0)": {
		"prefix": "formatFloat",
		"body" : [ "formatFloat( ${1:double value}, ${2:const string &in options = \"\"}, ${3:uint width = 0}, ${4:uint precision = 0} )" ],
		"description" : "Formats a double into a string. The options string is a combination of the following characters:. 'l' = left justify. '0' = pad with zeroes. '+' = always include the sign, even if positive. ' ' = add a space in case of positive number. 'e' = exponent character with small e. 'E' = exponent character with capital E. "
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat}, ${3:?& in} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "snprintf",
		"body" : [ "snprintf( ${1:string& out szOutBuffer}, ${2:const string& in szFormat}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in}, ${10:?& in} )" ],
		"description" : "Prints the format string to the destination buffer. Uses SC printf formatting style."
	},
	"bool Regex::Match(const string& in szString, const Regex@ pRegex, MatchFlagType flags = match_default)": {
		"prefix": "Match",
		"body" : [ "Match( ${1:const string& in szString}, ${2:const Regex@ pRegex}, ${3:MatchFlagType flags = match_default} )" ],
		"description" : "Performs are regular expression matching operation. Returns true if the match succeeded, false otherwise"
	},
	"bool Regex::Match(const string& in szString, MatchResults@ pResults, const Regex@ pRegex, MatchFlagType flags = match_default)": {
		"prefix": "Match",
		"body" : [ "Match( ${1:const string& in szString}, ${2:MatchResults@ pResults}, ${3:const Regex@ pRegex}, ${4:MatchFlagType flags = match_default} )" ],
		"description" : "Performs are regular expression matching operation. Returns true if the match succeeded, false otherwise. pResults will contain the results of the operation, if any."
	},
	"bool Regex::Search(const string& in szString, const Regex@ pRegex, MatchFlagType flags = match_default)": {
		"prefix": "Search",
		"body" : [ "Search( ${1:const string& in szString}, ${2:const Regex@ pRegex}, ${3:MatchFlagType flags = match_default} )" ],
		"description" : "Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression pRegex."
	},
	"bool Regex::Search(const string& in szString, MatchResults@ pResults, const Regex@ pRegex, MatchFlagType flags = match_default)": {
		"prefix": "Search",
		"body" : [ "Search( ${1:const string& in szString}, ${2:MatchResults@ pResults}, ${3:const Regex@ pRegex}, ${4:MatchFlagType flags = match_default} )" ],
		"description" : "Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression pRegex. pResults will contain the results of the operation, if any."
	},
	"string Regex::Replace(const string& in szString, const Regex@ pRegex, const string& in szFormat, MatchFlagType flags = match_default)": {
		"prefix": "Replace",
		"body" : [ "Replace( ${1:const string& in szString}, ${2:const Regex@ pRegex}, ${3:const string& in szFormat}, ${4:MatchFlagType flags = match_default} )" ],
		"description" : "Makes a copy of the target sequence (the subject) with all matches of the regular expression pRegex (the pattern) replaced by szFormat (the replacement)."
	},
	"bool FileSystem::FlagsValid(const OpenFileFlags_t uiOpenFlags)": {
		"prefix": "FlagsValid",
		"body" : [ "FlagsValid( ${1:const OpenFileFlags_t uiOpenFlags} )" ],
		"description" : "Returns whether the given open flags are valid."
	},
	"OpenFileFlags_t FileSystem::FilterFlags(OpenFileFlags_t uiOpenFlags)": {
		"prefix": "FilterFlags",
		"body" : [ "FilterFlags( ${1:OpenFileFlags_t uiOpenFlags} )" ],
		"description" : "Filters the given flags, removing unnecessary flags."
	},
	"bool FileSystem::FormatOpenFlags(OpenFileFlags_t uiOpenFlags, string& out szOutFlags)": {
		"prefix": "FormatOpenFlags",
		"body" : [ "FormatOpenFlags( ${1:OpenFileFlags_t uiOpenFlags}, ${2:string& out szOutFlags} )" ],
		"description" : "Formats the open flags into a string that represents the flags."
	},
	"CScheduler@ get_g_Scheduler()": {
		"prefix": "get_g_Scheduler",
		"body" : [ "get_g_Scheduler()" ],
		"description" : "Gets the current script's scheduler."
	},
	"float DotProduct(const Vector2D& in lhs, const Vector2D& in rhs)": {
		"prefix": "DotProduct",
		"body" : [ "DotProduct( ${1:const Vector2D& in lhs}, ${2:const Vector2D& in rhs} )" ],
		"description" : "Returns a dot product of the given vectors"
	},
	"float DotProduct(const Vector& in lhs, const Vector& in rhs)": {
		"prefix": "DotProduct",
		"body" : [ "DotProduct( ${1:const Vector& in lhs}, ${2:const Vector& in rhs} )" ],
		"description" : "Returns the dot product of the given vectors"
	},
	"Vector CrossProduct(const Vector& in, const Vector& in)": {
		"prefix": "CrossProduct",
		"body" : [ "CrossProduct( ${1:const Vector& in}, ${2:const Vector& in} )" ],
		"description" : "Returns the cross product of the given vectors"
	},
	"int TrainSpeed(int iSpeed, int iMax)": {
		"prefix": "TrainSpeed",
		"body" : [ "TrainSpeed( ${1:int iSpeed}, ${2:int iMax} )" ],
		"description" : ""
	},
	"bool FNullEnt(const edict_t@ pEnt)": {
		"prefix": "FNullEnt",
		"body" : [ "FNullEnt( ${1:const edict_t@ pEnt} )" ],
		"description" : "Checks edict for nullity"
	},
	"bool FNullEnt(entvars_t@ pev)": {
		"prefix": "FNullEnt",
		"body" : [ "FNullEnt( ${1:entvars_t@ pev} )" ],
		"description" : "Checks entvars for nullity"
	},
	"CSoundEnt@ GetSoundEntInstance()": {
		"prefix": "GetSoundEntInstance",
		"body" : [ "GetSoundEntInstance()" ],
		"description" : "Gets the current global sound manager entity"
	},
	"CPathTrack@ PathTrackEntity_Instance(edict_t@ pEdict)": {
		"prefix": "PathTrackEntity_Instance",
		"body" : [ "PathTrackEntity_Instance( ${1:edict_t@ pEdict} )" ],
		"description" : ""
	},
	"CPersistence@ get_g_Persistence()": {
		"prefix": "get_g_Persistence",
		"body" : [ "get_g_Persistence()" ],
		"description" : "Gets the map script's persistence manager."
	},
	"time_t UnixTimestamp()": {
		"prefix": "UnixTimestamp",
		"body" : [ "UnixTimestamp()" ],
		"description" : "Gets the current time as a unix timestamp."
	},
	"CModuleHookManager@ get_g_Hooks()": {
		"prefix": "get_g_Hooks",
		"body" : [ "get_g_Hooks()" ],
		"description" : "Gets the current script's hook manager."
	},
	"CModule@ get_g_Module()": {
		"prefix": "get_g_Module",
		"body" : [ "get_g_Module()" ],
		"description" : "Gets the current script's module."
	},
	"enum GIB {..., GIB_NORMAL, ...}": {
		"prefix": "GIB_NORMAL",
		"body" : [ "GIB_NORMAL" ],
		"description" : "(0) gib if entity was overkilled"
	},
	"enum GIB {..., GIB_NEVER, ...}": {
		"prefix": "GIB_NEVER",
		"body" : [ "GIB_NEVER" ],
		"description" : "(1) never gib, no matter how much death damage is done (freezing, etc)"
	},
	"enum GIB {..., GIB_ALWAYS, ...}": {
		"prefix": "GIB_ALWAYS",
		"body" : [ "GIB_ALWAYS" ],
		"description" : "(2) always gib (Houndeye Shock, Barnacle Bite)"
	},
	"enum GIB {..., GIB_NOPENALTY, ...}": {
		"prefix": "GIB_NOPENALTY",
		"body" : [ "GIB_NOPENALTY" ],
		"description" : "(3) No penalty applied to players that died"
	},
	"string GlobalEntity::name() const": {
		"prefix": "name",
		"body" : [ "name()" ],
		"description" : "Gets the name of this global state"
	},
	"string GlobalEntity::levelName() const": {
		"prefix": "levelName",
		"body" : [ "levelName()" ],
		"description" : "Name of the level where this global state was last updated"
	},
	"GLOBALESTATE GlobalEntity::state": {
		"prefix": "state",
		"body" : [ "state" ],
		"description" : "Global state of this entity"
	},
	"GlobalEntity@ GlobalEntity::next": {
		"prefix": "next",
		"body" : [ "next" ],
		"description" : "Next global state entity in the list"
	},
	"enum GLOBALESTATE {..., GLOBAL_OFF, ...}": {
		"prefix": "GLOBAL_OFF",
		"body" : [ "GLOBAL_OFF" ],
		"description" : "(0) Global state when off"
	},
	"enum GLOBALESTATE {..., GLOBAL_ON, ...}": {
		"prefix": "GLOBAL_ON",
		"body" : [ "GLOBAL_ON" ],
		"description" : "(1) Global state when on"
	},
	"enum GLOBALESTATE {..., GLOBAL_DEAD, ...}": {
		"prefix": "GLOBAL_DEAD",
		"body" : [ "GLOBAL_DEAD" ],
		"description" : "(2) Global state when removed"
	},
	"enum HITGROUP {..., HITGROUP_GENERIC, ...}": {
		"prefix": "HITGROUP_GENERIC",
		"body" : [ "HITGROUP_GENERIC" ],
		"description" : "(0)"
	},
	"enum HITGROUP {..., HITGROUP_HEAD, ...}": {
		"prefix": "HITGROUP_HEAD",
		"body" : [ "HITGROUP_HEAD" ],
		"description" : "(1)"
	},
	"enum HITGROUP {..., HITGROUP_CHEST, ...}": {
		"prefix": "HITGROUP_CHEST",
		"body" : [ "HITGROUP_CHEST" ],
		"description" : "(2)"
	},
	"enum HITGROUP {..., HITGROUP_STOMACH, ...}": {
		"prefix": "HITGROUP_STOMACH",
		"body" : [ "HITGROUP_STOMACH" ],
		"description" : "(3)"
	},
	"enum HITGROUP {..., HITGROUP_LEFTARM, ...}": {
		"prefix": "HITGROUP_LEFTARM",
		"body" : [ "HITGROUP_LEFTARM" ],
		"description" : "(4)"
	},
	"enum HITGROUP {..., HITGROUP_RIGHTARM, ...}": {
		"prefix": "HITGROUP_RIGHTARM",
		"body" : [ "HITGROUP_RIGHTARM" ],
		"description" : "(5)"
	},
	"enum HITGROUP {..., HITGROUP_LEFTLEG, ...}": {
		"prefix": "HITGROUP_LEFTLEG",
		"body" : [ "HITGROUP_LEFTLEG" ],
		"description" : "(6)"
	},
	"enum HITGROUP {..., HITGROUP_RIGHTLEG, ...}": {
		"prefix": "HITGROUP_RIGHTLEG",
		"body" : [ "HITGROUP_RIGHTLEG" ],
		"description" : "(7)"
	},
	"enum HookReturnCode {..., HOOK_CONTINUE, ...}": {
		"prefix": "HOOK_CONTINUE",
		"body" : [ "HOOK_CONTINUE" ],
		"description" : "(0) Returned when a hook function has not handled the call"
	},
	"enum HookReturnCode {..., HOOK_HANDLED, ...}": {
		"prefix": "HOOK_HANDLED",
		"body" : [ "HOOK_HANDLED" ],
		"description" : "(1) Returned when a hook function has handled the call"
	},
	"enum HUD {..., HUD_PRINTNOTIFY, ...}": {
		"prefix": "HUD_PRINTNOTIFY",
		"body" : [ "HUD_PRINTNOTIFY" ],
		"description" : "(1) Print notify"
	},
	"enum HUD {..., HUD_PRINTCONSOLE, ...}": {
		"prefix": "HUD_PRINTCONSOLE",
		"body" : [ "HUD_PRINTCONSOLE" ],
		"description" : "(2) Print to console"
	},
	"enum HUD {..., HUD_PRINTTALK, ...}": {
		"prefix": "HUD_PRINTTALK",
		"body" : [ "HUD_PRINTTALK" ],
		"description" : "(3) Print to chat"
	},
	"enum HUD {..., HUD_PRINTCENTER, ...}": {
		"prefix": "HUD_PRINTCENTER",
		"body" : [ "HUD_PRINTCENTER" ],
		"description" : "(4) Print to center of screen"
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_NONE, ...}": {
		"prefix": "HUD_EFFECT_NONE",
		"body" : [ "HUD_EFFECT_NONE" ],
		"description" : "(0) No effect."
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_RAMP_UP, ...}": {
		"prefix": "HUD_EFFECT_RAMP_UP",
		"body" : [ "HUD_EFFECT_RAMP_UP" ],
		"description" : "(1) Linear ramp up from color1 to color2."
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_RAMP_DOWN, ...}": {
		"prefix": "HUD_EFFECT_RAMP_DOWN",
		"body" : [ "HUD_EFFECT_RAMP_DOWN" ],
		"description" : "(2) Linear ramp down from color2 to color1."
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_TRIANGLE, ...}": {
		"prefix": "HUD_EFFECT_TRIANGLE",
		"body" : [ "HUD_EFFECT_TRIANGLE" ],
		"description" : "(3) Linear ramp up and ramp down from color1 through color2 back to color1."
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_COSINE_UP, ...}": {
		"prefix": "HUD_EFFECT_COSINE_UP",
		"body" : [ "HUD_EFFECT_COSINE_UP" ],
		"description" : "(4) Cosine ramp up from color1 to color2."
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_COSINE_DOWN, ...}": {
		"prefix": "HUD_EFFECT_COSINE_DOWN",
		"body" : [ "HUD_EFFECT_COSINE_DOWN" ],
		"description" : "(5) Cosine ramp down from color2 to color1."
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_COSINE, ...}": {
		"prefix": "HUD_EFFECT_COSINE",
		"body" : [ "HUD_EFFECT_COSINE" ],
		"description" : "(6) Cosine ramp up and ramp down from color1 through color2 back to color1."
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_TOGGLE, ...}": {
		"prefix": "HUD_EFFECT_TOGGLE",
		"body" : [ "HUD_EFFECT_TOGGLE" ],
		"description" : "(7) Toggle between color1 and color2."
	},
	"enum HUD_EFFECT {..., HUD_EFFECT_SINE_PULSE, ...}": {
		"prefix": "HUD_EFFECT_SINE_PULSE",
		"body" : [ "HUD_EFFECT_SINE_PULSE" ],
		"description" : "(8) Sine pulse from color1 through zero to color2."
	},
	"enum HUD_ELEM {..., HUD_ELEM_ABSOLUTE_X, ...}": {
		"prefix": "HUD_ELEM_ABSOLUTE_X",
		"body" : [ "HUD_ELEM_ABSOLUTE_X" ],
		"description" : "(1) X position in pixels."
	},
	"enum HUD_ELEM {..., HUD_ELEM_ABSOLUTE_Y, ...}": {
		"prefix": "HUD_ELEM_ABSOLUTE_Y",
		"body" : [ "HUD_ELEM_ABSOLUTE_Y" ],
		"description" : "(2) Y position in pixels."
	},
	"enum HUD_ELEM {..., HUD_ELEM_SCR_CENTER_X, ...}": {
		"prefix": "HUD_ELEM_SCR_CENTER_X",
		"body" : [ "HUD_ELEM_SCR_CENTER_X" ],
		"description" : "(4) X position relative to the center of the screen."
	},
	"enum HUD_ELEM {..., HUD_ELEM_SCR_CENTER_Y, ...}": {
		"prefix": "HUD_ELEM_SCR_CENTER_Y",
		"body" : [ "HUD_ELEM_SCR_CENTER_Y" ],
		"description" : "(8) Y position relative to the center of the screen."
	},
	"enum HUD_ELEM {..., HUD_ELEM_NO_BORDER, ...}": {
		"prefix": "HUD_ELEM_NO_BORDER",
		"body" : [ "HUD_ELEM_NO_BORDER" ],
		"description" : "(16) Ignore the client-side HUD border (hud_bordersize)."
	},
	"enum HUD_ELEM {..., HUD_ELEM_HIDDEN, ...}": {
		"prefix": "HUD_ELEM_HIDDEN",
		"body" : [ "HUD_ELEM_HIDDEN" ],
		"description" : "(32) Create a hidden element."
	},
	"enum HUD_ELEM {..., HUD_ELEM_EFFECT_ONCE, ...}": {
		"prefix": "HUD_ELEM_EFFECT_ONCE",
		"body" : [ "HUD_ELEM_EFFECT_ONCE" ],
		"description" : "(64) Play the effect only once."
	},
	"enum HUD_ELEM {..., HUD_ELEM_DEFAULT_ALPHA, ...}": {
		"prefix": "HUD_ELEM_DEFAULT_ALPHA",
		"body" : [ "HUD_ELEM_DEFAULT_ALPHA" ],
		"description" : "(128) Use the default client-side HUD alpha (hud_defaultalpha)."
	},
	"enum HUD_ELEM {..., HUD_ELEM_DYNAMIC_ALPHA, ...}": {
		"prefix": "HUD_ELEM_DYNAMIC_ALPHA",
		"body" : [ "HUD_ELEM_DYNAMIC_ALPHA" ],
		"description" : "(256) Use the default client-side HUD alpha and flash the element when updated."
	},
	"enum HUD_NUM {..., HUD_NUM_RIGHT_ALIGN, ...}": {
		"prefix": "HUD_NUM_RIGHT_ALIGN",
		"body" : [ "HUD_NUM_RIGHT_ALIGN" ],
		"description" : "(65536) Draw right aligned element."
	},
	"enum HUD_NUM {..., HUD_NUM_SEPARATOR, ...}": {
		"prefix": "HUD_NUM_SEPARATOR",
		"body" : [ "HUD_NUM_SEPARATOR" ],
		"description" : "(131072) Draw separator."
	},
	"enum HUD_NUM {..., HUD_NUM_DONT_DRAW_ZERO, ...}": {
		"prefix": "HUD_NUM_DONT_DRAW_ZERO",
		"body" : [ "HUD_NUM_DONT_DRAW_ZERO" ],
		"description" : "(262144) Hide the element if the value is zero."
	},
	"enum HUD_NUM {..., HUD_NUM_LEADING_ZEROS, ...}": {
		"prefix": "HUD_NUM_LEADING_ZEROS",
		"body" : [ "HUD_NUM_LEADING_ZEROS" ],
		"description" : "(524288) Draw leading zeros."
	},
	"enum HUD_NUM {..., HUD_NUM_NEGATIVE_NUMBERS, ...}": {
		"prefix": "HUD_NUM_NEGATIVE_NUMBERS",
		"body" : [ "HUD_NUM_NEGATIVE_NUMBERS" ],
		"description" : "(1048576) Allow negative values."
	},
	"enum HUD_NUM {..., HUD_NUM_PLUS_SIGN, ...}": {
		"prefix": "HUD_NUM_PLUS_SIGN",
		"body" : [ "HUD_NUM_PLUS_SIGN" ],
		"description" : "(2097152) Draw sign for positive values."
	},
	"enum HUD_SPR {..., HUD_SPR_OPAQUE, ...}": {
		"prefix": "HUD_SPR_OPAQUE",
		"body" : [ "HUD_SPR_OPAQUE" ],
		"description" : "(65536) Draw opaque sprite."
	},
	"enum HUD_SPR {..., HUD_SPR_MASKED, ...}": {
		"prefix": "HUD_SPR_MASKED",
		"body" : [ "HUD_SPR_MASKED" ],
		"description" : "(131072) Draw masked sprite."
	},
	"enum HUD_SPR {..., HUD_SPR_PLAY_ONCE, ...}": {
		"prefix": "HUD_SPR_PLAY_ONCE",
		"body" : [ "HUD_SPR_PLAY_ONCE" ],
		"description" : "(262144) Play the animation only once."
	},
	"enum HUD_SPR {..., HUD_SPR_HIDE_WHEN_STOPPED, ...}": {
		"prefix": "HUD_SPR_HIDE_WHEN_STOPPED",
		"body" : [ "HUD_SPR_HIDE_WHEN_STOPPED" ],
		"description" : "(524288) Hide the sprite when the animation stops."
	},
	"enum HUD_TIME {..., HUD_TIME_RIGHT_ALIGN, ...}": {
		"prefix": "HUD_TIME_RIGHT_ALIGN",
		"body" : [ "HUD_TIME_RIGHT_ALIGN" ],
		"description" : "(65536) Draw right aligned element."
	},
	"enum HUD_TIME {..., HUD_TIME_HOURS, ...}": {
		"prefix": "HUD_TIME_HOURS",
		"body" : [ "HUD_TIME_HOURS" ],
		"description" : "(131072) Draw hours."
	},
	"enum HUD_TIME {..., HUD_TIME_MINUTES, ...}": {
		"prefix": "HUD_TIME_MINUTES",
		"body" : [ "HUD_TIME_MINUTES" ],
		"description" : "(262144) Draw minutes."
	},
	"enum HUD_TIME {..., HUD_TIME_SECONDS, ...}": {
		"prefix": "HUD_TIME_SECONDS",
		"body" : [ "HUD_TIME_SECONDS" ],
		"description" : "(524288) Draw seconds."
	},
	"enum HUD_TIME {..., HUD_TIME_MILLISECONDS, ...}": {
		"prefix": "HUD_TIME_MILLISECONDS",
		"body" : [ "HUD_TIME_MILLISECONDS" ],
		"description" : "(1048576) Draw milliseconds."
	},
	"enum HUD_TIME {..., HUD_TIME_ZERO_HOURS, ...}": {
		"prefix": "HUD_TIME_ZERO_HOURS",
		"body" : [ "HUD_TIME_ZERO_HOURS" ],
		"description" : "(2097152) Draw hours even if the value is zero."
	},
	"enum HUD_TIME {..., HUD_TIME_FREEZE, ...}": {
		"prefix": "HUD_TIME_FREEZE",
		"body" : [ "HUD_TIME_FREEZE" ],
		"description" : "(4194304) Freeze the displayed value."
	},
	"enum HUD_TIME {..., HUD_TIME_COUNT_DOWN, ...}": {
		"prefix": "HUD_TIME_COUNT_DOWN",
		"body" : [ "HUD_TIME_COUNT_DOWN" ],
		"description" : "(8388608) Count down."
	},
	"void HUDNumDisplayParams::HUDNumDisplayParams()": {
		"prefix": "HUDNumDisplayParams",
		"body" : [ "HUDNumDisplayParams()" ],
		"description" : "Constructor"
	},
	"void HUDNumDisplayParams::HUDNumDisplayParams(const HUDNumDisplayParams& in other)": {
		"prefix": "HUDNumDisplayParams",
		"body" : [ "HUDNumDisplayParams( ${1:const HUDNumDisplayParams& in other} )" ],
		"description" : "Copy constructor"
	},
	"HUDNumDisplayParams& HUDNumDisplayParams::opAssign(const HUDNumDisplayParams& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const HUDNumDisplayParams& in other} )" ],
		"description" : "Assignment operator"
	},
	"uint8 HUDNumDisplayParams::channel": {
		"prefix": "channel",
		"body" : [ "channel" ],
		"description" : "Channel. Range: 0-15 (each module type has its own channel group)."
	},
	"int HUDNumDisplayParams::flags": {
		"prefix": "flags",
		"body" : [ "flags" ],
		"description" : "Flags. See HUD_ELEM, HUD_NUM (numeric display only) and HUD_TIME (time display only) enums."
	},
	"float HUDNumDisplayParams::value": {
		"prefix": "value",
		"body" : [ "value" ],
		"description" : "Value"
	},
	"uint8 HUDNumDisplayParams::defdigits": {
		"prefix": "defdigits",
		"body" : [ "defdigits" ],
		"description" : "Default number of digits (numeric display only)"
	},
	"uint8 HUDNumDisplayParams::maxdigits": {
		"prefix": "maxdigits",
		"body" : [ "maxdigits" ],
		"description" : "Maximum number of digits (numeric display only)"
	},
	"float HUDNumDisplayParams::x": {
		"prefix": "x",
		"body" : [ "x" ],
		"description" : "Horizontal position on the screen. <0, 1.0> = left to right. (-1.0, 0) = right to left. -1.0 = centered"
	},
	"float HUDNumDisplayParams::y": {
		"prefix": "y",
		"body" : [ "y" ],
		"description" : "Vertical position on the screen. <0, 1.0> = top to bottom. (-1.0, 0) = bottom to top. -1.0 = centered"
	},
	"RGBA HUDNumDisplayParams::color1": {
		"prefix": "color1",
		"body" : [ "color1" ],
		"description" : "Color 1"
	},
	"RGBA HUDNumDisplayParams::color2": {
		"prefix": "color2",
		"body" : [ "color2" ],
		"description" : "Color 2"
	},
	"float HUDNumDisplayParams::fadeinTime": {
		"prefix": "fadeinTime",
		"body" : [ "fadeinTime" ],
		"description" : "Fade in time"
	},
	"float HUDNumDisplayParams::fadeoutTime": {
		"prefix": "fadeoutTime",
		"body" : [ "fadeoutTime" ],
		"description" : "Fade out time"
	},
	"float HUDNumDisplayParams::holdTime": {
		"prefix": "holdTime",
		"body" : [ "holdTime" ],
		"description" : "Hold time"
	},
	"float HUDNumDisplayParams::fxTime": {
		"prefix": "fxTime",
		"body" : [ "fxTime" ],
		"description" : "Effect time"
	},
	"uint8 HUDNumDisplayParams::effect": {
		"prefix": "effect",
		"body" : [ "effect" ],
		"description" : "Effect. See HUD_EFFECT enum."
	},
	"string_t HUDNumDisplayParams::spritename": {
		"prefix": "spritename",
		"body" : [ "spritename" ],
		"description" : "Sprite name"
	},
	"uint8 HUDNumDisplayParams::left": {
		"prefix": "left",
		"body" : [ "left" ],
		"description" : "Sprite left offset. Range: 0-255"
	},
	"uint8 HUDNumDisplayParams::top": {
		"prefix": "top",
		"body" : [ "top" ],
		"description" : "Sprite top offset. Range: 0-255"
	},
	"int16 HUDNumDisplayParams::width": {
		"prefix": "width",
		"body" : [ "width" ],
		"description" : "Sprite width. Range: 0-512 (0: auto; use total width of the sprite)"
	},
	"int16 HUDNumDisplayParams::height": {
		"prefix": "height",
		"body" : [ "height" ],
		"description" : "Sprite height. Range: 0-512 (0: auto; use total height of the sprite)"
	},
	"void HUDSpriteParams::HUDSpriteParams()": {
		"prefix": "HUDSpriteParams",
		"body" : [ "HUDSpriteParams()" ],
		"description" : "Constructor"
	},
	"void HUDSpriteParams::HUDSpriteParams(const HUDSpriteParams& in other)": {
		"prefix": "HUDSpriteParams",
		"body" : [ "HUDSpriteParams( ${1:const HUDSpriteParams& in other} )" ],
		"description" : "Copy constructor"
	},
	"HUDSpriteParams& HUDSpriteParams::opAssign(const HUDSpriteParams& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const HUDSpriteParams& in other} )" ],
		"description" : "Assignment operator"
	},
	"uint8 HUDSpriteParams::channel": {
		"prefix": "channel",
		"body" : [ "channel" ],
		"description" : "Channel. Range: 0-15 (each module type has its own channel group)."
	},
	"int HUDSpriteParams::flags": {
		"prefix": "flags",
		"body" : [ "flags" ],
		"description" : "Flags. See HUD_ELEM and HUD_SPR enums."
	},
	"string_t HUDSpriteParams::spritename": {
		"prefix": "spritename",
		"body" : [ "spritename" ],
		"description" : "Sprite name"
	},
	"uint8 HUDSpriteParams::left": {
		"prefix": "left",
		"body" : [ "left" ],
		"description" : "Sprite left offset. Range: 0-255"
	},
	"uint8 HUDSpriteParams::top": {
		"prefix": "top",
		"body" : [ "top" ],
		"description" : "Sprite top offset. Range: 0-255"
	},
	"int16 HUDSpriteParams::width": {
		"prefix": "width",
		"body" : [ "width" ],
		"description" : "Sprite width. Range: 0-512 (0: auto; use total width of the sprite)"
	},
	"int16 HUDSpriteParams::height": {
		"prefix": "height",
		"body" : [ "height" ],
		"description" : "Sprite height. Range: 0-512 (0: auto; use total height of the sprite)"
	},
	"float HUDSpriteParams::x": {
		"prefix": "x",
		"body" : [ "x" ],
		"description" : "Horizontal position on the screen. <0, 1.0> = left to right. (-1.0, 0) = right to left. -1.0 = centered"
	},
	"float HUDSpriteParams::y": {
		"prefix": "y",
		"body" : [ "y" ],
		"description" : "Vertical position on the screen. <0, 1.0> = top to bottom. (-1.0, 0) = bottom to top. -1.0 = centered"
	},
	"RGBA HUDSpriteParams::color1": {
		"prefix": "color1",
		"body" : [ "color1" ],
		"description" : "Color 1"
	},
	"RGBA HUDSpriteParams::color2": {
		"prefix": "color2",
		"body" : [ "color2" ],
		"description" : "Color 2"
	},
	"uint8 HUDSpriteParams::frame": {
		"prefix": "frame",
		"body" : [ "frame" ],
		"description" : "Frame"
	},
	"uint8 HUDSpriteParams::numframes": {
		"prefix": "numframes",
		"body" : [ "numframes" ],
		"description" : "Number of frames"
	},
	"float HUDSpriteParams::framerate": {
		"prefix": "framerate",
		"body" : [ "framerate" ],
		"description" : "Framerate"
	},
	"float HUDSpriteParams::fadeinTime": {
		"prefix": "fadeinTime",
		"body" : [ "fadeinTime" ],
		"description" : "Fade in time"
	},
	"float HUDSpriteParams::fadeoutTime": {
		"prefix": "fadeoutTime",
		"body" : [ "fadeoutTime" ],
		"description" : "Fade out time"
	},
	"float HUDSpriteParams::holdTime": {
		"prefix": "holdTime",
		"body" : [ "holdTime" ],
		"description" : "Hold time"
	},
	"float HUDSpriteParams::fxTime": {
		"prefix": "fxTime",
		"body" : [ "fxTime" ],
		"description" : "Effect time"
	},
	"uint8 HUDSpriteParams::effect": {
		"prefix": "effect",
		"body" : [ "effect" ],
		"description" : "Effect. See HUD_EFFECT enum."
	},
	"void HUDTextParams::HUDTextParams()": {
		"prefix": "HUDTextParams",
		"body" : [ "HUDTextParams()" ],
		"description" : "Constructor"
	},
	"void HUDTextParams::HUDTextParams(const HUDTextParams& in other)": {
		"prefix": "HUDTextParams",
		"body" : [ "HUDTextParams( ${1:const HUDTextParams& in other} )" ],
		"description" : "Copy constructor"
	},
	"HUDTextParams& HUDTextParams::opAssign(const HUDTextParams& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const HUDTextParams& in other} )" ],
		"description" : "Assignment operator"
	},
	"float HUDTextParams::x": {
		"prefix": "x",
		"body" : [ "x" ],
		"description" : "Horizontal position on the screen. <0, 1.0> = left to right. (-1.0, 0) = right to left. -1.0 = centered"
	},
	"float HUDTextParams::y": {
		"prefix": "y",
		"body" : [ "y" ],
		"description" : "Vertical position on the screen. <0, 1.0> = top to bottom. (-1.0, 0) = bottom to top. -1.0 = centered"
	},
	"int HUDTextParams::effect": {
		"prefix": "effect",
		"body" : [ "effect" ],
		"description" : "Effects. 0 : Fade In/Out. 1 : Credits. 2 : Scan Out"
	},
	"uint8 HUDTextParams::r1": {
		"prefix": "r1",
		"body" : [ "r1" ],
		"description" : "Red 1"
	},
	"uint8 HUDTextParams::g1": {
		"prefix": "g1",
		"body" : [ "g1" ],
		"description" : "Green 1"
	},
	"uint8 HUDTextParams::b1": {
		"prefix": "b1",
		"body" : [ "b1" ],
		"description" : "Blue 1"
	},
	"uint8 HUDTextParams::a1": {
		"prefix": "a1",
		"body" : [ "a1" ],
		"description" : "Alpha 1"
	},
	"uint8 HUDTextParams::r2": {
		"prefix": "r2",
		"body" : [ "r2" ],
		"description" : "Red 2"
	},
	"uint8 HUDTextParams::g2": {
		"prefix": "g2",
		"body" : [ "g2" ],
		"description" : "Green 2"
	},
	"uint8 HUDTextParams::b2": {
		"prefix": "b2",
		"body" : [ "b2" ],
		"description" : "Blue 2"
	},
	"uint8 HUDTextParams::a2": {
		"prefix": "a2",
		"body" : [ "a2" ],
		"description" : "Alpha 2"
	},
	"float HUDTextParams::fadeinTime": {
		"prefix": "fadeinTime",
		"body" : [ "fadeinTime" ],
		"description" : "Fade in time"
	},
	"float HUDTextParams::fadeoutTime": {
		"prefix": "fadeoutTime",
		"body" : [ "fadeoutTime" ],
		"description" : "Fade out time"
	},
	"float HUDTextParams::holdTime": {
		"prefix": "holdTime",
		"body" : [ "holdTime" ],
		"description" : "Hold time"
	},
	"float HUDTextParams::fxTime": {
		"prefix": "fxTime",
		"body" : [ "fxTime" ],
		"description" : "Effect time (scan effect only)"
	},
	"int HUDTextParams::channel": {
		"prefix": "channel",
		"body" : [ "channel" ],
		"description" : "Channel. 1-4."
	},
	"enum HULL_NUMBER {..., point_hull, ...}": {
		"prefix": "point_hull",
		"body" : [ "point_hull" ],
		"description" : "(0) Point hull. No size."
	},
	"enum HULL_NUMBER {..., human_hull, ...}": {
		"prefix": "human_hull",
		"body" : [ "human_hull" ],
		"description" : "(1) Human sized hull."
	},
	"enum HULL_NUMBER {..., large_hull, ...}": {
		"prefix": "large_hull",
		"body" : [ "large_hull" ],
		"description" : "(2) Large hull."
	},
	"enum HULL_NUMBER {..., head_hull, ...}": {
		"prefix": "head_hull",
		"body" : [ "head_hull" ],
		"description" : "(3) Head hull."
	},
	"enum IGNORE_GLASS {..., ignore_glass, ...}": {
		"prefix": "ignore_glass",
		"body" : [ "ignore_glass" ],
		"description" : "(1) Ignore glass"
	},
	"enum IGNORE_GLASS {..., dont_ignore_glass, ...}": {
		"prefix": "dont_ignore_glass",
		"body" : [ "dont_ignore_glass" ],
		"description" : "(0) Don't ignore glass"
	},
	"enum IGNORE_MONSTERS {..., ignore_monsters, ...}": {
		"prefix": "ignore_monsters",
		"body" : [ "ignore_monsters" ],
		"description" : "(1) Ignore monsters"
	},
	"enum IGNORE_MONSTERS {..., dont_ignore_monsters, ...}": {
		"prefix": "dont_ignore_monsters",
		"body" : [ "dont_ignore_monsters" ],
		"description" : "(0) Don't ignore monsters"
	},
	"enum IGNORE_MONSTERS {..., missile, ...}": {
		"prefix": "missile",
		"body" : [ "missile" ],
		"description" : "(2) Object doing the trace is a missile"
	},
	"enum In_Buttons {..., IN_ATTACK, ...}": {
		"prefix": "IN_ATTACK",
		"body" : [ "IN_ATTACK" ],
		"description" : "(1) Primary attack"
	},
	"enum In_Buttons {..., IN_JUMP, ...}": {
		"prefix": "IN_JUMP",
		"body" : [ "IN_JUMP" ],
		"description" : "(2) Jump"
	},
	"enum In_Buttons {..., IN_DUCK, ...}": {
		"prefix": "IN_DUCK",
		"body" : [ "IN_DUCK" ],
		"description" : "(4) Duck"
	},
	"enum In_Buttons {..., IN_FORWARD, ...}": {
		"prefix": "IN_FORWARD",
		"body" : [ "IN_FORWARD" ],
		"description" : "(8) Move forward"
	},
	"enum In_Buttons {..., IN_BACK, ...}": {
		"prefix": "IN_BACK",
		"body" : [ "IN_BACK" ],
		"description" : "(16) Move backward"
	},
	"enum In_Buttons {..., IN_USE, ...}": {
		"prefix": "IN_USE",
		"body" : [ "IN_USE" ],
		"description" : "(32) Use"
	},
	"enum In_Buttons {..., IN_CANCEL, ...}": {
		"prefix": "IN_CANCEL",
		"body" : [ "IN_CANCEL" ],
		"description" : "(64)"
	},
	"enum In_Buttons {..., IN_LEFT, ...}": {
		"prefix": "IN_LEFT",
		"body" : [ "IN_LEFT" ],
		"description" : "(128)"
	},
	"enum In_Buttons {..., IN_RIGHT, ...}": {
		"prefix": "IN_RIGHT",
		"body" : [ "IN_RIGHT" ],
		"description" : "(256)"
	},
	"enum In_Buttons {..., IN_MOVELEFT, ...}": {
		"prefix": "IN_MOVELEFT",
		"body" : [ "IN_MOVELEFT" ],
		"description" : "(512) Move left"
	},
	"enum In_Buttons {..., IN_MOVERIGHT, ...}": {
		"prefix": "IN_MOVERIGHT",
		"body" : [ "IN_MOVERIGHT" ],
		"description" : "(1024) Move right"
	},
	"enum In_Buttons {..., IN_ATTACK2, ...}": {
		"prefix": "IN_ATTACK2",
		"body" : [ "IN_ATTACK2" ],
		"description" : "(2048) Secondary attack"
	},
	"enum In_Buttons {..., IN_RUN, ...}": {
		"prefix": "IN_RUN",
		"body" : [ "IN_RUN" ],
		"description" : "(4096) Run/Walk"
	},
	"enum In_Buttons {..., IN_RELOAD, ...}": {
		"prefix": "IN_RELOAD",
		"body" : [ "IN_RELOAD" ],
		"description" : "(8192) Reload"
	},
	"enum In_Buttons {..., IN_ALT1, ...}": {
		"prefix": "IN_ALT1",
		"body" : [ "IN_ALT1" ],
		"description" : "(16384) Tertiary attack"
	},
	"enum In_Buttons {..., IN_SCORE, ...}": {
		"prefix": "IN_SCORE",
		"body" : [ "IN_SCORE" ],
		"description" : "(32768) Used by client.dll for when scoreboard is held down"
	},
	"EHandle InventoryList::hItem": {
		"prefix": "hItem",
		"body" : [ "hItem" ],
		"description" : "Item"
	},
	"InventoryList@ InventoryList::pNext": {
		"prefix": "pNext",
		"body" : [ "pNext" ],
		"description" : "Next item in the list"
	},
	"bool InventoryRules::CanUseTrigger(CBaseEntity@ pActivator, bool fContinueByDefault = false)": {
		"prefix": "CanUseTrigger",
		"body" : [ "CanUseTrigger( ${1:CBaseEntity@ pActivator}, ${2:bool fContinueByDefault = false} )" ],
		"description" : "Returns whether the owning trigger can be triggered by the given activator."
	},
	"EHandle InventoryRules::m_hEntity": {
		"prefix": "m_hEntity",
		"body" : [ "m_hEntity" ],
		"description" : "Owning entity"
	},
	"string_t InventoryRules::m_szRequiresItemName": {
		"prefix": "m_szRequiresItemName",
		"body" : [ "m_szRequiresItemName" ],
		"description" : "Inventory: Require these item(s)"
	},
	"string_t InventoryRules::m_szRequiresItemGroup": {
		"prefix": "m_szRequiresItemGroup",
		"body" : [ "m_szRequiresItemGroup" ],
		"description" : "Inventory: Require an item from these group(s)"
	},
	"int InventoryRules::m_iRequiresItemGroupNum": {
		"prefix": "m_iRequiresItemGroupNum",
		"body" : [ "m_iRequiresItemGroupNum" ],
		"description" : "Inventory: Number of item(s) from the required group(s) required (0 = all)"
	},
	"string_t InventoryRules::m_szCantHaveItemName": {
		"prefix": "m_szCantHaveItemName",
		"body" : [ "m_szCantHaveItemName" ],
		"description" : "Inventory: Must not have these item(s)"
	},
	"string_t InventoryRules::m_szCantHaveItemGroup": {
		"prefix": "m_szCantHaveItemGroup",
		"body" : [ "m_szCantHaveItemGroup" ],
		"description" : "Inventory: Must not have an item in these group(s)"
	},
	"int InventoryRules::m_iCantHaveItemGroupNum": {
		"prefix": "m_iCantHaveItemGroupNum",
		"body" : [ "m_iCantHaveItemGroupNum" ],
		"description" : "Inventory: Number of item(s) from the can't have group(s) (0 = all)"
	},
	"bool InventoryRules::m_fIgnoreUseTriggers": {
		"prefix": "m_fIgnoreUseTriggers",
		"body" : [ "m_fIgnoreUseTriggers" ],
		"description" : "On pass: Ignore item's on use triggers?"
	},
	"string_t InventoryRules::m_szDropItemNameOnUse": {
		"prefix": "m_szDropItemNameOnUse",
		"body" : [ "m_szDropItemNameOnUse" ],
		"description" : "On pass: Drop item(s)"
	},
	"string_t InventoryRules::m_szDropItemGroupOnUse": {
		"prefix": "m_szDropItemGroupOnUse",
		"body" : [ "m_szDropItemGroupOnUse" ],
		"description" : "On pass: Drop item(s) in these group(s)"
	},
	"bool InventoryRules::m_fIgnoreDropTriggers": {
		"prefix": "m_fIgnoreDropTriggers",
		"body" : [ "m_fIgnoreDropTriggers" ],
		"description" : "On pass: Ignore item's on drop triggers?"
	},
	"string_t InventoryRules::m_szReturnItemNameOnUse": {
		"prefix": "m_szReturnItemNameOnUse",
		"body" : [ "m_szReturnItemNameOnUse" ],
		"description" : "On pass: Return item(s)"
	},
	"string_t InventoryRules::m_szReturnItemGroupOnUse": {
		"prefix": "m_szReturnItemGroupOnUse",
		"body" : [ "m_szReturnItemGroupOnUse" ],
		"description" : "On pass: Return item(s) in these group(s)"
	},
	"bool InventoryRules::m_fIgnoreReturnTriggers": {
		"prefix": "m_fIgnoreReturnTriggers",
		"body" : [ "m_fIgnoreReturnTriggers" ],
		"description" : "On pass: Ignore item's on return triggers?"
	},
	"string_t InventoryRules::m_szDestroyItemNameOnUse": {
		"prefix": "m_szDestroyItemNameOnUse",
		"body" : [ "m_szDestroyItemNameOnUse" ],
		"description" : "On pass: Destroy item(s)"
	},
	"string_t InventoryRules::m_szDestroyItemGroupOnUse": {
		"prefix": "m_szDestroyItemGroupOnUse",
		"body" : [ "m_szDestroyItemGroupOnUse" ],
		"description" : "On pass: Destroy item(s) in these group(s)"
	},
	"bool InventoryRules::m_fIgnoreDestroyTriggers": {
		"prefix": "m_fIgnoreDestroyTriggers",
		"body" : [ "m_fIgnoreDestroyTriggers" ],
		"description" : "On pass: Ignore item's on destroy triggers?"
	},
	"string_t InventoryRules::m_szTargetOnFail": {
		"prefix": "m_szTargetOnFail",
		"body" : [ "m_szTargetOnFail" ],
		"description" : "Target: Inventory rules failed"
	},
	"Function@ Reflection::IReflectionGroup::FindGlobalFunction(const string& in szName, bool fSearchByDecl = false)": {
		"prefix": "FindGlobalFunction",
		"body" : [ "FindGlobalFunction( ${1:const string& in szName}, ${2:bool fSearchByDecl = false} )" ],
		"description" : "Finds a global function. Searches by name by default, searches by declaration if fSearchByDecl is set to true."
	},
	"uint Reflection::IReflectionGroup::GetGlobalFunctionCount() const": {
		"prefix": "GetGlobalFunctionCount",
		"body" : [ "GetGlobalFunctionCount()" ],
		"description" : "Gets the number of global functions."
	},
	"Function@ Reflection::IReflectionGroup::GetGlobalFunctionByIndex(uint uiIndex)": {
		"prefix": "GetGlobalFunctionByIndex",
		"body" : [ "GetGlobalFunctionByIndex( ${1:uint uiIndex} )" ],
		"description" : "Gets the global function at the given index."
	},
	"ObjectType@ Reflection::IReflectionGroup::FindObjectType(const string& in szName, bool fSearchByDecl = false)": {
		"prefix": "FindObjectType",
		"body" : [ "FindObjectType( ${1:const string& in szName}, ${2:bool fSearchByDecl = false} )" ],
		"description" : "Finds an object type. Searches by name by default, searches by declaration if fSearchByDecl is set to true."
	},
	"uint Reflection::IReflectionGroup::GetObjectTypeCount() const": {
		"prefix": "GetObjectTypeCount",
		"body" : [ "GetObjectTypeCount()" ],
		"description" : "Gets the number of object types."
	},
	"ObjectType@ Reflection::IReflectionGroup::GetObjectTypeByIndex(uint uiIndex) const": {
		"prefix": "GetObjectTypeByIndex",
		"body" : [ "GetObjectTypeByIndex( ${1:uint uiIndex} )" ],
		"description" : "Gets the object type at the given index."
	},
	"enum ItemFlag {..., ITEM_FLAG_SELECTONEMPTY, ...}": {
		"prefix": "ITEM_FLAG_SELECTONEMPTY",
		"body" : [ "ITEM_FLAG_SELECTONEMPTY" ],
		"description" : "(1) Allow this weapon to be selected if it has no ammo."
	},
	"enum ItemFlag {..., ITEM_FLAG_NOAUTORELOAD, ...}": {
		"prefix": "ITEM_FLAG_NOAUTORELOAD",
		"body" : [ "ITEM_FLAG_NOAUTORELOAD" ],
		"description" : "(2) Don't automatically reload this weapon."
	},
	"enum ItemFlag {..., ITEM_FLAG_NOAUTOSWITCHEMPTY, ...}": {
		"prefix": "ITEM_FLAG_NOAUTOSWITCHEMPTY",
		"body" : [ "ITEM_FLAG_NOAUTOSWITCHEMPTY" ],
		"description" : "(4) Don't automatically switch away from this weapon when it runs out of ammo."
	},
	"enum ItemFlag {..., ITEM_FLAG_LIMITINWORLD, ...}": {
		"prefix": "ITEM_FLAG_LIMITINWORLD",
		"body" : [ "ITEM_FLAG_LIMITINWORLD" ],
		"description" : "(8) If there are few entity slots left, this item will not respawn."
	},
	"enum ItemFlag {..., ITEM_FLAG_EXHAUSTIBLE, ...}": {
		"prefix": "ITEM_FLAG_EXHAUSTIBLE",
		"body" : [ "ITEM_FLAG_EXHAUSTIBLE" ],
		"description" : "(16) A player can totally exhaust their ammo supply and lose this weapon."
	},
	"enum ItemFlag {..., ITEM_FLAG_DUALWIELD, ...}": {
		"prefix": "ITEM_FLAG_DUALWIELD",
		"body" : [ "ITEM_FLAG_DUALWIELD" ],
		"description" : "(32) Use a special HUD ammo configuration unique to a dual wielded weapons."
	},
	"enum ItemFlag {..., ITEM_FLAG_IGNOREWEAPONSTAY, ...}": {
		"prefix": "ITEM_FLAG_IGNOREWEAPONSTAY",
		"body" : [ "ITEM_FLAG_IGNOREWEAPONSTAY" ],
		"description" : "(64) Ignore weaponstay settings when respawning this weapon."
	},
	"enum ItemFlag {..., ITEM_FLAG_ESSENTIAL, ...}": {
		"prefix": "ITEM_FLAG_ESSENTIAL",
		"body" : [ "ITEM_FLAG_ESSENTIAL" ],
		"description" : "(128) This weapon should not be dropped straight away when the player dies, only if he is gibbed or if he respawned."
	},
	"void ItemInfo::ItemInfo()": {
		"prefix": "ItemInfo",
		"body" : [ "ItemInfo()" ],
		"description" : "Constructor"
	},
	"void ItemInfo::ItemInfo(const ItemInfo& in other)": {
		"prefix": "ItemInfo",
		"body" : [ "ItemInfo( ${1:const ItemInfo& in other} )" ],
		"description" : "Constructor"
	},
	"ItemInfo& ItemInfo::opAssign(const ItemInfo& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const ItemInfo& in other} )" ],
		"description" : "Assignment operator"
	},
	"string ItemInfo::szName() const": {
		"prefix": "szName",
		"body" : [ "szName()" ],
		"description" : "Gets the name of this weapon."
	},
	"string ItemInfo::szAmmo1() const": {
		"prefix": "szAmmo1",
		"body" : [ "szAmmo1()" ],
		"description" : "Gets the primary ammo name of this weapon."
	},
	"string ItemInfo::szAmmo2() const": {
		"prefix": "szAmmo2",
		"body" : [ "szAmmo2()" ],
		"description" : "Gets the secondary ammo name of this weapon."
	},
	"int ItemInfo::iId": {
		"prefix": "iId",
		"body" : [ "iId" ],
		"description" : "Item id."
	},
	"int ItemInfo::iSlot": {
		"prefix": "iSlot",
		"body" : [ "iSlot" ],
		"description" : "Item HUD slot."
	},
	"int ItemInfo::iPosition": {
		"prefix": "iPosition",
		"body" : [ "iPosition" ],
		"description" : "Item HUD slot position."
	},
	"int ItemInfo::iFlags": {
		"prefix": "iFlags",
		"body" : [ "iFlags" ],
		"description" : "Item flags."
	},
	"int ItemInfo::iWeight": {
		"prefix": "iWeight",
		"body" : [ "iWeight" ],
		"description" : "Item weight. This value used to determine this weapon's importance in autoselection."
	},
	"int ItemInfo::iMaxAmmo1": {
		"prefix": "iMaxAmmo1",
		"body" : [ "iMaxAmmo1" ],
		"description" : "Item primary max ammo. -1 if this weapon does not use primary ammo."
	},
	"int ItemInfo::iAmmo1Drop": {
		"prefix": "iAmmo1Drop",
		"body" : [ "iAmmo1Drop" ],
		"description" : "Amount of dropped primary ammo."
	},
	"int ItemInfo::iMaxAmmo2": {
		"prefix": "iMaxAmmo2",
		"body" : [ "iMaxAmmo2" ],
		"description" : "Item secondary max ammo. -1 if this weapon does not use secondary ammo."
	},
	"int ItemInfo::iAmmo2Drop": {
		"prefix": "iAmmo2Drop",
		"body" : [ "iAmmo2Drop" ],
		"description" : "Amount of dropped secondary ammo."
	},
	"int ItemInfo::iMaxClip": {
		"prefix": "iMaxClip",
		"body" : [ "iMaxClip" ],
		"description" : "Item primary ammo max clip contents."
	},
	"ItemMapping@ ItemMapping::ItemMapping(const string& in szFrom, const string& in szTo)": {
		"prefix": "ItemMapping",
		"body" : [ "ItemMapping( ${1:const string& in szFrom}, ${2:const string& in szTo} )" ],
		"description" : "Constructor"
	},
	"const string& ItemMapping::get_From() const": {
		"prefix": "get_From",
		"body" : [ "get_From()" ],
		"description" : "Gets the From item name"
	},
	"const string& ItemMapping::get_To() const": {
		"prefix": "get_To",
		"body" : [ "get_To()" ],
		"description" : "Gets the To item name"
	},
	"enum KeyCode {..., KEY_0, ...}": {
		"prefix": "KEY_0",
		"body" : [ "KEY_0" ],
		"description" : "(0) 0"
	},
	"enum KeyCode {..., KEY_1, ...}": {
		"prefix": "KEY_1",
		"body" : [ "KEY_1" ],
		"description" : "(1) 1"
	},
	"enum KeyCode {..., KEY_2, ...}": {
		"prefix": "KEY_2",
		"body" : [ "KEY_2" ],
		"description" : "(2) 2"
	},
	"enum KeyCode {..., KEY_3, ...}": {
		"prefix": "KEY_3",
		"body" : [ "KEY_3" ],
		"description" : "(3) 3"
	},
	"enum KeyCode {..., KEY_4, ...}": {
		"prefix": "KEY_4",
		"body" : [ "KEY_4" ],
		"description" : "(4) 4"
	},
	"enum KeyCode {..., KEY_5, ...}": {
		"prefix": "KEY_5",
		"body" : [ "KEY_5" ],
		"description" : "(5) 5"
	},
	"enum KeyCode {..., KEY_6, ...}": {
		"prefix": "KEY_6",
		"body" : [ "KEY_6" ],
		"description" : "(6) 6"
	},
	"enum KeyCode {..., KEY_7, ...}": {
		"prefix": "KEY_7",
		"body" : [ "KEY_7" ],
		"description" : "(7) 7"
	},
	"enum KeyCode {..., KEY_8, ...}": {
		"prefix": "KEY_8",
		"body" : [ "KEY_8" ],
		"description" : "(8) 8"
	},
	"enum KeyCode {..., KEY_9, ...}": {
		"prefix": "KEY_9",
		"body" : [ "KEY_9" ],
		"description" : "(9) 9"
	},
	"enum KeyCode {..., KEY_A, ...}": {
		"prefix": "KEY_A",
		"body" : [ "KEY_A" ],
		"description" : "(10) A"
	},
	"enum KeyCode {..., KEY_B, ...}": {
		"prefix": "KEY_B",
		"body" : [ "KEY_B" ],
		"description" : "(11) B"
	},
	"enum KeyCode {..., KEY_C, ...}": {
		"prefix": "KEY_C",
		"body" : [ "KEY_C" ],
		"description" : "(12) C"
	},
	"enum KeyCode {..., KEY_D, ...}": {
		"prefix": "KEY_D",
		"body" : [ "KEY_D" ],
		"description" : "(13) D"
	},
	"enum KeyCode {..., KEY_E, ...}": {
		"prefix": "KEY_E",
		"body" : [ "KEY_E" ],
		"description" : "(14) E"
	},
	"enum KeyCode {..., KEY_F, ...}": {
		"prefix": "KEY_F",
		"body" : [ "KEY_F" ],
		"description" : "(15) F"
	},
	"enum KeyCode {..., KEY_G, ...}": {
		"prefix": "KEY_G",
		"body" : [ "KEY_G" ],
		"description" : "(16) G"
	},
	"enum KeyCode {..., KEY_H, ...}": {
		"prefix": "KEY_H",
		"body" : [ "KEY_H" ],
		"description" : "(17) H"
	},
	"enum KeyCode {..., KEY_I, ...}": {
		"prefix": "KEY_I",
		"body" : [ "KEY_I" ],
		"description" : "(18) I"
	},
	"enum KeyCode {..., KEY_J, ...}": {
		"prefix": "KEY_J",
		"body" : [ "KEY_J" ],
		"description" : "(19) J"
	},
	"enum KeyCode {..., KEY_K, ...}": {
		"prefix": "KEY_K",
		"body" : [ "KEY_K" ],
		"description" : "(20) K"
	},
	"enum KeyCode {..., KEY_L, ...}": {
		"prefix": "KEY_L",
		"body" : [ "KEY_L" ],
		"description" : "(21) L"
	},
	"enum KeyCode {..., KEY_M, ...}": {
		"prefix": "KEY_M",
		"body" : [ "KEY_M" ],
		"description" : "(22) M"
	},
	"enum KeyCode {..., KEY_N, ...}": {
		"prefix": "KEY_N",
		"body" : [ "KEY_N" ],
		"description" : "(23) N"
	},
	"enum KeyCode {..., KEY_O, ...}": {
		"prefix": "KEY_O",
		"body" : [ "KEY_O" ],
		"description" : "(24) O"
	},
	"enum KeyCode {..., KEY_P, ...}": {
		"prefix": "KEY_P",
		"body" : [ "KEY_P" ],
		"description" : "(25) P"
	},
	"enum KeyCode {..., KEY_Q, ...}": {
		"prefix": "KEY_Q",
		"body" : [ "KEY_Q" ],
		"description" : "(26) Q"
	},
	"enum KeyCode {..., KEY_R, ...}": {
		"prefix": "KEY_R",
		"body" : [ "KEY_R" ],
		"description" : "(27) R"
	},
	"enum KeyCode {..., KEY_S, ...}": {
		"prefix": "KEY_S",
		"body" : [ "KEY_S" ],
		"description" : "(28) S"
	},
	"enum KeyCode {..., KEY_T, ...}": {
		"prefix": "KEY_T",
		"body" : [ "KEY_T" ],
		"description" : "(29) T"
	},
	"enum KeyCode {..., KEY_U, ...}": {
		"prefix": "KEY_U",
		"body" : [ "KEY_U" ],
		"description" : "(30) U"
	},
	"enum KeyCode {..., KEY_V, ...}": {
		"prefix": "KEY_V",
		"body" : [ "KEY_V" ],
		"description" : "(31) V"
	},
	"enum KeyCode {..., KEY_W, ...}": {
		"prefix": "KEY_W",
		"body" : [ "KEY_W" ],
		"description" : "(32) W"
	},
	"enum KeyCode {..., KEY_X, ...}": {
		"prefix": "KEY_X",
		"body" : [ "KEY_X" ],
		"description" : "(33) X"
	},
	"enum KeyCode {..., KEY_Y, ...}": {
		"prefix": "KEY_Y",
		"body" : [ "KEY_Y" ],
		"description" : "(34) Y"
	},
	"enum KeyCode {..., KEY_Z, ...}": {
		"prefix": "KEY_Z",
		"body" : [ "KEY_Z" ],
		"description" : "(35) Z"
	},
	"enum KeyCode {..., KEY_PAD_0, ...}": {
		"prefix": "KEY_PAD_0",
		"body" : [ "KEY_PAD_0" ],
		"description" : "(36) Numpad 0"
	},
	"enum KeyCode {..., KEY_PAD_1, ...}": {
		"prefix": "KEY_PAD_1",
		"body" : [ "KEY_PAD_1" ],
		"description" : "(37) Numpad 1"
	},
	"enum KeyCode {..., KEY_PAD_2, ...}": {
		"prefix": "KEY_PAD_2",
		"body" : [ "KEY_PAD_2" ],
		"description" : "(38) Numpad 2"
	},
	"enum KeyCode {..., KEY_PAD_3, ...}": {
		"prefix": "KEY_PAD_3",
		"body" : [ "KEY_PAD_3" ],
		"description" : "(39) Numpad 3"
	},
	"enum KeyCode {..., KEY_PAD_4, ...}": {
		"prefix": "KEY_PAD_4",
		"body" : [ "KEY_PAD_4" ],
		"description" : "(40) Numpad 4"
	},
	"enum KeyCode {..., KEY_PAD_5, ...}": {
		"prefix": "KEY_PAD_5",
		"body" : [ "KEY_PAD_5" ],
		"description" : "(41) Numpad 5"
	},
	"enum KeyCode {..., KEY_PAD_6, ...}": {
		"prefix": "KEY_PAD_6",
		"body" : [ "KEY_PAD_6" ],
		"description" : "(42) Numpad 6"
	},
	"enum KeyCode {..., KEY_PAD_7, ...}": {
		"prefix": "KEY_PAD_7",
		"body" : [ "KEY_PAD_7" ],
		"description" : "(43) Numpad 7"
	},
	"enum KeyCode {..., KEY_PAD_8, ...}": {
		"prefix": "KEY_PAD_8",
		"body" : [ "KEY_PAD_8" ],
		"description" : "(44) Numpad 8"
	},
	"enum KeyCode {..., KEY_PAD_9, ...}": {
		"prefix": "KEY_PAD_9",
		"body" : [ "KEY_PAD_9" ],
		"description" : "(45) Numpad 9"
	},
	"enum KeyCode {..., KEY_PAD_DIVIDE, ...}": {
		"prefix": "KEY_PAD_DIVIDE",
		"body" : [ "KEY_PAD_DIVIDE" ],
		"description" : "(46) Numpad DIVIDE"
	},
	"enum KeyCode {..., KEY_PAD_MULTIPLY, ...}": {
		"prefix": "KEY_PAD_MULTIPLY",
		"body" : [ "KEY_PAD_MULTIPLY" ],
		"description" : "(47) Numpad MULTIPLY"
	},
	"enum KeyCode {..., KEY_PAD_MINUS, ...}": {
		"prefix": "KEY_PAD_MINUS",
		"body" : [ "KEY_PAD_MINUS" ],
		"description" : "(48) Numpad MINUS"
	},
	"enum KeyCode {..., KEY_PAD_PLUS, ...}": {
		"prefix": "KEY_PAD_PLUS",
		"body" : [ "KEY_PAD_PLUS" ],
		"description" : "(49) Numpad PLUS"
	},
	"enum KeyCode {..., KEY_PAD_ENTER, ...}": {
		"prefix": "KEY_PAD_ENTER",
		"body" : [ "KEY_PAD_ENTER" ],
		"description" : "(50) Numpad ENTER"
	},
	"enum KeyCode {..., KEY_PAD_DECIMAL, ...}": {
		"prefix": "KEY_PAD_DECIMAL",
		"body" : [ "KEY_PAD_DECIMAL" ],
		"description" : "(51) Numpad DECIMAL"
	},
	"enum KeyCode {..., KEY_LBRACKET, ...}": {
		"prefix": "KEY_LBRACKET",
		"body" : [ "KEY_LBRACKET" ],
		"description" : "(52) LBRACKET"
	},
	"enum KeyCode {..., KEY_RBRACKET, ...}": {
		"prefix": "KEY_RBRACKET",
		"body" : [ "KEY_RBRACKET" ],
		"description" : "(53) RBRACKET"
	},
	"enum KeyCode {..., KEY_SEMICOLON, ...}": {
		"prefix": "KEY_SEMICOLON",
		"body" : [ "KEY_SEMICOLON" ],
		"description" : "(54) SEMICOLON"
	},
	"enum KeyCode {..., KEY_APOSTROPHE, ...}": {
		"prefix": "KEY_APOSTROPHE",
		"body" : [ "KEY_APOSTROPHE" ],
		"description" : "(55) APOSTROPHE"
	},
	"enum KeyCode {..., KEY_BACKQUOTE, ...}": {
		"prefix": "KEY_BACKQUOTE",
		"body" : [ "KEY_BACKQUOTE" ],
		"description" : "(56) BACKQUOTE"
	},
	"enum KeyCode {..., KEY_COMMA, ...}": {
		"prefix": "KEY_COMMA",
		"body" : [ "KEY_COMMA" ],
		"description" : "(57) COMMA"
	},
	"enum KeyCode {..., KEY_PERIOD, ...}": {
		"prefix": "KEY_PERIOD",
		"body" : [ "KEY_PERIOD" ],
		"description" : "(58) PERIOD"
	},
	"enum KeyCode {..., KEY_SLASH, ...}": {
		"prefix": "KEY_SLASH",
		"body" : [ "KEY_SLASH" ],
		"description" : "(59) SLASH"
	},
	"enum KeyCode {..., KEY_BACKSLASH, ...}": {
		"prefix": "KEY_BACKSLASH",
		"body" : [ "KEY_BACKSLASH" ],
		"description" : "(60) BACKSLASH"
	},
	"enum KeyCode {..., KEY_MINUS, ...}": {
		"prefix": "KEY_MINUS",
		"body" : [ "KEY_MINUS" ],
		"description" : "(61) MINUS"
	},
	"enum KeyCode {..., KEY_EQUAL, ...}": {
		"prefix": "KEY_EQUAL",
		"body" : [ "KEY_EQUAL" ],
		"description" : "(62) EQUAL"
	},
	"enum KeyCode {..., KEY_ENTER, ...}": {
		"prefix": "KEY_ENTER",
		"body" : [ "KEY_ENTER" ],
		"description" : "(63) ENTER"
	},
	"enum KeyCode {..., KEY_SPACE, ...}": {
		"prefix": "KEY_SPACE",
		"body" : [ "KEY_SPACE" ],
		"description" : "(64) SPACE"
	},
	"enum KeyCode {..., KEY_BACKSPACE, ...}": {
		"prefix": "KEY_BACKSPACE",
		"body" : [ "KEY_BACKSPACE" ],
		"description" : "(65) BACKSPACE"
	},
	"enum KeyCode {..., KEY_TAB, ...}": {
		"prefix": "KEY_TAB",
		"body" : [ "KEY_TAB" ],
		"description" : "(66) TAB"
	},
	"enum KeyCode {..., KEY_CAPSLOCK, ...}": {
		"prefix": "KEY_CAPSLOCK",
		"body" : [ "KEY_CAPSLOCK" ],
		"description" : "(67) CAPSLOCK"
	},
	"enum KeyCode {..., KEY_NUMLOCK, ...}": {
		"prefix": "KEY_NUMLOCK",
		"body" : [ "KEY_NUMLOCK" ],
		"description" : "(68) NUMLOCK"
	},
	"enum KeyCode {..., KEY_ESCAPE, ...}": {
		"prefix": "KEY_ESCAPE",
		"body" : [ "KEY_ESCAPE" ],
		"description" : "(69) ESCAPE"
	},
	"enum KeyCode {..., KEY_SCROLLLOCK, ...}": {
		"prefix": "KEY_SCROLLLOCK",
		"body" : [ "KEY_SCROLLLOCK" ],
		"description" : "(70) SCROLLLOCK"
	},
	"enum KeyCode {..., KEY_INSERT, ...}": {
		"prefix": "KEY_INSERT",
		"body" : [ "KEY_INSERT" ],
		"description" : "(71) INSERT"
	},
	"enum KeyCode {..., KEY_DELETE, ...}": {
		"prefix": "KEY_DELETE",
		"body" : [ "KEY_DELETE" ],
		"description" : "(72) DELETE"
	},
	"enum KeyCode {..., KEY_HOME, ...}": {
		"prefix": "KEY_HOME",
		"body" : [ "KEY_HOME" ],
		"description" : "(73) HOME"
	},
	"enum KeyCode {..., KEY_END, ...}": {
		"prefix": "KEY_END",
		"body" : [ "KEY_END" ],
		"description" : "(74) END"
	},
	"enum KeyCode {..., KEY_PAGEUP, ...}": {
		"prefix": "KEY_PAGEUP",
		"body" : [ "KEY_PAGEUP" ],
		"description" : "(75) PAGEUP"
	},
	"enum KeyCode {..., KEY_PAGEDOWN, ...}": {
		"prefix": "KEY_PAGEDOWN",
		"body" : [ "KEY_PAGEDOWN" ],
		"description" : "(76) PAGEDOWN"
	},
	"enum KeyCode {..., KEY_BREAK, ...}": {
		"prefix": "KEY_BREAK",
		"body" : [ "KEY_BREAK" ],
		"description" : "(77) BREAK"
	},
	"enum KeyCode {..., KEY_LSHIFT, ...}": {
		"prefix": "KEY_LSHIFT",
		"body" : [ "KEY_LSHIFT" ],
		"description" : "(78) LSHIFT"
	},
	"enum KeyCode {..., KEY_RSHIFT, ...}": {
		"prefix": "KEY_RSHIFT",
		"body" : [ "KEY_RSHIFT" ],
		"description" : "(79) RSHIFT"
	},
	"enum KeyCode {..., KEY_LALT, ...}": {
		"prefix": "KEY_LALT",
		"body" : [ "KEY_LALT" ],
		"description" : "(80) LALT"
	},
	"enum KeyCode {..., KEY_RALT, ...}": {
		"prefix": "KEY_RALT",
		"body" : [ "KEY_RALT" ],
		"description" : "(81) RALT"
	},
	"enum KeyCode {..., KEY_LCONTROL, ...}": {
		"prefix": "KEY_LCONTROL",
		"body" : [ "KEY_LCONTROL" ],
		"description" : "(82) LCONTROL"
	},
	"enum KeyCode {..., KEY_RCONTROL, ...}": {
		"prefix": "KEY_RCONTROL",
		"body" : [ "KEY_RCONTROL" ],
		"description" : "(83) RCONTROL"
	},
	"enum KeyCode {..., KEY_LWIN, ...}": {
		"prefix": "KEY_LWIN",
		"body" : [ "KEY_LWIN" ],
		"description" : "(84) LWIN"
	},
	"enum KeyCode {..., KEY_RWIN, ...}": {
		"prefix": "KEY_RWIN",
		"body" : [ "KEY_RWIN" ],
		"description" : "(85) RWIN"
	},
	"enum KeyCode {..., KEY_APP, ...}": {
		"prefix": "KEY_APP",
		"body" : [ "KEY_APP" ],
		"description" : "(86) APP"
	},
	"enum KeyCode {..., KEY_UP, ...}": {
		"prefix": "KEY_UP",
		"body" : [ "KEY_UP" ],
		"description" : "(87) UP"
	},
	"enum KeyCode {..., KEY_LEFT, ...}": {
		"prefix": "KEY_LEFT",
		"body" : [ "KEY_LEFT" ],
		"description" : "(88) LEFT"
	},
	"enum KeyCode {..., KEY_DOWN, ...}": {
		"prefix": "KEY_DOWN",
		"body" : [ "KEY_DOWN" ],
		"description" : "(89) DOWN"
	},
	"enum KeyCode {..., KEY_RIGHT, ...}": {
		"prefix": "KEY_RIGHT",
		"body" : [ "KEY_RIGHT" ],
		"description" : "(90) RIGHT"
	},
	"enum KeyCode {..., KEY_F1, ...}": {
		"prefix": "KEY_F1",
		"body" : [ "KEY_F1" ],
		"description" : "(91) F1"
	},
	"enum KeyCode {..., KEY_F2, ...}": {
		"prefix": "KEY_F2",
		"body" : [ "KEY_F2" ],
		"description" : "(92) F2"
	},
	"enum KeyCode {..., KEY_F3, ...}": {
		"prefix": "KEY_F3",
		"body" : [ "KEY_F3" ],
		"description" : "(93) F3"
	},
	"enum KeyCode {..., KEY_F4, ...}": {
		"prefix": "KEY_F4",
		"body" : [ "KEY_F4" ],
		"description" : "(94) F4"
	},
	"enum KeyCode {..., KEY_F5, ...}": {
		"prefix": "KEY_F5",
		"body" : [ "KEY_F5" ],
		"description" : "(95) F5"
	},
	"enum KeyCode {..., KEY_F6, ...}": {
		"prefix": "KEY_F6",
		"body" : [ "KEY_F6" ],
		"description" : "(96) F6"
	},
	"enum KeyCode {..., KEY_F7, ...}": {
		"prefix": "KEY_F7",
		"body" : [ "KEY_F7" ],
		"description" : "(97) F7"
	},
	"enum KeyCode {..., KEY_F8, ...}": {
		"prefix": "KEY_F8",
		"body" : [ "KEY_F8" ],
		"description" : "(98) F8"
	},
	"enum KeyCode {..., KEY_F9, ...}": {
		"prefix": "KEY_F9",
		"body" : [ "KEY_F9" ],
		"description" : "(99) F9"
	},
	"enum KeyCode {..., KEY_F10, ...}": {
		"prefix": "KEY_F10",
		"body" : [ "KEY_F10" ],
		"description" : "(100) F10"
	},
	"enum KeyCode {..., KEY_F11, ...}": {
		"prefix": "KEY_F11",
		"body" : [ "KEY_F11" ],
		"description" : "(101) F11"
	},
	"enum KeyCode {..., KEY_F12, ...}": {
		"prefix": "KEY_F12",
		"body" : [ "KEY_F12" ],
		"description" : "(102) F12"
	},
	"enum KeyCode {..., KEY_LAST, ...}": {
		"prefix": "KEY_LAST",
		"body" : [ "KEY_LAST" ],
		"description" : "(103) The last number in the range of key codes."
	},
	"edict_t@ KeyValueBuffer::GetClient() const": {
		"prefix": "GetClient",
		"body" : [ "GetClient()" ],
		"description" : "Gets the client that this buffer belongs to."
	},
	"string KeyValueBuffer::GetValue(const string& in szKey) const": {
		"prefix": "GetValue",
		"body" : [ "GetValue( ${1:const string& in szKey} )" ],
		"description" : "Gets a key value"
	},
	"void KeyValueBuffer::SetValue(const string& in szKey, const string& in szValue) const": {
		"prefix": "SetValue",
		"body" : [ "SetValue( ${1:const string& in szKey}, ${2:const string& in szValue} )" ],
		"description" : "Sets a key value."
	},
	"void KeyValueBuffer::RemoveValue(const string& in szKey)": {
		"prefix": "RemoveValue",
		"body" : [ "RemoveValue( ${1:const string& in szKey} )" ],
		"description" : "Removes a key value. If this is a physics key buffer, this will set the key to an empty string instead."
	},
	"enum Regex::MatchFlagType {..., match_default, ...}": {
		"prefix": "match_default",
		"body" : [ "Regex::match_default" ],
		"description" : "(0)"
	},
	"enum Regex::MatchFlagType {..., match_not_bol, ...}": {
		"prefix": "match_not_bol",
		"body" : [ "Regex::match_not_bol" ],
		"description" : "(1)"
	},
	"enum Regex::MatchFlagType {..., match_not_eol, ...}": {
		"prefix": "match_not_eol",
		"body" : [ "Regex::match_not_eol" ],
		"description" : "(2)"
	},
	"enum Regex::MatchFlagType {..., match_not_bow, ...}": {
		"prefix": "match_not_bow",
		"body" : [ "Regex::match_not_bow" ],
		"description" : "(4)"
	},
	"enum Regex::MatchFlagType {..., match_not_eow, ...}": {
		"prefix": "match_not_eow",
		"body" : [ "Regex::match_not_eow" ],
		"description" : "(8)"
	},
	"enum Regex::MatchFlagType {..., match_any, ...}": {
		"prefix": "match_any",
		"body" : [ "Regex::match_any" ],
		"description" : "(16)"
	},
	"enum Regex::MatchFlagType {..., match_not_null, ...}": {
		"prefix": "match_not_null",
		"body" : [ "Regex::match_not_null" ],
		"description" : "(32)"
	},
	"enum Regex::MatchFlagType {..., match_continuous, ...}": {
		"prefix": "match_continuous",
		"body" : [ "Regex::match_continuous" ],
		"description" : "(64)"
	},
	"enum Regex::MatchFlagType {..., match_prev_avail, ...}": {
		"prefix": "match_prev_avail",
		"body" : [ "Regex::match_prev_avail" ],
		"description" : "(256)"
	},
	"enum Regex::MatchFlagType {..., format_default, ...}": {
		"prefix": "format_default",
		"body" : [ "Regex::format_default" ],
		"description" : "(0)"
	},
	"enum Regex::MatchFlagType {..., format_sed, ...}": {
		"prefix": "format_sed",
		"body" : [ "Regex::format_sed" ],
		"description" : "(1024)"
	},
	"enum Regex::MatchFlagType {..., format_no_copy, ...}": {
		"prefix": "format_no_copy",
		"body" : [ "Regex::format_no_copy" ],
		"description" : "(2048)"
	},
	"enum Regex::MatchFlagType {..., format_first_only, ...}": {
		"prefix": "format_first_only",
		"body" : [ "Regex::format_first_only" ],
		"description" : "(4096)"
	},
	"MatchResults@ Regex::MatchResults::MatchResults()": {
		"prefix": "MatchResults",
		"body" : [ "MatchResults()" ],
		"description" : "Constructor"
	},
	"MatchResults@ Regex::MatchResults::MatchResults(const MatchResults@ pOther)": {
		"prefix": "MatchResults",
		"body" : [ "MatchResults( ${1:const MatchResults@ pOther} )" ],
		"description" : "Copy constructor"
	},
	"bool Regex::MatchResults::IsEmpty() const": {
		"prefix": "IsEmpty",
		"body" : [ "IsEmpty()" ],
		"description" : "Returns whether this match results object is empty or not"
	},
	"size_t Regex::MatchResults::GetSize() const": {
		"prefix": "GetSize",
		"body" : [ "GetSize()" ],
		"description" : "Returns the number of matches"
	},
	"size_t Regex::MatchResults::GetMaxSize() const": {
		"prefix": "GetMaxSize",
		"body" : [ "GetMaxSize()" ],
		"description" : "Returns the maximum size"
	},
	"SubMatch Regex::MatchResults::opIndex(size_t uiIndex) const": {
		"prefix": "opIndex",
		"body" : [ "opIndex( ${1:size_t uiIndex} )" ],
		"description" : "Returns the sub match object at the given index"
	},
	"SubMatch Regex::MatchResults::GetPrefix() const": {
		"prefix": "GetPrefix",
		"body" : [ "GetPrefix()" ],
		"description" : "Gets the prefix submatch"
	},
	"SubMatch Regex::MatchResults::GetSuffix() const": {
		"prefix": "GetSuffix",
		"body" : [ "GetSuffix()" ],
		"description" : "Gets the suffix submatch"
	},
	"int Regex::MatchResults::GetLength(size_t uiIndex = 0) const": {
		"prefix": "GetLength",
		"body" : [ "GetLength( ${1:size_t uiIndex = 0} )" ],
		"description" : "Gets the length of the given submatch"
	},
	"int Regex::MatchResults::GetPosition(size_t uiIndex = 0) const": {
		"prefix": "GetPosition",
		"body" : [ "GetPosition( ${1:size_t uiIndex = 0} )" ],
		"description" : "Gets the position of the given submatch"
	},
	"string Regex::MatchResults::GetString(size_t uiIndex = 0) const": {
		"prefix": "GetString",
		"body" : [ "GetString( ${1:size_t uiIndex = 0} )" ],
		"description" : "Gets the given submatch as a string"
	},
	"string Regex::MatchResults::Format(const string& in szFormat, MatchFlagType flags = Regex::match_default) const": {
		"prefix": "Format",
		"body" : [ "Format( ${1:const string& in szFormat}, ${2:MatchFlagType flags = Regex::match_default} )" ],
		"description" : "Gets the length of the given submatch"
	},
	"void Regex::MatchResults::Swap(MatchResults@ other)": {
		"prefix": "Swap",
		"body" : [ "Swap( ${1:MatchResults@ other} )" ],
		"description" : "Swaps these match results with the given results."
	},
	"enum Materials {..., matGlass, ...}": {
		"prefix": "matGlass",
		"body" : [ "matGlass" ],
		"description" : "(0)"
	},
	"enum Materials {..., matWood, ...}": {
		"prefix": "matWood",
		"body" : [ "matWood" ],
		"description" : "(1)"
	},
	"enum Materials {..., matMetal, ...}": {
		"prefix": "matMetal",
		"body" : [ "matMetal" ],
		"description" : "(2)"
	},
	"enum Materials {..., matFlesh, ...}": {
		"prefix": "matFlesh",
		"body" : [ "matFlesh" ],
		"description" : "(3)"
	},
	"enum Materials {..., matCinderBlock, ...}": {
		"prefix": "matCinderBlock",
		"body" : [ "matCinderBlock" ],
		"description" : "(4)"
	},
	"enum Materials {..., matCeilingTile, ...}": {
		"prefix": "matCeilingTile",
		"body" : [ "matCeilingTile" ],
		"description" : "(5)"
	},
	"enum Materials {..., matComputer, ...}": {
		"prefix": "matComputer",
		"body" : [ "matComputer" ],
		"description" : "(6)"
	},
	"enum Materials {..., matUnbreakableGlass, ...}": {
		"prefix": "matUnbreakableGlass",
		"body" : [ "matUnbreakableGlass" ],
		"description" : "(7)"
	},
	"enum Materials {..., matRocks, ...}": {
		"prefix": "matRocks",
		"body" : [ "matRocks" ],
		"description" : "(8)"
	},
	"enum Materials {..., matNone, ...}": {
		"prefix": "matNone",
		"body" : [ "matNone" ],
		"description" : "(9)"
	},
	"enum Materials {..., matLastMaterial, ...}": {
		"prefix": "matLastMaterial",
		"body" : [ "matLastMaterial" ],
		"description" : "(10)"
	},
	"Callable@ Reflection::Method::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Implicitly casts to base type."
	},
	"string Reflection::Method::GetNamespace() const": {
		"prefix": "GetNamespace",
		"body" : [ "GetNamespace()" ],
		"description" : "Gets this instance's namespace."
	},
	"string Reflection::Method::GetName() const": {
		"prefix": "GetName",
		"body" : [ "GetName()" ],
		"description" : "Gets this instance's name."
	},
	"bool Reflection::Method::Equals(const Callable@ pCallable) const": {
		"prefix": "Equals",
		"body" : [ "Equals( ${1:const Callable@ pCallable} )" ],
		"description" : "Returns whether the given callable type is identical to this one."
	},
	"bool Reflection::Method::IsCompatible(const Callable@ pCallable) const": {
		"prefix": "IsCompatible",
		"body" : [ "IsCompatible( ${1:const Callable@ pCallable} )" ],
		"description" : "Returns whether the given object type is compatible with this one."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, Arguments@ pArguments)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:Arguments@ pArguments} )" ],
		"description" : "Calls this method. pArguments must be valid."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject} )" ],
		"description" : "Calls this method."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:?& in} )" ],
		"description" : "Calls this method."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:?& in}, ${3:?& in} )" ],
		"description" : "Calls this method."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:?& in}, ${3:?& in}, ${4:?& in} )" ],
		"description" : "Calls this method."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in} )" ],
		"description" : "Calls this method."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in} )" ],
		"description" : "Calls this method."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in} )" ],
		"description" : "Calls this method."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in} )" ],
		"description" : "Calls this method."
	},
	"ReturnValue@ Reflection::Method::Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)": {
		"prefix": "Call",
		"body" : [ "Call( ${1:?& in thisObject}, ${2:?& in}, ${3:?& in}, ${4:?& in}, ${5:?& in}, ${6:?& in}, ${7:?& in}, ${8:?& in}, ${9:?& in} )" ],
		"description" : "Calls this method."
	},
	"enum MonsterCondition {..., bits_COND_NO_AMMO_LOADED, ...}": {
		"prefix": "bits_COND_NO_AMMO_LOADED",
		"body" : [ "bits_COND_NO_AMMO_LOADED" ],
		"description" : "(1) weapon needs to be reloaded!"
	},
	"enum MonsterCondition {..., bits_COND_SEE_HATE, ...}": {
		"prefix": "bits_COND_SEE_HATE",
		"body" : [ "bits_COND_SEE_HATE" ],
		"description" : "(2) see something that you hate"
	},
	"enum MonsterCondition {..., bits_COND_SEE_FEAR, ...}": {
		"prefix": "bits_COND_SEE_FEAR",
		"body" : [ "bits_COND_SEE_FEAR" ],
		"description" : "(4) see something that you are afraid of"
	},
	"enum MonsterCondition {..., bits_COND_SEE_DISLIKE, ...}": {
		"prefix": "bits_COND_SEE_DISLIKE",
		"body" : [ "bits_COND_SEE_DISLIKE" ],
		"description" : "(8) see something that you dislike"
	},
	"enum MonsterCondition {..., bits_COND_SEE_ENEMY, ...}": {
		"prefix": "bits_COND_SEE_ENEMY",
		"body" : [ "bits_COND_SEE_ENEMY" ],
		"description" : "(16) target entity is in full view."
	},
	"enum MonsterCondition {..., bits_COND_ENEMY_OCCLUDED, ...}": {
		"prefix": "bits_COND_ENEMY_OCCLUDED",
		"body" : [ "bits_COND_ENEMY_OCCLUDED" ],
		"description" : "(32) target entity occluded by the world"
	},
	"enum MonsterCondition {..., bits_COND_SMELL_FOOD, ...}": {
		"prefix": "bits_COND_SMELL_FOOD",
		"body" : [ "bits_COND_SMELL_FOOD" ],
		"description" : "(64)"
	},
	"enum MonsterCondition {..., bits_COND_ENEMY_TOOFAR, ...}": {
		"prefix": "bits_COND_ENEMY_TOOFAR",
		"body" : [ "bits_COND_ENEMY_TOOFAR" ],
		"description" : "(128)"
	},
	"enum MonsterCondition {..., bits_COND_LIGHT_DAMAGE, ...}": {
		"prefix": "bits_COND_LIGHT_DAMAGE",
		"body" : [ "bits_COND_LIGHT_DAMAGE" ],
		"description" : "(256) hurt a little"
	},
	"enum MonsterCondition {..., bits_COND_HEAVY_DAMAGE, ...}": {
		"prefix": "bits_COND_HEAVY_DAMAGE",
		"body" : [ "bits_COND_HEAVY_DAMAGE" ],
		"description" : "(512) hurt a lot"
	},
	"enum MonsterCondition {..., bits_COND_CAN_RANGE_ATTACK1, ...}": {
		"prefix": "bits_COND_CAN_RANGE_ATTACK1",
		"body" : [ "bits_COND_CAN_RANGE_ATTACK1" ],
		"description" : "(1024)"
	},
	"enum MonsterCondition {..., bits_COND_CAN_MELEE_ATTACK1, ...}": {
		"prefix": "bits_COND_CAN_MELEE_ATTACK1",
		"body" : [ "bits_COND_CAN_MELEE_ATTACK1" ],
		"description" : "(2048)"
	},
	"enum MonsterCondition {..., bits_COND_CAN_RANGE_ATTACK2, ...}": {
		"prefix": "bits_COND_CAN_RANGE_ATTACK2",
		"body" : [ "bits_COND_CAN_RANGE_ATTACK2" ],
		"description" : "(4096)"
	},
	"enum MonsterCondition {..., bits_COND_CAN_MELEE_ATTACK2, ...}": {
		"prefix": "bits_COND_CAN_MELEE_ATTACK2",
		"body" : [ "bits_COND_CAN_MELEE_ATTACK2" ],
		"description" : "(8192)"
	},
	"enum MonsterCondition {..., bits_COND_PROVOKED, ...}": {
		"prefix": "bits_COND_PROVOKED",
		"body" : [ "bits_COND_PROVOKED" ],
		"description" : "(32768)"
	},
	"enum MonsterCondition {..., bits_COND_NEW_ENEMY, ...}": {
		"prefix": "bits_COND_NEW_ENEMY",
		"body" : [ "bits_COND_NEW_ENEMY" ],
		"description" : "(65536)"
	},
	"enum MonsterCondition {..., bits_COND_HEAR_SOUND, ...}": {
		"prefix": "bits_COND_HEAR_SOUND",
		"body" : [ "bits_COND_HEAR_SOUND" ],
		"description" : "(131072) there is an interesting sound"
	},
	"enum MonsterCondition {..., bits_COND_SMELL, ...}": {
		"prefix": "bits_COND_SMELL",
		"body" : [ "bits_COND_SMELL" ],
		"description" : "(262144) there is an interesting scent"
	},
	"enum MonsterCondition {..., bits_COND_ENEMY_FACING_ME, ...}": {
		"prefix": "bits_COND_ENEMY_FACING_ME",
		"body" : [ "bits_COND_ENEMY_FACING_ME" ],
		"description" : "(524288) enemy is facing me"
	},
	"enum MonsterCondition {..., bits_COND_ENEMY_DEAD, ...}": {
		"prefix": "bits_COND_ENEMY_DEAD",
		"body" : [ "bits_COND_ENEMY_DEAD" ],
		"description" : "(1048576) enemy was killed. If you get this in combat, try to find another enemy. If you get it in alert, victory dance."
	},
	"enum MonsterCondition {..., bits_COND_SEE_CLIENT, ...}": {
		"prefix": "bits_COND_SEE_CLIENT",
		"body" : [ "bits_COND_SEE_CLIENT" ],
		"description" : "(2097152) see a client"
	},
	"enum MonsterCondition {..., bits_COND_SEE_NEMESIS, ...}": {
		"prefix": "bits_COND_SEE_NEMESIS",
		"body" : [ "bits_COND_SEE_NEMESIS" ],
		"description" : "(4194304) see my nemesis"
	},
	"enum MonsterCondition {..., bits_COND_CAN_RANGE_ATTACK1_MOVING, ...}": {
		"prefix": "bits_COND_CAN_RANGE_ATTACK1_MOVING",
		"body" : [ "bits_COND_CAN_RANGE_ATTACK1_MOVING" ],
		"description" : "(8388608)"
	},
	"enum MonsterCondition {..., bits_COND_CAN_MELEE_ATTACK1_MOVING, ...}": {
		"prefix": "bits_COND_CAN_MELEE_ATTACK1_MOVING",
		"body" : [ "bits_COND_CAN_MELEE_ATTACK1_MOVING" ],
		"description" : "(16777216)"
	},
	"enum MonsterCondition {..., bits_COND_CAN_RANGE_ATTACK2_MOVING, ...}": {
		"prefix": "bits_COND_CAN_RANGE_ATTACK2_MOVING",
		"body" : [ "bits_COND_CAN_RANGE_ATTACK2_MOVING" ],
		"description" : "(33554432)"
	},
	"enum MonsterCondition {..., bits_COND_CAN_MELEE_ATTACK2_MOVING, ...}": {
		"prefix": "bits_COND_CAN_MELEE_ATTACK2_MOVING",
		"body" : [ "bits_COND_CAN_MELEE_ATTACK2_MOVING" ],
		"description" : "(67108864)"
	},
	"enum MonsterCondition {..., bits_COND_SPECIAL1, ...}": {
		"prefix": "bits_COND_SPECIAL1",
		"body" : [ "bits_COND_SPECIAL1" ],
		"description" : "(268435456) Defined by individual monster"
	},
	"enum MonsterCondition {..., bits_COND_SPECIAL2, ...}": {
		"prefix": "bits_COND_SPECIAL2",
		"body" : [ "bits_COND_SPECIAL2" ],
		"description" : "(536870912) Defined by individual monster"
	},
	"enum MonsterCondition {..., bits_COND_TASK_FAILED, ...}": {
		"prefix": "bits_COND_TASK_FAILED",
		"body" : [ "bits_COND_TASK_FAILED" ],
		"description" : "(1073741824)"
	},
	"enum MonsterCondition {..., bits_COND_SCHEDULE_DONE, ...}": {
		"prefix": "bits_COND_SCHEDULE_DONE",
		"body" : [ "bits_COND_SCHEDULE_DONE" ],
		"description" : "(-2147483648)"
	},
	"enum MonsterCondition {..., bits_COND_CAN_USE_TANK, ...}": {
		"prefix": "bits_COND_CAN_USE_TANK",
		"body" : [ "bits_COND_CAN_USE_TANK" ],
		"description" : "(16384) This monster can use a func_tank now"
	},
	"enum MonsterCondition {..., bits_COND_ALL_SPECIAL, ...}": {
		"prefix": "bits_COND_ALL_SPECIAL",
		"body" : [ "bits_COND_ALL_SPECIAL" ],
		"description" : "(805306368)"
	},
	"enum MonsterCondition {..., bits_COND_CAN_ATTACK, ...}": {
		"prefix": "bits_COND_CAN_ATTACK",
		"body" : [ "bits_COND_CAN_ATTACK" ],
		"description" : "(15360)"
	},
	"string MonsterEvent::options() const": {
		"prefix": "options",
		"body" : [ "options()" ],
		"description" : "Options. Usually a sound name."
	},
	"int MonsterEvent::event": {
		"prefix": "event",
		"body" : [ "event" ],
		"description" : "Event type. See MonsterEventType enum"
	},
	"enum MonsterEventType {..., EVENT_SPECIFIC, ...}": {
		"prefix": "EVENT_SPECIFIC",
		"body" : [ "EVENT_SPECIFIC" ],
		"description" : "(0)"
	},
	"enum MonsterEventType {..., EVENT_SCRIPTED, ...}": {
		"prefix": "EVENT_SCRIPTED",
		"body" : [ "EVENT_SCRIPTED" ],
		"description" : "(1000)"
	},
	"enum MonsterEventType {..., EVENT_SHARED, ...}": {
		"prefix": "EVENT_SHARED",
		"body" : [ "EVENT_SHARED" ],
		"description" : "(2000)"
	},
	"enum MonsterEventType {..., EVENT_CLIENT, ...}": {
		"prefix": "EVENT_CLIENT",
		"body" : [ "EVENT_CLIENT" ],
		"description" : "(5000)"
	},
	"enum MonsterEventType {..., MONSTER_EVENT_BODYDROP_LIGHT, ...}": {
		"prefix": "MONSTER_EVENT_BODYDROP_LIGHT",
		"body" : [ "MONSTER_EVENT_BODYDROP_LIGHT" ],
		"description" : "(2001)"
	},
	"enum MonsterEventType {..., MONSTER_EVENT_BODYDROP_HEAVY, ...}": {
		"prefix": "MONSTER_EVENT_BODYDROP_HEAVY",
		"body" : [ "MONSTER_EVENT_BODYDROP_HEAVY" ],
		"description" : "(2002)"
	},
	"enum MonsterEventType {..., MONSTER_EVENT_FOOTSTEP, ...}": {
		"prefix": "MONSTER_EVENT_FOOTSTEP",
		"body" : [ "MONSTER_EVENT_FOOTSTEP" ],
		"description" : "(2003)"
	},
	"enum MonsterEventType {..., MONSTER_EVENT_SWISHSOUND, ...}": {
		"prefix": "MONSTER_EVENT_SWISHSOUND",
		"body" : [ "MONSTER_EVENT_SWISHSOUND" ],
		"description" : "(2010)"
	},
	"enum MonsterMemory {..., MEMORY_CLEAR, ...}": {
		"prefix": "MEMORY_CLEAR",
		"body" : [ "MEMORY_CLEAR" ],
		"description" : "(0) No memory."
	},
	"enum MonsterMemory {..., bits_MEMORY_PROVOKED, ...}": {
		"prefix": "bits_MEMORY_PROVOKED",
		"body" : [ "bits_MEMORY_PROVOKED" ],
		"description" : "(1) right now only used for houndeyes."
	},
	"enum MonsterMemory {..., bits_MEMORY_INCOVER, ...}": {
		"prefix": "bits_MEMORY_INCOVER",
		"body" : [ "bits_MEMORY_INCOVER" ],
		"description" : "(2) monster knows it is in a covered position."
	},
	"enum MonsterMemory {..., bits_MEMORY_SUSPICIOUS, ...}": {
		"prefix": "bits_MEMORY_SUSPICIOUS",
		"body" : [ "bits_MEMORY_SUSPICIOUS" ],
		"description" : "(4) Ally is suspicious of the player, and will move to provoked more easily"
	},
	"enum MonsterMemory {..., bits_MEMORY_PATH_FINISHED, ...}": {
		"prefix": "bits_MEMORY_PATH_FINISHED",
		"body" : [ "bits_MEMORY_PATH_FINISHED" ],
		"description" : "(8) Finished monster path (just used by big momma for now)"
	},
	"enum MonsterMemory {..., bits_MEMORY_ON_PATH, ...}": {
		"prefix": "bits_MEMORY_ON_PATH",
		"body" : [ "bits_MEMORY_ON_PATH" ],
		"description" : "(16) Moving on a path"
	},
	"enum MonsterMemory {..., bits_MEMORY_MOVE_FAILED, ...}": {
		"prefix": "bits_MEMORY_MOVE_FAILED",
		"body" : [ "bits_MEMORY_MOVE_FAILED" ],
		"description" : "(32) Movement has already failed"
	},
	"enum MonsterMemory {..., bits_MEMORY_FLINCHED, ...}": {
		"prefix": "bits_MEMORY_FLINCHED",
		"body" : [ "bits_MEMORY_FLINCHED" ],
		"description" : "(64) Has already flinched"
	},
	"enum MonsterMemory {..., bits_MEMORY_KILLED, ...}": {
		"prefix": "bits_MEMORY_KILLED",
		"body" : [ "bits_MEMORY_KILLED" ],
		"description" : "(128) HACKHACK -- remember that I've already called my Killed()"
	},
	"enum MonsterMemory {..., bits_MEMORY_MOVE_RADIUS_ONLY, ...}": {
		"prefix": "bits_MEMORY_MOVE_RADIUS_ONLY",
		"body" : [ "bits_MEMORY_MOVE_RADIUS_ONLY" ],
		"description" : "(256) Can only get there within radius"
	},
	"enum MonsterMemory {..., bits_MEMORY_CUSTOM4, ...}": {
		"prefix": "bits_MEMORY_CUSTOM4",
		"body" : [ "bits_MEMORY_CUSTOM4" ],
		"description" : "(268435456) Monster-specific memory"
	},
	"enum MonsterMemory {..., bits_MEMORY_CUSTOM3, ...}": {
		"prefix": "bits_MEMORY_CUSTOM3",
		"body" : [ "bits_MEMORY_CUSTOM3" ],
		"description" : "(536870912) Monster-specific memory"
	},
	"enum MonsterMemory {..., bits_MEMORY_CUSTOM2, ...}": {
		"prefix": "bits_MEMORY_CUSTOM2",
		"body" : [ "bits_MEMORY_CUSTOM2" ],
		"description" : "(1073741824) Monster-specific memory"
	},
	"enum MonsterMemory {..., bits_MEMORY_CUSTOM1, ...}": {
		"prefix": "bits_MEMORY_CUSTOM1",
		"body" : [ "bits_MEMORY_CUSTOM1" ],
		"description" : "(-2147483648) Monster-specific memory"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_NONE, ...}": {
		"prefix": "MONSTERSTATE_NONE",
		"body" : [ "MONSTERSTATE_NONE" ],
		"description" : "(0)"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_IDLE, ...}": {
		"prefix": "MONSTERSTATE_IDLE",
		"body" : [ "MONSTERSTATE_IDLE" ],
		"description" : "(1)"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_COMBAT, ...}": {
		"prefix": "MONSTERSTATE_COMBAT",
		"body" : [ "MONSTERSTATE_COMBAT" ],
		"description" : "(2)"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_ALERT, ...}": {
		"prefix": "MONSTERSTATE_ALERT",
		"body" : [ "MONSTERSTATE_ALERT" ],
		"description" : "(3)"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_HUNT, ...}": {
		"prefix": "MONSTERSTATE_HUNT",
		"body" : [ "MONSTERSTATE_HUNT" ],
		"description" : "(4)"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_PRONE, ...}": {
		"prefix": "MONSTERSTATE_PRONE",
		"body" : [ "MONSTERSTATE_PRONE" ],
		"description" : "(5)"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_SCRIPT, ...}": {
		"prefix": "MONSTERSTATE_SCRIPT",
		"body" : [ "MONSTERSTATE_SCRIPT" ],
		"description" : "(6)"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_PLAYDEAD, ...}": {
		"prefix": "MONSTERSTATE_PLAYDEAD",
		"body" : [ "MONSTERSTATE_PLAYDEAD" ],
		"description" : "(7)"
	},
	"enum MONSTERSTATE {..., MONSTERSTATE_DEAD, ...}": {
		"prefix": "MONSTERSTATE_DEAD",
		"body" : [ "MONSTERSTATE_DEAD" ],
		"description" : "(8)"
	},
	"enum MOVE_TYPE {..., MOVE_NORMAL, ...}": {
		"prefix": "MOVE_NORMAL",
		"body" : [ "MOVE_NORMAL" ],
		"description" : "(0) Normal move in the direction monster is facing."
	},
	"enum MOVE_TYPE {..., MOVE_STRAFE, ...}": {
		"prefix": "MOVE_STRAFE",
		"body" : [ "MOVE_STRAFE" ],
		"description" : "(1) Moves in direction specified, no matter which way monster is facing."
	},
	"enum MoveFlag {..., bits_MF_TO_TARGETENT, ...}": {
		"prefix": "bits_MF_TO_TARGETENT",
		"body" : [ "bits_MF_TO_TARGETENT" ],
		"description" : "(1) local move to targetent."
	},
	"enum MoveFlag {..., bits_MF_TO_ENEMY, ...}": {
		"prefix": "bits_MF_TO_ENEMY",
		"body" : [ "bits_MF_TO_ENEMY" ],
		"description" : "(2) local move to enemy"
	},
	"enum MoveFlag {..., bits_MF_TO_COVER, ...}": {
		"prefix": "bits_MF_TO_COVER",
		"body" : [ "bits_MF_TO_COVER" ],
		"description" : "(4) local move to a hiding place"
	},
	"enum MoveFlag {..., bits_MF_TO_DETOUR, ...}": {
		"prefix": "bits_MF_TO_DETOUR",
		"body" : [ "bits_MF_TO_DETOUR" ],
		"description" : "(8) local move to detour point."
	},
	"enum MoveFlag {..., bits_MF_TO_PATHCORNER, ...}": {
		"prefix": "bits_MF_TO_PATHCORNER",
		"body" : [ "bits_MF_TO_PATHCORNER" ],
		"description" : "(16) local move to a path corner"
	},
	"enum MoveFlag {..., bits_MF_TO_NODE, ...}": {
		"prefix": "bits_MF_TO_NODE",
		"body" : [ "bits_MF_TO_NODE" ],
		"description" : "(32) local move to a node"
	},
	"enum MoveFlag {..., bits_MF_TO_LOCATION, ...}": {
		"prefix": "bits_MF_TO_LOCATION",
		"body" : [ "bits_MF_TO_LOCATION" ],
		"description" : "(64) local move to an arbitrary point"
	},
	"enum MoveFlag {..., bits_MF_IS_GOAL, ...}": {
		"prefix": "bits_MF_IS_GOAL",
		"body" : [ "bits_MF_IS_GOAL" ],
		"description" : "(128) this waypoint is the goal of the whole move."
	},
	"enum MoveFlag {..., bits_MF_DONT_SIMPLIFY, ...}": {
		"prefix": "bits_MF_DONT_SIMPLIFY",
		"body" : [ "bits_MF_DONT_SIMPLIFY" ],
		"description" : "(256) Don't let the route code simplify this waypoint"
	},
	"enum MoveFlag {..., bits_MF_TO_JUMP, ...}": {
		"prefix": "bits_MF_TO_JUMP",
		"body" : [ "bits_MF_TO_JUMP" ],
		"description" : "(512) Jumping..."
	},
	"enum MoveFlag {..., bits_MF_TO_LADDER, ...}": {
		"prefix": "bits_MF_TO_LADDER",
		"body" : [ "bits_MF_TO_LADDER" ],
		"description" : "(1024) Ladder..."
	},
	"enum MoveFlag {..., bits_MF_TO_ELEVATOR, ...}": {
		"prefix": "bits_MF_TO_ELEVATOR",
		"body" : [ "bits_MF_TO_ELEVATOR" ],
		"description" : "(2048) Elevator"
	},
	"enum MOVETYPE {..., MOVETYPE_NONE_EXPLICIT, ...}": {
		"prefix": "MOVETYPE_NONE_EXPLICIT",
		"body" : [ "MOVETYPE_NONE_EXPLICIT" ],
		"description" : "(-1) never moves (forced by map)"
	},
	"enum MOVETYPE {..., MOVETYPE_NONE, ...}": {
		"prefix": "MOVETYPE_NONE",
		"body" : [ "MOVETYPE_NONE" ],
		"description" : "(0) never moves"
	},
	"enum MOVETYPE {..., MOVETYPE_WALK, ...}": {
		"prefix": "MOVETYPE_WALK",
		"body" : [ "MOVETYPE_WALK" ],
		"description" : "(3) Player only - moving on the ground"
	},
	"enum MOVETYPE {..., MOVETYPE_STEP, ...}": {
		"prefix": "MOVETYPE_STEP",
		"body" : [ "MOVETYPE_STEP" ],
		"description" : "(4) gravity, special edge handling -- monsters use this"
	},
	"enum MOVETYPE {..., MOVETYPE_FLY, ...}": {
		"prefix": "MOVETYPE_FLY",
		"body" : [ "MOVETYPE_FLY" ],
		"description" : "(5) No gravity, but still collides with stuff"
	},
	"enum MOVETYPE {..., MOVETYPE_TOSS, ...}": {
		"prefix": "MOVETYPE_TOSS",
		"body" : [ "MOVETYPE_TOSS" ],
		"description" : "(6) gravity/collisions"
	},
	"enum MOVETYPE {..., MOVETYPE_PUSH, ...}": {
		"prefix": "MOVETYPE_PUSH",
		"body" : [ "MOVETYPE_PUSH" ],
		"description" : "(7) no clip to world, push and crush"
	},
	"enum MOVETYPE {..., MOVETYPE_NOCLIP, ...}": {
		"prefix": "MOVETYPE_NOCLIP",
		"body" : [ "MOVETYPE_NOCLIP" ],
		"description" : "(8) No gravity, no collisions, still do velocity/avelocity"
	},
	"enum MOVETYPE {..., MOVETYPE_FLYMISSILE, ...}": {
		"prefix": "MOVETYPE_FLYMISSILE",
		"body" : [ "MOVETYPE_FLYMISSILE" ],
		"description" : "(9) extra size to monsters"
	},
	"enum MOVETYPE {..., MOVETYPE_BOUNCE, ...}": {
		"prefix": "MOVETYPE_BOUNCE",
		"body" : [ "MOVETYPE_BOUNCE" ],
		"description" : "(10) Just like Toss, but reflect velocity when contacting surfaces"
	},
	"enum MOVETYPE {..., MOVETYPE_BOUNCEMISSILE, ...}": {
		"prefix": "MOVETYPE_BOUNCEMISSILE",
		"body" : [ "MOVETYPE_BOUNCEMISSILE" ],
		"description" : "(11) bounce w/o gravity"
	},
	"enum MOVETYPE {..., MOVETYPE_FOLLOW, ...}": {
		"prefix": "MOVETYPE_FOLLOW",
		"body" : [ "MOVETYPE_FOLLOW" ],
		"description" : "(12) track movement of aiment"
	},
	"enum MOVETYPE {..., MOVETYPE_PUSHSTEP, ...}": {
		"prefix": "MOVETYPE_PUSHSTEP",
		"body" : [ "MOVETYPE_PUSHSTEP" ],
		"description" : "(13) BSP model that needs physics/world collisions (uses nearest hull for world collision)"
	},
	"NetworkMessage@ NetworkMessage::NetworkMessage(NetworkMessageDest dest, NetworkMessages::NetworkMessageType type, edict_t@ pEdict = null)": {
		"prefix": "NetworkMessage",
		"body" : [ "NetworkMessage( ${1:NetworkMessageDest dest}, ${2:NetworkMessages::NetworkMessageType type}, ${3:edict_t@ pEdict = null} )" ],
		"description" : "Constructor"
	},
	"NetworkMessage@ NetworkMessage::NetworkMessage(NetworkMessageDest dest, NetworkMessages::NetworkMessageType type, const Vector& in vecOrigin, edict_t@ pEdict = null)": {
		"prefix": "NetworkMessage",
		"body" : [ "NetworkMessage( ${1:NetworkMessageDest dest}, ${2:NetworkMessages::NetworkMessageType type}, ${3:const Vector& in vecOrigin}, ${4:edict_t@ pEdict = null} )" ],
		"description" : "Constructor"
	},
	"void NetworkMessage::End()": {
		"prefix": "End",
		"body" : [ "End()" ],
		"description" : "Ends the message. Must be called to send the message."
	},
	"void NetworkMessage::WriteByte(uint8 byte)": {
		"prefix": "WriteByte",
		"body" : [ "WriteByte( ${1:uint8 byte} )" ],
		"description" : "Writes a byte to the buffer."
	},
	"void NetworkMessage::WriteChar(const string& in szChar)": {
		"prefix": "WriteChar",
		"body" : [ "WriteChar( ${1:const string& in szChar} )" ],
		"description" : "Writes a character to the buffer."
	},
	"void NetworkMessage::WriteShort(int16 short)": {
		"prefix": "WriteShort",
		"body" : [ "WriteShort( ${1:int16 short} )" ],
		"description" : "Writes a short to the buffer."
	},
	"void NetworkMessage::WriteLong(int32 long)": {
		"prefix": "WriteLong",
		"body" : [ "WriteLong( ${1:int32 long} )" ],
		"description" : "Writes a long to the buffer."
	},
	"void NetworkMessage::WriteAngle(float flValue)": {
		"prefix": "WriteAngle",
		"body" : [ "WriteAngle( ${1:float flValue} )" ],
		"description" : "Writes an angle to the buffer."
	},
	"void NetworkMessage::WriteCoord(float flValue)": {
		"prefix": "WriteCoord",
		"body" : [ "WriteCoord( ${1:float flValue} )" ],
		"description" : "Writes a coordinate to the buffer."
	},
	"void NetworkMessage::WriteVector(const Vector& in vecVector)": {
		"prefix": "WriteVector",
		"body" : [ "WriteVector( ${1:const Vector& in vecVector} )" ],
		"description" : "Writes a vector to the buffer."
	},
	"void NetworkMessage::WriteString(const string& in szString)": {
		"prefix": "WriteString",
		"body" : [ "WriteString( ${1:const string& in szString} )" ],
		"description" : "Writes a string to the buffer."
	},
	"void NetworkMessage::WriteEntity(int iEntity)": {
		"prefix": "WriteEntity",
		"body" : [ "WriteEntity( ${1:int iEntity} )" ],
		"description" : "Writes an entity index to the buffer."
	},
	"void NetworkMessage::WriteEntity(CBaseEntity@ pEntity)": {
		"prefix": "WriteEntity",
		"body" : [ "WriteEntity( ${1:CBaseEntity@ pEntity} )" ],
		"description" : "Writes an entity index to the buffer."
	},
	"void NetworkMessage::WriteFloat(float flValue)": {
		"prefix": "WriteFloat",
		"body" : [ "WriteFloat( ${1:float flValue} )" ],
		"description" : "Writes a float to the buffer."
	},
	"enum NetworkMessageDest {..., MSG_BROADCAST, ...}": {
		"prefix": "MSG_BROADCAST",
		"body" : [ "MSG_BROADCAST" ],
		"description" : "(0) unreliable to all"
	},
	"enum NetworkMessageDest {..., MSG_ONE, ...}": {
		"prefix": "MSG_ONE",
		"body" : [ "MSG_ONE" ],
		"description" : "(1) reliable to one (msg_entity)"
	},
	"enum NetworkMessageDest {..., MSG_ALL, ...}": {
		"prefix": "MSG_ALL",
		"body" : [ "MSG_ALL" ],
		"description" : "(2) reliable to all"
	},
	"enum NetworkMessageDest {..., MSG_INIT, ...}": {
		"prefix": "MSG_INIT",
		"body" : [ "MSG_INIT" ],
		"description" : "(3) write to the init string"
	},
	"enum NetworkMessageDest {..., MSG_PVS, ...}": {
		"prefix": "MSG_PVS",
		"body" : [ "MSG_PVS" ],
		"description" : "(4) Ents in PVS of org"
	},
	"enum NetworkMessageDest {..., MSG_PAS, ...}": {
		"prefix": "MSG_PAS",
		"body" : [ "MSG_PAS" ],
		"description" : "(5) Ents in PAS of org"
	},
	"enum NetworkMessageDest {..., MSG_PVS_R, ...}": {
		"prefix": "MSG_PVS_R",
		"body" : [ "MSG_PVS_R" ],
		"description" : "(6) Reliable to PVS"
	},
	"enum NetworkMessageDest {..., MSG_PAS_R, ...}": {
		"prefix": "MSG_PAS_R",
		"body" : [ "MSG_PAS_R" ],
		"description" : "(7) Reliable to PAS"
	},
	"enum NetworkMessageDest {..., MSG_ONE_UNRELIABLE, ...}": {
		"prefix": "MSG_ONE_UNRELIABLE",
		"body" : [ "MSG_ONE_UNRELIABLE" ],
		"description" : "(8) Send to one client, but don't put in reliable stream, put in unreliable datagram (could be dropped)"
	},
	"enum NetworkMessageDest {..., MSG_SPEC, ...}": {
		"prefix": "MSG_SPEC",
		"body" : [ "MSG_SPEC" ],
		"description" : "(9) Sends to all spectator proxies"
	},
	"enum NetworkMessages::NetworkMessageType {..., SVC_TEMPENTITY, ...}": {
		"prefix": "SVC_TEMPENTITY",
		"body" : [ "NetworkMessages::SVC_TEMPENTITY" ],
		"description" : "(23) Creates temporary entities on the client side."
	},
	"enum NetworkMessages::NetworkMessageType {..., SVC_INTERMISSION, ...}": {
		"prefix": "SVC_INTERMISSION",
		"body" : [ "NetworkMessages::SVC_INTERMISSION" ],
		"description" : "(30) Enables intermission for clients."
	},
	"enum NetworkMessages::NetworkMessageType {..., SVC_STUFFTEXT, ...}": {
		"prefix": "SVC_STUFFTEXT",
		"body" : [ "NetworkMessages::SVC_STUFFTEXT" ],
		"description" : "(9) Executes command on the client side."
	},
	"enum NetworkMessages::NetworkMessageType {..., SelAmmo, ...}": {
		"prefix": "SelAmmo",
		"body" : [ "NetworkMessages::SelAmmo" ],
		"description" : "(64) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., CurWeapon, ...}": {
		"prefix": "CurWeapon",
		"body" : [ "NetworkMessages::CurWeapon" ],
		"description" : "(65) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Geiger, ...}": {
		"prefix": "Geiger",
		"body" : [ "NetworkMessages::Geiger" ],
		"description" : "(66) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Flashlight, ...}": {
		"prefix": "Flashlight",
		"body" : [ "NetworkMessages::Flashlight" ],
		"description" : "(67) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., FlashBat, ...}": {
		"prefix": "FlashBat",
		"body" : [ "NetworkMessages::FlashBat" ],
		"description" : "(68) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Health, ...}": {
		"prefix": "Health",
		"body" : [ "NetworkMessages::Health" ],
		"description" : "(69) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Damage, ...}": {
		"prefix": "Damage",
		"body" : [ "NetworkMessages::Damage" ],
		"description" : "(70) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Battery, ...}": {
		"prefix": "Battery",
		"body" : [ "NetworkMessages::Battery" ],
		"description" : "(71) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Train, ...}": {
		"prefix": "Train",
		"body" : [ "NetworkMessages::Train" ],
		"description" : "(72) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., HudText, ...}": {
		"prefix": "HudText",
		"body" : [ "NetworkMessages::HudText" ],
		"description" : "(73) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., SayText, ...}": {
		"prefix": "SayText",
		"body" : [ "NetworkMessages::SayText" ],
		"description" : "(74) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., TextMsg, ...}": {
		"prefix": "TextMsg",
		"body" : [ "NetworkMessages::TextMsg" ],
		"description" : "(75) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., WeaponList, ...}": {
		"prefix": "WeaponList",
		"body" : [ "NetworkMessages::WeaponList" ],
		"description" : "(76) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., CustWeapon, ...}": {
		"prefix": "CustWeapon",
		"body" : [ "NetworkMessages::CustWeapon" ],
		"description" : "(77) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ResetHUD, ...}": {
		"prefix": "ResetHUD",
		"body" : [ "NetworkMessages::ResetHUD" ],
		"description" : "(78) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., InitHUD, ...}": {
		"prefix": "InitHUD",
		"body" : [ "NetworkMessages::InitHUD" ],
		"description" : "(79) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., CdAudio, ...}": {
		"prefix": "CdAudio",
		"body" : [ "NetworkMessages::CdAudio" ],
		"description" : "(80) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., GameTitle, ...}": {
		"prefix": "GameTitle",
		"body" : [ "NetworkMessages::GameTitle" ],
		"description" : "(81) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., DeathMsg, ...}": {
		"prefix": "DeathMsg",
		"body" : [ "NetworkMessages::DeathMsg" ],
		"description" : "(82) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ScoreInfo, ...}": {
		"prefix": "ScoreInfo",
		"body" : [ "NetworkMessages::ScoreInfo" ],
		"description" : "(83) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., TeamInfo, ...}": {
		"prefix": "TeamInfo",
		"body" : [ "NetworkMessages::TeamInfo" ],
		"description" : "(84) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., TeamScore, ...}": {
		"prefix": "TeamScore",
		"body" : [ "NetworkMessages::TeamScore" ],
		"description" : "(85) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., GameMode, ...}": {
		"prefix": "GameMode",
		"body" : [ "NetworkMessages::GameMode" ],
		"description" : "(86) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., MOTD, ...}": {
		"prefix": "MOTD",
		"body" : [ "NetworkMessages::MOTD" ],
		"description" : "(87) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., AmmoPickup, ...}": {
		"prefix": "AmmoPickup",
		"body" : [ "NetworkMessages::AmmoPickup" ],
		"description" : "(88) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., WeapPickup, ...}": {
		"prefix": "WeapPickup",
		"body" : [ "NetworkMessages::WeapPickup" ],
		"description" : "(89) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ItemPickup, ...}": {
		"prefix": "ItemPickup",
		"body" : [ "NetworkMessages::ItemPickup" ],
		"description" : "(90) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., HideHUD, ...}": {
		"prefix": "HideHUD",
		"body" : [ "NetworkMessages::HideHUD" ],
		"description" : "(91) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., SetFOV, ...}": {
		"prefix": "SetFOV",
		"body" : [ "NetworkMessages::SetFOV" ],
		"description" : "(92) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ShowMenu, ...}": {
		"prefix": "ShowMenu",
		"body" : [ "NetworkMessages::ShowMenu" ],
		"description" : "(93) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ScreenShake, ...}": {
		"prefix": "ScreenShake",
		"body" : [ "NetworkMessages::ScreenShake" ],
		"description" : "(94) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ScreenFade, ...}": {
		"prefix": "ScreenFade",
		"body" : [ "NetworkMessages::ScreenFade" ],
		"description" : "(95) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., AmmoX, ...}": {
		"prefix": "AmmoX",
		"body" : [ "NetworkMessages::AmmoX" ],
		"description" : "(96) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Gib, ...}": {
		"prefix": "Gib",
		"body" : [ "NetworkMessages::Gib" ],
		"description" : "(97) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Spectator, ...}": {
		"prefix": "Spectator",
		"body" : [ "NetworkMessages::Spectator" ],
		"description" : "(98) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., TE_CUSTOM, ...}": {
		"prefix": "TE_CUSTOM",
		"body" : [ "NetworkMessages::TE_CUSTOM" ],
		"description" : "(99) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Speaksent, ...}": {
		"prefix": "Speaksent",
		"body" : [ "NetworkMessages::Speaksent" ],
		"description" : "(100) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., TimeEnd, ...}": {
		"prefix": "TimeEnd",
		"body" : [ "NetworkMessages::TimeEnd" ],
		"description" : "(101) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., MapList, ...}": {
		"prefix": "MapList",
		"body" : [ "NetworkMessages::MapList" ],
		"description" : "(102) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., CbElec, ...}": {
		"prefix": "CbElec",
		"body" : [ "NetworkMessages::CbElec" ],
		"description" : "(103) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., EndVote, ...}": {
		"prefix": "EndVote",
		"body" : [ "NetworkMessages::EndVote" ],
		"description" : "(104) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., VoteMenu, ...}": {
		"prefix": "VoteMenu",
		"body" : [ "NetworkMessages::VoteMenu" ],
		"description" : "(105) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., NextMap, ...}": {
		"prefix": "NextMap",
		"body" : [ "NetworkMessages::NextMap" ],
		"description" : "(106) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., StartSound, ...}": {
		"prefix": "StartSound",
		"body" : [ "NetworkMessages::StartSound" ],
		"description" : "(107) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., SoundList, ...}": {
		"prefix": "SoundList",
		"body" : [ "NetworkMessages::SoundList" ],
		"description" : "(108) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ToxicCloud, ...}": {
		"prefix": "ToxicCloud",
		"body" : [ "NetworkMessages::ToxicCloud" ],
		"description" : "(109) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ShkFlash, ...}": {
		"prefix": "ShkFlash",
		"body" : [ "NetworkMessages::ShkFlash" ],
		"description" : "(110) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., CreateBlood, ...}": {
		"prefix": "CreateBlood",
		"body" : [ "NetworkMessages::CreateBlood" ],
		"description" : "(111) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., GargSplash, ...}": {
		"prefix": "GargSplash",
		"body" : [ "NetworkMessages::GargSplash" ],
		"description" : "(112) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., SporeTrail, ...}": {
		"prefix": "SporeTrail",
		"body" : [ "NetworkMessages::SporeTrail" ],
		"description" : "(113) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., TracerDecal, ...}": {
		"prefix": "TracerDecal",
		"body" : [ "NetworkMessages::TracerDecal" ],
		"description" : "(114) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., SRDetonate, ...}": {
		"prefix": "SRDetonate",
		"body" : [ "NetworkMessages::SRDetonate" ],
		"description" : "(115) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., SRPrimed, ...}": {
		"prefix": "SRPrimed",
		"body" : [ "NetworkMessages::SRPrimed" ],
		"description" : "(116) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., SRPrimedOff, ...}": {
		"prefix": "SRPrimedOff",
		"body" : [ "NetworkMessages::SRPrimedOff" ],
		"description" : "(117) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., RampSprite, ...}": {
		"prefix": "RampSprite",
		"body" : [ "NetworkMessages::RampSprite" ],
		"description" : "(118) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ShieldRic, ...}": {
		"prefix": "ShieldRic",
		"body" : [ "NetworkMessages::ShieldRic" ],
		"description" : "(119) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Playlist, ...}": {
		"prefix": "Playlist",
		"body" : [ "NetworkMessages::Playlist" ],
		"description" : "(120) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., VGUIMenu, ...}": {
		"prefix": "VGUIMenu",
		"body" : [ "NetworkMessages::VGUIMenu" ],
		"description" : "(121) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ServerName, ...}": {
		"prefix": "ServerName",
		"body" : [ "NetworkMessages::ServerName" ],
		"description" : "(122) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., TeamNames, ...}": {
		"prefix": "TeamNames",
		"body" : [ "NetworkMessages::TeamNames" ],
		"description" : "(123) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ServerVer, ...}": {
		"prefix": "ServerVer",
		"body" : [ "NetworkMessages::ServerVer" ],
		"description" : "(124) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ServerBuild, ...}": {
		"prefix": "ServerBuild",
		"body" : [ "NetworkMessages::ServerBuild" ],
		"description" : "(125) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., WeatherFX, ...}": {
		"prefix": "WeatherFX",
		"body" : [ "NetworkMessages::WeatherFX" ],
		"description" : "(126) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., CameraMouse, ...}": {
		"prefix": "CameraMouse",
		"body" : [ "NetworkMessages::CameraMouse" ],
		"description" : "(127) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Fog, ...}": {
		"prefix": "Fog",
		"body" : [ "NetworkMessages::Fog" ],
		"description" : "(128) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., PrtlUpdt, ...}": {
		"prefix": "PrtlUpdt",
		"body" : [ "NetworkMessages::PrtlUpdt" ],
		"description" : "(129) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ASScriptName, ...}": {
		"prefix": "ASScriptName",
		"body" : [ "NetworkMessages::ASScriptName" ],
		"description" : "(130) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., PrintKB, ...}": {
		"prefix": "PrintKB",
		"body" : [ "NetworkMessages::PrintKB" ],
		"description" : "(131) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., InvAdd, ...}": {
		"prefix": "InvAdd",
		"body" : [ "NetworkMessages::InvAdd" ],
		"description" : "(132) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., InvRemove, ...}": {
		"prefix": "InvRemove",
		"body" : [ "NetworkMessages::InvRemove" ],
		"description" : "(133) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Concuss, ...}": {
		"prefix": "Concuss",
		"body" : [ "NetworkMessages::Concuss" ],
		"description" : "(134) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ViewMode, ...}": {
		"prefix": "ViewMode",
		"body" : [ "NetworkMessages::ViewMode" ],
		"description" : "(135) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., Flamethwr, ...}": {
		"prefix": "Flamethwr",
		"body" : [ "NetworkMessages::Flamethwr" ],
		"description" : "(136) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ClassicMode, ...}": {
		"prefix": "ClassicMode",
		"body" : [ "NetworkMessages::ClassicMode" ],
		"description" : "(137) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., WeaponSpr, ...}": {
		"prefix": "WeaponSpr",
		"body" : [ "NetworkMessages::WeaponSpr" ],
		"description" : "(138) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., ToggleElem, ...}": {
		"prefix": "ToggleElem",
		"body" : [ "NetworkMessages::ToggleElem" ],
		"description" : "(139) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., CustSpr, ...}": {
		"prefix": "CustSpr",
		"body" : [ "NetworkMessages::CustSpr" ],
		"description" : "(140) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., NumDisplay, ...}": {
		"prefix": "NumDisplay",
		"body" : [ "NetworkMessages::NumDisplay" ],
		"description" : "(141) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., UpdateNum, ...}": {
		"prefix": "UpdateNum",
		"body" : [ "NetworkMessages::UpdateNum" ],
		"description" : "(142) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., TimeDisplay, ...}": {
		"prefix": "TimeDisplay",
		"body" : [ "NetworkMessages::TimeDisplay" ],
		"description" : "(143) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., UpdateTime, ...}": {
		"prefix": "UpdateTime",
		"body" : [ "NetworkMessages::UpdateTime" ],
		"description" : "(144) User message"
	},
	"enum NetworkMessages::NetworkMessageType {..., VModelPos, ...}": {
		"prefix": "VModelPos",
		"body" : [ "NetworkMessages::VModelPos" ],
		"description" : "(145) User message"
	},
	"uint Reflection::ObjectType::GetMethodCount() const": {
		"prefix": "GetMethodCount",
		"body" : [ "GetMethodCount()" ],
		"description" : "Gets the number of methods this object type has."
	},
	"Method@ Reflection::ObjectType::GetMethodByIndex(uint uiIndex) const": {
		"prefix": "GetMethodByIndex",
		"body" : [ "GetMethodByIndex( ${1:uint uiIndex} )" ],
		"description" : "Gets the method at the given index."
	},
	"Method@ Reflection::ObjectType::GetMethod(const string& in szFunctionSignature)": {
		"prefix": "GetMethod",
		"body" : [ "GetMethod( ${1:const string& in szFunctionSignature} )" ],
		"description" : "Gets a method by declaration."
	},
	"bool Reflection::ObjectType::MethodExists(const string& in szFunctionSignature)": {
		"prefix": "MethodExists",
		"body" : [ "MethodExists( ${1:const string& in szFunctionSignature} )" ],
		"description" : "Gets a method by declaration."
	},
	"bool Reflection::ObjectType::Equals(const ObjectType@ pObjectType) const": {
		"prefix": "Equals",
		"body" : [ "Equals( ${1:const ObjectType@ pObjectType} )" ],
		"description" : "Returns whether the given object type is identical to this one."
	},
	"bool Reflection::ObjectType::IsCompatible(const ObjectType@ pObjectType) const": {
		"prefix": "IsCompatible",
		"body" : [ "IsCompatible( ${1:const ObjectType@ pObjectType} )" ],
		"description" : "Returns whether the given object type is compatible with this one."
	},
	"bool Reflection::ObjectType::DerivesFrom(const string& in szName) const": {
		"prefix": "DerivesFrom",
		"body" : [ "DerivesFrom( ${1:const string& in szName} )" ],
		"description" : "Returns whether this object derives from the given type."
	},
	"bool Reflection::ObjectType::DerivesFrom(const ObjectType@ pObjectType) const": {
		"prefix": "DerivesFrom",
		"body" : [ "DerivesFrom( ${1:const ObjectType@ pObjectType} )" ],
		"description" : "Returns whether this object derives from the given type."
	},
	"CBaseEntity@ Observer::GetObserverTarget()": {
		"prefix": "GetObserverTarget",
		"body" : [ "GetObserverTarget()" ],
		"description" : "Gets the current observer target, if any."
	},
	"void Observer::ResetObserverTarget()": {
		"prefix": "ResetObserverTarget",
		"body" : [ "ResetObserverTarget()" ],
		"description" : "Resets the observer target and finds the next suitable candidate."
	},
	"void Observer::SetObserverTarget(CBasePlayer@ pPlayer)": {
		"prefix": "SetObserverTarget",
		"body" : [ "SetObserverTarget( ${1:CBasePlayer@ pPlayer} )" ],
		"description" : "Sets the observer target."
	},
	"bool Observer::CanUseObserver()": {
		"prefix": "CanUseObserver",
		"body" : [ "CanUseObserver()" ],
		"description" : "Returns whether this player can use observer mode."
	},
	"bool Observer::IsObserver() const": {
		"prefix": "IsObserver",
		"body" : [ "IsObserver()" ],
		"description" : "Returns whether this player is an observer."
	},
	"void Observer::StartObserver(const Vector& in vecPosition, const Vector& in vecViewAngle, bool fCreateBody = true)": {
		"prefix": "StartObserver",
		"body" : [ "StartObserver( ${1:const Vector& in vecPosition}, ${2:const Vector& in vecViewAngle}, ${3:bool fCreateBody = true} )" ],
		"description" : "Starts observer mode."
	},
	"void Observer::StopObserver(bool fRespawn)": {
		"prefix": "StopObserver",
		"body" : [ "StopObserver( ${1:bool fRespawn} )" ],
		"description" : "Stops observer mode."
	},
	"void Observer::FindNextPlayer(bool fReverse)": {
		"prefix": "FindNextPlayer",
		"body" : [ "FindNextPlayer( ${1:bool fReverse} )" ],
		"description" : "Find the next player to observe."
	},
	"void Observer::HandleButtons()": {
		"prefix": "HandleButtons",
		"body" : [ "HandleButtons()" ],
		"description" : "Handles button input."
	},
	"void Observer::SetMode(ObserverMode iMode)": {
		"prefix": "SetMode",
		"body" : [ "SetMode( ${1:ObserverMode iMode} )" ],
		"description" : "Sets the observer mode."
	},
	"CBaseEntity@ Observer::FindObserverStartPoint()": {
		"prefix": "FindObserverStartPoint",
		"body" : [ "FindObserverStartPoint()" ],
		"description" : "Find a point to start a player at for observer."
	},
	"bool Observer::HasCorpse()": {
		"prefix": "HasCorpse",
		"body" : [ "HasCorpse()" ],
		"description" : "Returns whether this player has a corpse."
	},
	"bool Observer::CanControlObserverMode() const": {
		"prefix": "CanControlObserverMode",
		"body" : [ "CanControlObserverMode()" ],
		"description" : "Returns whether this player can control the observer mode."
	},
	"void Observer::SetObserverModeControlEnabled(bool fEnabled)": {
		"prefix": "SetObserverModeControlEnabled",
		"body" : [ "SetObserverModeControlEnabled( ${1:bool fEnabled} )" ],
		"description" : "Sets whether this player can control the observer mode."
	},
	"void Observer::RemoveDeadBody()": {
		"prefix": "RemoveDeadBody",
		"body" : [ "RemoveDeadBody()" ],
		"description" : "Removes the player's dead body, if it exists."
	},
	"enum ObserverMode {..., OBS_ENTERING, ...}": {
		"prefix": "OBS_ENTERING",
		"body" : [ "OBS_ENTERING" ],
		"description" : "(-1) Player in the process of entering observer mode"
	},
	"enum ObserverMode {..., OBS_NONE, ...}": {
		"prefix": "OBS_NONE",
		"body" : [ "OBS_NONE" ],
		"description" : "(0) Player not in observer mode"
	},
	"enum ObserverMode {..., OBS_CHASE_LOCKED, ...}": {
		"prefix": "OBS_CHASE_LOCKED",
		"body" : [ "OBS_CHASE_LOCKED" ],
		"description" : "(3) Chase locked"
	},
	"enum ObserverMode {..., OBS_CHASE_FREE, ...}": {
		"prefix": "OBS_CHASE_FREE",
		"body" : [ "OBS_CHASE_FREE" ],
		"description" : "(1) Free movement"
	},
	"enum ObserverMode {..., OBS_ROAMING, ...}": {
		"prefix": "OBS_ROAMING",
		"body" : [ "OBS_ROAMING" ],
		"description" : "(2) Roaming"
	},
	"enum OpenFile::OpenFile {..., READ, ...}": {
		"prefix": "READ",
		"body" : [ "OpenFile::READ" ],
		"description" : "(1) Open file for reading."
	},
	"enum OpenFile::OpenFile {..., WRITE, ...}": {
		"prefix": "WRITE",
		"body" : [ "OpenFile::WRITE" ],
		"description" : "(2) Open file for writing."
	},
	"enum OpenFile::OpenFile {..., APPEND, ...}": {
		"prefix": "APPEND",
		"body" : [ "OpenFile::APPEND" ],
		"description" : "(4) Open file for appending."
	},
	"enum OpenFile::OpenFile {..., BINARY, ...}": {
		"prefix": "BINARY",
		"body" : [ "OpenFile::BINARY" ],
		"description" : "(8) Open in binary mode."
	},
	"enum PathTrackSpawnFlags {..., SF_PATH_DISABLED, ...}": {
		"prefix": "SF_PATH_DISABLED",
		"body" : [ "SF_PATH_DISABLED" ],
		"description" : "(1)"
	},
	"enum PathTrackSpawnFlags {..., SF_PATH_FIREONCE, ...}": {
		"prefix": "SF_PATH_FIREONCE",
		"body" : [ "SF_PATH_FIREONCE" ],
		"description" : "(2)"
	},
	"enum PathTrackSpawnFlags {..., SF_PATH_ALTREVERSE, ...}": {
		"prefix": "SF_PATH_ALTREVERSE",
		"body" : [ "SF_PATH_ALTREVERSE" ],
		"description" : "(4)"
	},
	"enum PathTrackSpawnFlags {..., SF_PATH_DISABLE_TRAIN, ...}": {
		"prefix": "SF_PATH_DISABLE_TRAIN",
		"body" : [ "SF_PATH_DISABLE_TRAIN" ],
		"description" : "(8)"
	},
	"enum PathTrackSpawnFlags {..., SF_PATH_ALTERNATE, ...}": {
		"prefix": "SF_PATH_ALTERNATE",
		"body" : [ "SF_PATH_ALTERNATE" ],
		"description" : "(32768)"
	},
	"enum PFLAG {..., PFLAG_ONLADDER, ...}": {
		"prefix": "PFLAG_ONLADDER",
		"body" : [ "PFLAG_ONLADDER" ],
		"description" : "(1)"
	},
	"enum PFLAG {..., PFLAG_ONSWING, ...}": {
		"prefix": "PFLAG_ONSWING",
		"body" : [ "PFLAG_ONSWING" ],
		"description" : "(1)"
	},
	"enum PFLAG {..., PFLAG_ONTRAIN, ...}": {
		"prefix": "PFLAG_ONTRAIN",
		"body" : [ "PFLAG_ONTRAIN" ],
		"description" : "(2)"
	},
	"enum PFLAG {..., PFLAG_ONBARNACLE, ...}": {
		"prefix": "PFLAG_ONBARNACLE",
		"body" : [ "PFLAG_ONBARNACLE" ],
		"description" : "(4)"
	},
	"enum PFLAG {..., PFLAG_DUCKING, ...}": {
		"prefix": "PFLAG_DUCKING",
		"body" : [ "PFLAG_DUCKING" ],
		"description" : "(8) In the process of ducking, but totally squatted yet"
	},
	"enum PFLAG {..., PFLAG_USING, ...}": {
		"prefix": "PFLAG_USING",
		"body" : [ "PFLAG_USING" ],
		"description" : "(16) Using a continuous entity"
	},
	"enum PFLAG {..., PFLAG_OBSERVER, ...}": {
		"prefix": "PFLAG_OBSERVER",
		"body" : [ "PFLAG_OBSERVER" ],
		"description" : "(32) player is locked in stationary cam mode. Spectators can move, observers can't."
	},
	"enum PFLAG {..., PFLAG_GRAPPLE, ...}": {
		"prefix": "PFLAG_GRAPPLE",
		"body" : [ "PFLAG_GRAPPLE" ],
		"description" : "(64) Toggle grapple use"
	},
	"enum PFLAG {..., PFLAG_CAMERA, ...}": {
		"prefix": "PFLAG_CAMERA",
		"body" : [ "PFLAG_CAMERA" ],
		"description" : "(128) Looking through a trigger_camera"
	},
	"enum PITCH {..., PITCH_NORM, ...}": {
		"prefix": "PITCH_NORM",
		"body" : [ "PITCH_NORM" ],
		"description" : "(100) non-pitch shifted"
	},
	"enum PITCH {..., PITCH_LOW, ...}": {
		"prefix": "PITCH_LOW",
		"body" : [ "PITCH_LOW" ],
		"description" : "(95) low pitch"
	},
	"enum PITCH {..., PITCH_HIGH, ...}": {
		"prefix": "PITCH_HIGH",
		"body" : [ "PITCH_HIGH" ],
		"description" : "(120) high pitch"
	},
	"enum PLAYER_ANIM {..., PLAYER_IDLE, ...}": {
		"prefix": "PLAYER_IDLE",
		"body" : [ "PLAYER_IDLE" ],
		"description" : "(0)"
	},
	"enum PLAYER_ANIM {..., PLAYER_WALK, ...}": {
		"prefix": "PLAYER_WALK",
		"body" : [ "PLAYER_WALK" ],
		"description" : "(1)"
	},
	"enum PLAYER_ANIM {..., PLAYER_JUMP, ...}": {
		"prefix": "PLAYER_JUMP",
		"body" : [ "PLAYER_JUMP" ],
		"description" : "(2)"
	},
	"enum PLAYER_ANIM {..., PLAYER_SUPERJUMP, ...}": {
		"prefix": "PLAYER_SUPERJUMP",
		"body" : [ "PLAYER_SUPERJUMP" ],
		"description" : "(3)"
	},
	"enum PLAYER_ANIM {..., PLAYER_DIE, ...}": {
		"prefix": "PLAYER_DIE",
		"body" : [ "PLAYER_DIE" ],
		"description" : "(4)"
	},
	"enum PLAYER_ANIM {..., PLAYER_ATTACK1, ...}": {
		"prefix": "PLAYER_ATTACK1",
		"body" : [ "PLAYER_ATTACK1" ],
		"description" : "(5)"
	},
	"enum PLAYER_ANIM {..., PLAYER_RELOAD, ...}": {
		"prefix": "PLAYER_RELOAD",
		"body" : [ "PLAYER_RELOAD" ],
		"description" : "(6)"
	},
	"enum PLAYER_ANIM {..., PLAYER_DEPLOY, ...}": {
		"prefix": "PLAYER_DEPLOY",
		"body" : [ "PLAYER_DEPLOY" ],
		"description" : "(7)"
	},
	"enum PLAYER_ANIM {..., PLAYER_BARNACLE_HIT, ...}": {
		"prefix": "PLAYER_BARNACLE_HIT",
		"body" : [ "PLAYER_BARNACLE_HIT" ],
		"description" : "(8)"
	},
	"enum PLAYER_ANIM {..., PLAYER_BARNACLE_PULL, ...}": {
		"prefix": "PLAYER_BARNACLE_PULL",
		"body" : [ "PLAYER_BARNACLE_PULL" ],
		"description" : "(9)"
	},
	"enum PLAYER_ANIM {..., PLAYER_BARNACLE_CHOMP, ...}": {
		"prefix": "PLAYER_BARNACLE_CHOMP",
		"body" : [ "PLAYER_BARNACLE_CHOMP" ],
		"description" : "(10)"
	},
	"enum PLAYER_ANIM {..., PLAYER_BARNACLE_CHEW, ...}": {
		"prefix": "PLAYER_BARNACLE_CHEW",
		"body" : [ "PLAYER_BARNACLE_CHEW" ],
		"description" : "(11)"
	},
	"enum PlayerHookFlag {..., PlrHook_SkipVehicles, ...}": {
		"prefix": "PlrHook_SkipVehicles",
		"body" : [ "PlrHook_SkipVehicles" ],
		"description" : "(1) Don't run vehicle checks"
	},
	"enum PlayerHookFlag {..., PlrHook_SkipUse, ...}": {
		"prefix": "PlrHook_SkipUse",
		"body" : [ "PlrHook_SkipUse" ],
		"description" : "(2) Don't run +use checks"
	},
	"enum PlayerViewMode {..., ViewMode_FirstPerson, ...}": {
		"prefix": "ViewMode_FirstPerson",
		"body" : [ "ViewMode_FirstPerson" ],
		"description" : "(0)"
	},
	"enum PlayerViewMode {..., ViewMode_ThirdPerson, ...}": {
		"prefix": "ViewMode_ThirdPerson",
		"body" : [ "ViewMode_ThirdPerson" ],
		"description" : "(1)"
	},
	"enum PRINT_TYPE {..., print_console, ...}": {
		"prefix": "print_console",
		"body" : [ "print_console" ],
		"description" : "(0) Print to the console"
	},
	"enum PRINT_TYPE {..., print_center, ...}": {
		"prefix": "print_center",
		"body" : [ "print_center" ],
		"description" : "(1) Print to the center of the screen"
	},
	"enum PRINT_TYPE {..., print_chat, ...}": {
		"prefix": "print_chat",
		"body" : [ "print_chat" ],
		"description" : "(2) Print to chat. Note: does not work. Use CPlayerFuncs::ClientPrint with HUD_PRINTTALK instead."
	},
	"const float WORLD_BOUNDARY": {
		"prefix": "WORLD_BOUNDARY",
		"body" : [ "WORLD_BOUNDARY" ],
		"description" : "Distance from the world origin to the world boundary in a single axis"
	},
	"const CompareType String::DEFAULT_COMPARE": {
		"prefix": "DEFAULT_COMPARE",
		"body" : [ "String::DEFAULT_COMPARE" ],
		"description" : "Default comparison type."
	},
	"const string String::EMPTY_STRING": {
		"prefix": "EMPTY_STRING",
		"body" : [ "String::EMPTY_STRING" ],
		"description" : "Empty string. Useful when a reference to a string is needed."
	},
	"const string String::WHITESPACE_CHARACTERS": {
		"prefix": "WHITESPACE_CHARACTERS",
		"body" : [ "String::WHITESPACE_CHARACTERS" ],
		"description" : "A string that contains one instance of every whitespace character."
	},
	"const size_t String::INVALID_INDEX": {
		"prefix": "INVALID_INDEX",
		"body" : [ "String::INVALID_INDEX" ],
		"description" : "Sentinel value used by string methods."
	},
	"const size_t String::NO_MORE_TOKENS": {
		"prefix": "NO_MORE_TOKENS",
		"body" : [ "String::NO_MORE_TOKENS" ],
		"description" : "Sentinel value used by string tokenization when there are no tokens remaining."
	},
	"CReflection Reflection::g_Reflection": {
		"prefix": "g_Reflection",
		"body" : [ "Reflection::g_Reflection" ],
		"description" : "Reflection global class instance."
	},
	"CVirtualFileSystem g_FileSystem": {
		"prefix": "g_FileSystem",
		"body" : [ "g_FileSystem" ],
		"description" : "Global file system instance"
	},
	" CDebuggerg_Debugger": {
		"prefix": "CDebuggerg_Debugger",
		"body" : [ "CDebuggerg_Debugger" ],
		"description" : "Debugger instance."
	},
	"const Vector g_vecZero": {
		"prefix": "g_vecZero",
		"body" : [ "g_vecZero" ],
		"description" : "Zero vector (0, 0, 0)"
	},
	"CMath Math": {
		"prefix": "Math",
		"body" : [ "Math" ],
		"description" : "Math functions instance"
	},
	"const float VIEW_FIELD_FULL": {
		"prefix": "VIEW_FIELD_FULL",
		"body" : [ "VIEW_FIELD_FULL" ],
		"description" : "Full view field"
	},
	"const float VIEW_FIELD_WIDE": {
		"prefix": "VIEW_FIELD_WIDE",
		"body" : [ "VIEW_FIELD_WIDE" ],
		"description" : "Wide view field"
	},
	"const float VIEW_FIELD_NARROW": {
		"prefix": "VIEW_FIELD_NARROW",
		"body" : [ "VIEW_FIELD_NARROW" ],
		"description" : "Narrow view field"
	},
	"const float VIEW_FIELD_ULTRA_NARROW": {
		"prefix": "VIEW_FIELD_ULTRA_NARROW",
		"body" : [ "VIEW_FIELD_ULTRA_NARROW" ],
		"description" : "Ultra narrow view field"
	},
	"CDecals g_Decals": {
		"prefix": "g_Decals",
		"body" : [ "g_Decals" ],
		"description" : "Dynamic decal manager instance"
	},
	"CActivityMap g_ActivityMap": {
		"prefix": "g_ActivityMap",
		"body" : [ "g_ActivityMap" ],
		"description" : "Activity map instance"
	},
	"Schedule Schedules::slIdleStand": {
		"prefix": "slIdleStand",
		"body" : [ "Schedules::slIdleStand" ],
		"description" : ""
	},
	"Schedule Schedules::slIdleTrigger": {
		"prefix": "slIdleTrigger",
		"body" : [ "Schedules::slIdleTrigger" ],
		"description" : ""
	},
	"Schedule Schedules::slIdleWalk": {
		"prefix": "slIdleWalk",
		"body" : [ "Schedules::slIdleWalk" ],
		"description" : ""
	},
	"Schedule Schedules::slWakeAngry": {
		"prefix": "slWakeAngry",
		"body" : [ "Schedules::slWakeAngry" ],
		"description" : ""
	},
	"Schedule Schedules::slAlertFace": {
		"prefix": "slAlertFace",
		"body" : [ "Schedules::slAlertFace" ],
		"description" : ""
	},
	"Schedule Schedules::slAlertStand": {
		"prefix": "slAlertStand",
		"body" : [ "Schedules::slAlertStand" ],
		"description" : ""
	},
	"Schedule Schedules::slCombatStand": {
		"prefix": "slCombatStand",
		"body" : [ "Schedules::slCombatStand" ],
		"description" : ""
	},
	"Schedule Schedules::slCombatFace": {
		"prefix": "slCombatFace",
		"body" : [ "Schedules::slCombatFace" ],
		"description" : ""
	},
	"Schedule Schedules::slReload": {
		"prefix": "slReload",
		"body" : [ "Schedules::slReload" ],
		"description" : ""
	},
	"Schedule Schedules::slRangeAttack1": {
		"prefix": "slRangeAttack1",
		"body" : [ "Schedules::slRangeAttack1" ],
		"description" : ""
	},
	"Schedule Schedules::slRangeAttack2": {
		"prefix": "slRangeAttack2",
		"body" : [ "Schedules::slRangeAttack2" ],
		"description" : ""
	},
	"Schedule Schedules::slChaseEnemy": {
		"prefix": "slChaseEnemy",
		"body" : [ "Schedules::slChaseEnemy" ],
		"description" : ""
	},
	"Schedule Schedules::slSmallFlinch": {
		"prefix": "slSmallFlinch",
		"body" : [ "Schedules::slSmallFlinch" ],
		"description" : ""
	},
	"Schedule Schedules::slDie": {
		"prefix": "slDie",
		"body" : [ "Schedules::slDie" ],
		"description" : ""
	},
	"Schedule Schedules::slError": {
		"prefix": "slError",
		"body" : [ "Schedules::slError" ],
		"description" : ""
	},
	"Schedule Schedules::slWalkToScript": {
		"prefix": "slWalkToScript",
		"body" : [ "Schedules::slWalkToScript" ],
		"description" : ""
	},
	"Schedule Schedules::slRunToScript": {
		"prefix": "slRunToScript",
		"body" : [ "Schedules::slRunToScript" ],
		"description" : ""
	},
	"Schedule Schedules::slWaitScript": {
		"prefix": "slWaitScript",
		"body" : [ "Schedules::slWaitScript" ],
		"description" : ""
	},
	"Schedule Schedules::slTakeCoverFromBestSound": {
		"prefix": "slTakeCoverFromBestSound",
		"body" : [ "Schedules::slTakeCoverFromBestSound" ],
		"description" : ""
	},
	"Schedule Schedules::slFail": {
		"prefix": "slFail",
		"body" : [ "Schedules::slFail" ],
		"description" : ""
	},
	"const size_t MAX_OLD_ENEMIES": {
		"prefix": "MAX_OLD_ENEMIES",
		"body" : [ "MAX_OLD_ENEMIES" ],
		"description" : "How many old enemies to remember"
	},
	"const size_t ROUTE_SIZE": {
		"prefix": "ROUTE_SIZE",
		"body" : [ "ROUTE_SIZE" ],
		"description" : "How many waypoints a monster can store at one time"
	},
	"const Vector VEC_HULL_MIN": {
		"prefix": "VEC_HULL_MIN",
		"body" : [ "VEC_HULL_MIN" ],
		"description" : "Default hull minimum. Used with CEntityFuncs::SetSize"
	},
	"const Vector VEC_HULL_MAX": {
		"prefix": "VEC_HULL_MAX",
		"body" : [ "VEC_HULL_MAX" ],
		"description" : "Default hull maximum. Used with CEntityFuncs::SetSize"
	},
	"const Vector VEC_HUMAN_HULL_MIN": {
		"prefix": "VEC_HUMAN_HULL_MIN",
		"body" : [ "VEC_HUMAN_HULL_MIN" ],
		"description" : "Default human hull maximum. Used with CEntityFuncs::SetSize"
	},
	"const Vector VEC_HUMAN_HULL_MAX": {
		"prefix": "VEC_HUMAN_HULL_MAX",
		"body" : [ "VEC_HUMAN_HULL_MAX" ],
		"description" : "Default human hull maximum while standing. Used with CEntityFuncs::SetSize"
	},
	"const Vector VEC_HUMAN_HULL_DUCK": {
		"prefix": "VEC_HUMAN_HULL_DUCK",
		"body" : [ "VEC_HUMAN_HULL_DUCK" ],
		"description" : "Default human hull maximum while ducking. Used with CEntityFuncs::SetSize"
	},
	"const Vector VEC_VIEW": {
		"prefix": "VEC_VIEW",
		"body" : [ "VEC_VIEW" ],
		"description" : "View offset."
	},
	"const Vector VEC_DUCK_HULL_MIN": {
		"prefix": "VEC_DUCK_HULL_MIN",
		"body" : [ "VEC_DUCK_HULL_MIN" ],
		"description" : "Hull minimum while ducking. Used with CEntityFuncs::SetSize"
	},
	"const Vector VEC_DUCK_HULL_MAX": {
		"prefix": "VEC_DUCK_HULL_MAX",
		"body" : [ "VEC_DUCK_HULL_MAX" ],
		"description" : "Hull maximum while ducking. Used with CEntityFuncs::SetSize"
	},
	"const Vector VEC_DUCK_VIEW": {
		"prefix": "VEC_DUCK_VIEW",
		"body" : [ "VEC_DUCK_VIEW" ],
		"description" : "Hull view offset while ducking."
	},
	"const size_t MAX_AMMO_TYPES": {
		"prefix": "MAX_AMMO_TYPES",
		"body" : [ "MAX_AMMO_TYPES" ],
		"description" : "Maximum number of ammo types"
	},
	"const size_t MAX_ITEM_TYPES": {
		"prefix": "MAX_ITEM_TYPES",
		"body" : [ "MAX_ITEM_TYPES" ],
		"description" : "HUD item selection slots"
	},
	"const float AUTOAIM_2DEGREES": {
		"prefix": "AUTOAIM_2DEGREES",
		"body" : [ "AUTOAIM_2DEGREES" ],
		"description" : "Autoaim"
	},
	"const float AUTOAIM_5DEGREES": {
		"prefix": "AUTOAIM_5DEGREES",
		"body" : [ "AUTOAIM_5DEGREES" ],
		"description" : "Autoaim"
	},
	"const float AUTOAIM_8DEGREES": {
		"prefix": "AUTOAIM_8DEGREES",
		"body" : [ "AUTOAIM_8DEGREES" ],
		"description" : "Autoaim"
	},
	"const float AUTOAIM_10DEGREES": {
		"prefix": "AUTOAIM_10DEGREES",
		"body" : [ "AUTOAIM_10DEGREES" ],
		"description" : "Autoaim"
	},
	"const float PLAYERCOMMAND_WAIT": {
		"prefix": "PLAYERCOMMAND_WAIT",
		"body" : [ "PLAYERCOMMAND_WAIT" ],
		"description" : "Time between player vocal client commands"
	},
	"CEngineFuncs g_EngineFuncs": {
		"prefix": "g_EngineFuncs",
		"body" : [ "g_EngineFuncs" ],
		"description" : "Engine functions instance"
	},
	"CModelFuncs g_ModelFuncs": {
		"prefix": "g_ModelFuncs",
		"body" : [ "g_ModelFuncs" ],
		"description" : "Model functions instance"
	},
	"const size_t MAX_WORLD_SOUNDS": {
		"prefix": "MAX_WORLD_SOUNDS",
		"body" : [ "MAX_WORLD_SOUNDS" ],
		"description" : "maximum number of sounds handled by the world at one time. See CSoundEnt."
	},
	"const int SOUNDLIST_EMPTY": {
		"prefix": "SOUNDLIST_EMPTY",
		"body" : [ "SOUNDLIST_EMPTY" ],
		"description" : "Indicates that the sound list is empty. See CSoundEnt."
	},
	"const int SOUNDLISTTYPE_FREE": {
		"prefix": "SOUNDLISTTYPE_FREE",
		"body" : [ "SOUNDLISTTYPE_FREE" ],
		"description" : "Identifiers passed to functions that can operate on either list, to indicate which list to operate on. See CSoundEnt."
	},
	"const int SOUNDLISTTYPE_ACTIVE": {
		"prefix": "SOUNDLISTTYPE_ACTIVE",
		"body" : [ "SOUNDLISTTYPE_ACTIVE" ],
		"description" : "Identifiers passed to functions that can operate on either list, to indicate which list to operate on. See CSoundEnt."
	},
	"const int SOUND_NEVER_EXPIRE": {
		"prefix": "SOUND_NEVER_EXPIRE",
		"body" : [ "SOUND_NEVER_EXPIRE" ],
		"description" : "With this set as a sound's ExpireTime, the sound will never expire. See CSoundEnt."
	},
	"CInventoryMisc g_InventoryMisc": {
		"prefix": "g_InventoryMisc",
		"body" : [ "g_InventoryMisc" ],
		"description" : "Inventory misc functions instance"
	},
	"const int LOUD_GUN_VOLUME": {
		"prefix": "LOUD_GUN_VOLUME",
		"body" : [ "LOUD_GUN_VOLUME" ],
		"description" : "Parameter for CSoundEnt::InsertSound iVolume"
	},
	"const int NORMAL_GUN_VOLUME": {
		"prefix": "NORMAL_GUN_VOLUME",
		"body" : [ "NORMAL_GUN_VOLUME" ],
		"description" : "Parameter for CSoundEnt::InsertSound iVolume"
	},
	"const int QUIET_GUN_VOLUME": {
		"prefix": "QUIET_GUN_VOLUME",
		"body" : [ "QUIET_GUN_VOLUME" ],
		"description" : "Parameter for CSoundEnt::InsertSound iVolume"
	},
	"const int BRIGHT_GUN_FLASH": {
		"prefix": "BRIGHT_GUN_FLASH",
		"body" : [ "BRIGHT_GUN_FLASH" ],
		"description" : "Value used in CBasePlayer::m_iWeaponFlash"
	},
	"const int NORMAL_GUN_FLASH": {
		"prefix": "NORMAL_GUN_FLASH",
		"body" : [ "NORMAL_GUN_FLASH" ],
		"description" : "Value used in CBasePlayer::m_iWeaponFlash"
	},
	"const int DIM_GUN_FLASH": {
		"prefix": "DIM_GUN_FLASH",
		"body" : [ "DIM_GUN_FLASH" ],
		"description" : "Value used in CBasePlayer::m_iWeaponFlash"
	},
	"const int BIG_EXPLOSION_VOLUME": {
		"prefix": "BIG_EXPLOSION_VOLUME",
		"body" : [ "BIG_EXPLOSION_VOLUME" ],
		"description" : "Parameter for CSoundEnt::InsertSound iVolume"
	},
	"const int NORMAL_EXPLOSION_VOLUME": {
		"prefix": "NORMAL_EXPLOSION_VOLUME",
		"body" : [ "NORMAL_EXPLOSION_VOLUME" ],
		"description" : "Parameter for CSoundEnt::InsertSound iVolume"
	},
	"const int SMALL_EXPLOSION_VOLUME": {
		"prefix": "SMALL_EXPLOSION_VOLUME",
		"body" : [ "SMALL_EXPLOSION_VOLUME" ],
		"description" : "Parameter for CSoundEnt::InsertSound iVolume"
	},
	"const int WEAPON_ACTIVITY_VOLUME": {
		"prefix": "WEAPON_ACTIVITY_VOLUME",
		"body" : [ "WEAPON_ACTIVITY_VOLUME" ],
		"description" : "Parameter for CSoundEnt::InsertSound iVolume"
	},
	"const Vector VECTOR_CONE_1DEGREES": {
		"prefix": "VECTOR_CONE_1DEGREES",
		"body" : [ "VECTOR_CONE_1DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_2DEGREES": {
		"prefix": "VECTOR_CONE_2DEGREES",
		"body" : [ "VECTOR_CONE_2DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_3DEGREES": {
		"prefix": "VECTOR_CONE_3DEGREES",
		"body" : [ "VECTOR_CONE_3DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_4DEGREES": {
		"prefix": "VECTOR_CONE_4DEGREES",
		"body" : [ "VECTOR_CONE_4DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_5DEGREES": {
		"prefix": "VECTOR_CONE_5DEGREES",
		"body" : [ "VECTOR_CONE_5DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_6DEGREES": {
		"prefix": "VECTOR_CONE_6DEGREES",
		"body" : [ "VECTOR_CONE_6DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_7DEGREES": {
		"prefix": "VECTOR_CONE_7DEGREES",
		"body" : [ "VECTOR_CONE_7DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_8DEGREES": {
		"prefix": "VECTOR_CONE_8DEGREES",
		"body" : [ "VECTOR_CONE_8DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_9DEGREES": {
		"prefix": "VECTOR_CONE_9DEGREES",
		"body" : [ "VECTOR_CONE_9DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_10DEGREES": {
		"prefix": "VECTOR_CONE_10DEGREES",
		"body" : [ "VECTOR_CONE_10DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_15DEGREES": {
		"prefix": "VECTOR_CONE_15DEGREES",
		"body" : [ "VECTOR_CONE_15DEGREES" ],
		"description" : ""
	},
	"const Vector VECTOR_CONE_20DEGREES": {
		"prefix": "VECTOR_CONE_20DEGREES",
		"body" : [ "VECTOR_CONE_20DEGREES" ],
		"description" : ""
	},
	"const int WEAPON_NOCLIP": {
		"prefix": "WEAPON_NOCLIP",
		"body" : [ "WEAPON_NOCLIP" ],
		"description" : "Used for clips that don't use ammo."
	},
	"CItemRegistry g_ItemRegistry": {
		"prefix": "g_ItemRegistry",
		"body" : [ "g_ItemRegistry" ],
		"description" : "Item registry global instance."
	},
	"CEntityLoader g_EntityLoader": {
		"prefix": "g_EntityLoader",
		"body" : [ "g_EntityLoader" ],
		"description" : "Entity loader global instance"
	},
	"CCustomEntityFuncs g_CustomEntityFuncs": {
		"prefix": "g_CustomEntityFuncs",
		"body" : [ "g_CustomEntityFuncs" ],
		"description" : "Custom entity functions global instance."
	},
	"CUtility g_Utility": {
		"prefix": "g_Utility",
		"body" : [ "g_Utility" ],
		"description" : "Utility methods instance"
	},
	"CGame g_Game": {
		"prefix": "g_Game",
		"body" : [ "g_Game" ],
		"description" : "Game functions instance"
	},
	"const float ATTN_NONE": {
		"prefix": "ATTN_NONE",
		"body" : [ "ATTN_NONE" ],
		"description" : ""
	},
	"const float ATTN_NORM": {
		"prefix": "ATTN_NORM",
		"body" : [ "ATTN_NORM" ],
		"description" : ""
	},
	"const float ATTN_IDLE": {
		"prefix": "ATTN_IDLE",
		"body" : [ "ATTN_IDLE" ],
		"description" : ""
	},
	"const float ATTN_STATIC": {
		"prefix": "ATTN_STATIC",
		"body" : [ "ATTN_STATIC" ],
		"description" : ""
	},
	"const float VOL_NORM": {
		"prefix": "VOL_NORM",
		"body" : [ "VOL_NORM" ],
		"description" : "Volume value normal"
	},
	"CSoundEngine g_SoundSystem": {
		"prefix": "g_SoundSystem",
		"body" : [ "g_SoundSystem" ],
		"description" : "Sound engine instance"
	},
	"CEngine g_Engine": {
		"prefix": "g_Engine",
		"body" : [ "g_Engine" ],
		"description" : "Engine global variables instance"
	},
	"const uint FTRACE_SIMPLEBOX": {
		"prefix": "FTRACE_SIMPLEBOX",
		"body" : [ "FTRACE_SIMPLEBOX" ],
		"description" : "Goes into g_Engine.trace_flags. Traceline with a simple box"
	},
	"CEntityFuncs g_EntityFuncs": {
		"prefix": "g_EntityFuncs",
		"body" : [ "g_EntityFuncs" ],
		"description" : "Global entity functions instance"
	},
	"const RGBA RGBA_WHITE": {
		"prefix": "RGBA_WHITE",
		"body" : [ "RGBA_WHITE" ],
		"description" : "White"
	},
	"const RGBA RGBA_BLACK": {
		"prefix": "RGBA_BLACK",
		"body" : [ "RGBA_BLACK" ],
		"description" : "Black"
	},
	"const RGBA RGBA_RED": {
		"prefix": "RGBA_RED",
		"body" : [ "RGBA_RED" ],
		"description" : "Red"
	},
	"const RGBA RGBA_GREEN": {
		"prefix": "RGBA_GREEN",
		"body" : [ "RGBA_GREEN" ],
		"description" : "Green"
	},
	"const RGBA RGBA_BLUE": {
		"prefix": "RGBA_BLUE",
		"body" : [ "RGBA_BLUE" ],
		"description" : "Blue"
	},
	"const RGBA RGBA_YELLOW": {
		"prefix": "RGBA_YELLOW",
		"body" : [ "RGBA_YELLOW" ],
		"description" : "Yellow"
	},
	"const RGBA RGBA_ORANGE": {
		"prefix": "RGBA_ORANGE",
		"body" : [ "RGBA_ORANGE" ],
		"description" : "Orange"
	},
	"const RGBA RGBA_SVENCOOP": {
		"prefix": "RGBA_SVENCOOP",
		"body" : [ "RGBA_SVENCOOP" ],
		"description" : "Sven Co-op HUD color"
	},
	"CPlayerFuncs g_PlayerFuncs": {
		"prefix": "g_PlayerFuncs",
		"body" : [ "g_PlayerFuncs" ],
		"description" : "Global player functions instance"
	},
	"CWeaponFuncs g_WeaponFuncs": {
		"prefix": "g_WeaponFuncs",
		"body" : [ "g_WeaponFuncs" ],
		"description" : "Weapon functions global instance."
	},
	"CGlobalState g_GlobalState": {
		"prefix": "g_GlobalState",
		"body" : [ "g_GlobalState" ],
		"description" : "Global state manager instance"
	},
	"CAngelscript g_Angelscript": {
		"prefix": "g_Angelscript",
		"body" : [ "g_Angelscript" ],
		"description" : "Angelscript debugging functions instance"
	},
	"CMapCycle g_MapCycle": {
		"prefix": "g_MapCycle",
		"body" : [ "g_MapCycle" ],
		"description" : "Map cycle manager instance"
	},
	"CMap g_Map": {
		"prefix": "g_Map",
		"body" : [ "g_Map" ],
		"description" : "Map state variables instance"
	},
	"CPluginManager g_PluginManager": {
		"prefix": "g_PluginManager",
		"body" : [ "g_PluginManager" ],
		"description" : "Plugin manager global instance."
	},
	"CStartInventory g_StartInventory": {
		"prefix": "g_StartInventory",
		"body" : [ "g_StartInventory" ],
		"description" : "Player start inventory manager instance"
	},
	"CTextMenus g_TextMenus": {
		"prefix": "g_TextMenus",
		"body" : [ "g_TextMenus" ],
		"description" : "Text menu manager global instance"
	},
	"CAdminControl g_AdminControl": {
		"prefix": "g_AdminControl",
		"body" : [ "g_AdminControl" ],
		"description" : "CAdminControl instance for plugins"
	},
	"CLog g_Log": {
		"prefix": "g_Log",
		"body" : [ "g_Log" ],
		"description" : "Log global instance"
	},
	"CConCommandSystem g_ConCommandSystem": {
		"prefix": "g_ConCommandSystem",
		"body" : [ "g_ConCommandSystem" ],
		"description" : "CConCommandSystem global instance"
	},
	"CClassicMode g_ClassicMode": {
		"prefix": "g_ClassicMode",
		"body" : [ "g_ClassicMode" ],
		"description" : "Classic Mode global instance."
	},
	"CSurvivalMode g_SurvivalMode": {
		"prefix": "g_SurvivalMode",
		"body" : [ "g_SurvivalMode" ],
		"description" : "Survival Mode global instance."
	},
	"const uint32 Hooks::Weapon::WeaponTertiaryAttack": {
		"prefix": "WeaponTertiaryAttack",
		"body" : [ "Hooks::Weapon::WeaponTertiaryAttack" ],
		"description" : "Called when a player fires a weapon's tertiary attack."
	},
	"const uint32 Hooks::Weapon::WeaponSecondaryAttack": {
		"prefix": "WeaponSecondaryAttack",
		"body" : [ "Hooks::Weapon::WeaponSecondaryAttack" ],
		"description" : "Called when a player fires a weapon's secondary attack."
	},
	"const uint32 Hooks::Weapon::WeaponPrimaryAttack": {
		"prefix": "WeaponPrimaryAttack",
		"body" : [ "Hooks::Weapon::WeaponPrimaryAttack" ],
		"description" : "Called when a player fires a weapon's primary attack."
	},
	"const uint32 Hooks::Player::PlayerPreDecal": {
		"prefix": "PlayerPreDecal",
		"body" : [ "Hooks::Player::PlayerPreDecal" ],
		"description" : "Called when a player attempts to spraypaint a decal onto a surface. The given trace result contains the surface information. Set bResult to false if the player shouldn't be able to spray. "
	},
	"const uint32 Hooks::Player::PlayerDecal": {
		"prefix": "PlayerDecal",
		"body" : [ "Hooks::Player::PlayerDecal" ],
		"description" : "Called when a player is spraypainting a decal onto a surface. The given trace result contains the surface information. "
	},
	"const uint32 Hooks::Player::GetPlayerSpawnSpot": {
		"prefix": "GetPlayerSpawnSpot",
		"body" : [ "Hooks::Player::GetPlayerSpawnSpot" ],
		"description" : "Called when a player is about to get a spawn point before (re)spawning."
	},
	"const uint32 Hooks::Player::PlayerPostThink": {
		"prefix": "PlayerPostThink",
		"body" : [ "Hooks::Player::PlayerPostThink" ],
		"description" : "Called when the player is processing post think events."
	},
	"const uint32 Hooks::Player::PlayerPreThink": {
		"prefix": "PlayerPreThink",
		"body" : [ "Hooks::Player::PlayerPreThink" ],
		"description" : "Called when the player is processing pre think events."
	},
	"const uint32 Hooks::Player::PlayerUse": {
		"prefix": "PlayerUse",
		"body" : [ "Hooks::Player::PlayerUse" ],
		"description" : "Called when the game is processing player use input. Note that this occurs even if the player has not pressed their use key."
	},
	"const uint32 Hooks::Player::PlayerLeftObserver": {
		"prefix": "PlayerLeftObserver",
		"body" : [ "Hooks::Player::PlayerLeftObserver" ],
		"description" : "Called when a player leaves observer mode."
	},
	"const uint32 Hooks::Player::PlayerEnteredObserver": {
		"prefix": "PlayerEnteredObserver",
		"body" : [ "Hooks::Player::PlayerEnteredObserver" ],
		"description" : "Called when a player enters observer mode."
	},
	"const uint32 Hooks::Player::PlayerKilled": {
		"prefix": "PlayerKilled",
		"body" : [ "Hooks::Player::PlayerKilled" ],
		"description" : "Called when a player is killed."
	},
	"const uint32 Hooks::Player::PlayerTakeDamage": {
		"prefix": "PlayerTakeDamage",
		"body" : [ "Hooks::Player::PlayerTakeDamage" ],
		"description" : "Called when a player takes damage. Note that the victim entity can't be changed at this point."
	},
	"const uint32 Hooks::Player::PlayerCanRespawn": {
		"prefix": "PlayerCanRespawn",
		"body" : [ "Hooks::Player::PlayerCanRespawn" ],
		"description" : "Called when the game wants to know if the player should be able to respawn or not.Set bCanRespawn to false to disallow, default true."
	},
	"const uint32 Hooks::Player::PlayerSpawn": {
		"prefix": "PlayerSpawn",
		"body" : [ "Hooks::Player::PlayerSpawn" ],
		"description" : "Called when a player (re)spawns."
	},
	"const uint32 Hooks::Player::ClientConnected": {
		"prefix": "ClientConnected",
		"body" : [ "Hooks::Player::ClientConnected" ],
		"description" : "Called when a player connects to the server. if bDisallowJoin is set to false, the player is disconnected. szRejectReason is shown to the player if disconnected. The maximum length of the reject reason string is 127 characters."
	},
	"const uint32 Hooks::PickupObject::Collected": {
		"prefix": "Collected",
		"body" : [ "Hooks::PickupObject::Collected" ],
		"description" : "Called when a pickup object is collected by a player. "
	},
	"const uint32 Hooks::PickupObject::Materialize": {
		"prefix": "Materialize",
		"body" : [ "Hooks::PickupObject::Materialize" ],
		"description" : "Called when a pickup object materializes."
	},
	"const uint32 Hooks::PickupObject::CanCollect": {
		"prefix": "CanCollect",
		"body" : [ "Hooks::PickupObject::CanCollect" ],
		"description" : "Called when a pickup object is about to be collected by a player. Note that basic checks are done before this hook is called."
	},
	"const uint32 Hooks::Player::CanPlayerUseReservedSlot": {
		"prefix": "CanPlayerUseReservedSlot",
		"body" : [ "Hooks::Player::CanPlayerUseReservedSlot" ],
		"description" : "Called when a player connects to the server, and the number of slots left on the server is <= the number of reserved slots. Set bAllowJoin to true to allow the player to join (default false)."
	},
	"const uint32 Hooks::Player::ClientSay": {
		"prefix": "ClientSay",
		"body" : [ "Hooks::Player::ClientSay" ],
		"description" : "Called when a player says something in game chat. The SayParameters class can be used to manipulate input and veto the message."
	},
	"const uint32 Hooks::Player::ClientPutInServer": {
		"prefix": "ClientPutInServer",
		"body" : [ "Hooks::Player::ClientPutInServer" ],
		"description" : "Called when a player has finished connecting and is put into the world. It is safe to send network messages to the player at this point."
	},
	"const uint32 Hooks::Player::ClientDisconnect": {
		"prefix": "ClientDisconnect",
		"body" : [ "Hooks::Player::ClientDisconnect" ],
		"description" : "Called when a player disconnects. Note that this is only called if the player was fully connected, meaning the player went through ClientPutInServer. This is never called for the local host."
	},
	"const uint32 Hooks::Game::EntityCreated": {
		"prefix": "EntityCreated",
		"body" : [ "Hooks::Game::EntityCreated" ],
		"description" : "Called when a new entity is created. At this point the entity is not spawned yet and may not be fully initialized."
	},
	"const uint32 Hooks::Game::MapChange": {
		"prefix": "MapChange",
		"body" : [ "Hooks::Game::MapChange" ],
		"description" : "Called when the map changes. This happens when the world is destroyed. There may still be entities that exist at this point."
	},
	"Regex@ Regex::Regex::Regex()": {
		"prefix": "Regex",
		"body" : [ "Regex()" ],
		"description" : "Default Constructor"
	},
	"Regex@ Regex::Regex::Regex(const Regex@ pOther)": {
		"prefix": "Regex",
		"body" : [ "Regex( ${1:const Regex@ pOther} )" ],
		"description" : "Copy Constructor"
	},
	"Regex@ Regex::Regex::Regex(const string& in szExpression, FlagType flags = Regex::ECMAScript)": {
		"prefix": "Regex",
		"body" : [ "Regex( ${1:const string& in szExpression}, ${2:FlagType flags = Regex::ECMAScript} )" ],
		"description" : "Initialization Constructor"
	},
	"Regex& Regex::Regex::Assign(const Regex@ pOther)": {
		"prefix": "Assign",
		"body" : [ "Assign( ${1:const Regex@ pOther} )" ],
		"description" : "Assigns the given regular expression to this one."
	},
	"Regex& Regex::Regex::Assign(const string& in szExpression, FlagType flags = Regex::ECMAScript)": {
		"prefix": "Assign",
		"body" : [ "Assign( ${1:const string& in szExpression}, ${2:FlagType flags = Regex::ECMAScript} )" ],
		"description" : "Assigns the given regular expression to this one."
	},
	"uint Regex::Regex::GetMarkCount() const": {
		"prefix": "GetMarkCount",
		"body" : [ "GetMarkCount()" ],
		"description" : "Gets the mark count"
	},
	"FlagType Regex::Regex::GetFlags() const": {
		"prefix": "GetFlags",
		"body" : [ "GetFlags()" ],
		"description" : "Gets this regex's flags"
	},
	"void Regex::Regex::Swap(Regex@ other)": {
		"prefix": "Swap",
		"body" : [ "Swap( ${1:Regex@ other} )" ],
		"description" : "Swaps this regular expression's contents with the given expression"
	},
	"enum RELATIONSHIP {..., R_AL, ...}": {
		"prefix": "R_AL",
		"body" : [ "R_AL" ],
		"description" : "(-2) Ally. Good alternative to R_NO when applicable."
	},
	"enum RELATIONSHIP {..., R_NO, ...}": {
		"prefix": "R_NO",
		"body" : [ "R_NO" ],
		"description" : "(0) No relationship. Disregard."
	},
	"enum RELATIONSHIP {..., R_DL, ...}": {
		"prefix": "R_DL",
		"body" : [ "R_DL" ],
		"description" : "(1) Dislike. Will attack."
	},
	"enum RELATIONSHIP {..., R_HT, ...}": {
		"prefix": "R_HT",
		"body" : [ "R_HT" ],
		"description" : "(2) Hate. Will attack this character instead of any DISLIKE'd characters."
	},
	"enum RELATIONSHIP {..., R_NM, ...}": {
		"prefix": "R_NM",
		"body" : [ "R_NM" ],
		"description" : "(3) Nemesis. A monster will ALWAYS attack its nemesis, no matter what."
	},
	"enum RELATIONSHIP {..., R_FR, ...}": {
		"prefix": "R_FR",
		"body" : [ "R_FR" ],
		"description" : "(4) Fear. Will attack."
	},
	"enum RenderFX {..., kRenderFxNone, ...}": {
		"prefix": "kRenderFxNone",
		"body" : [ "kRenderFxNone" ],
		"description" : "(0)"
	},
	"enum RenderFX {..., kRenderFxPulseSlow, ...}": {
		"prefix": "kRenderFxPulseSlow",
		"body" : [ "kRenderFxPulseSlow" ],
		"description" : "(1)"
	},
	"enum RenderFX {..., kRenderFxPulseFast, ...}": {
		"prefix": "kRenderFxPulseFast",
		"body" : [ "kRenderFxPulseFast" ],
		"description" : "(2)"
	},
	"enum RenderFX {..., kRenderFxPulseSlowWide, ...}": {
		"prefix": "kRenderFxPulseSlowWide",
		"body" : [ "kRenderFxPulseSlowWide" ],
		"description" : "(3)"
	},
	"enum RenderFX {..., kRenderFxPulseFastWide, ...}": {
		"prefix": "kRenderFxPulseFastWide",
		"body" : [ "kRenderFxPulseFastWide" ],
		"description" : "(4)"
	},
	"enum RenderFX {..., kRenderFxFadeSlow, ...}": {
		"prefix": "kRenderFxFadeSlow",
		"body" : [ "kRenderFxFadeSlow" ],
		"description" : "(5)"
	},
	"enum RenderFX {..., kRenderFxFadeFast, ...}": {
		"prefix": "kRenderFxFadeFast",
		"body" : [ "kRenderFxFadeFast" ],
		"description" : "(6)"
	},
	"enum RenderFX {..., kRenderFxSolidSlow, ...}": {
		"prefix": "kRenderFxSolidSlow",
		"body" : [ "kRenderFxSolidSlow" ],
		"description" : "(7)"
	},
	"enum RenderFX {..., kRenderFxSolidFast, ...}": {
		"prefix": "kRenderFxSolidFast",
		"body" : [ "kRenderFxSolidFast" ],
		"description" : "(8)"
	},
	"enum RenderFX {..., kRenderFxStrobeSlow, ...}": {
		"prefix": "kRenderFxStrobeSlow",
		"body" : [ "kRenderFxStrobeSlow" ],
		"description" : "(9)"
	},
	"enum RenderFX {..., kRenderFxStrobeFast, ...}": {
		"prefix": "kRenderFxStrobeFast",
		"body" : [ "kRenderFxStrobeFast" ],
		"description" : "(10)"
	},
	"enum RenderFX {..., kRenderFxStrobeFaster, ...}": {
		"prefix": "kRenderFxStrobeFaster",
		"body" : [ "kRenderFxStrobeFaster" ],
		"description" : "(11)"
	},
	"enum RenderFX {..., kRenderFxFlickerSlow, ...}": {
		"prefix": "kRenderFxFlickerSlow",
		"body" : [ "kRenderFxFlickerSlow" ],
		"description" : "(12)"
	},
	"enum RenderFX {..., kRenderFxFlickerFast, ...}": {
		"prefix": "kRenderFxFlickerFast",
		"body" : [ "kRenderFxFlickerFast" ],
		"description" : "(13)"
	},
	"enum RenderFX {..., kRenderFxNoDissipation, ...}": {
		"prefix": "kRenderFxNoDissipation",
		"body" : [ "kRenderFxNoDissipation" ],
		"description" : "(14)"
	},
	"enum RenderFX {..., kRenderFxDistort, ...}": {
		"prefix": "kRenderFxDistort",
		"body" : [ "kRenderFxDistort" ],
		"description" : "(15) Distort/scale/translate flicker"
	},
	"enum RenderFX {..., kRenderFxHologram, ...}": {
		"prefix": "kRenderFxHologram",
		"body" : [ "kRenderFxHologram" ],
		"description" : "(16) kRenderFxDistort + distance fade"
	},
	"enum RenderFX {..., kRenderFxDeadPlayer, ...}": {
		"prefix": "kRenderFxDeadPlayer",
		"body" : [ "kRenderFxDeadPlayer" ],
		"description" : "(17) kRenderAmt is the player index"
	},
	"enum RenderFX {..., kRenderFxExplode, ...}": {
		"prefix": "kRenderFxExplode",
		"body" : [ "kRenderFxExplode" ],
		"description" : "(18) Scale up really big!"
	},
	"enum RenderFX {..., kRenderFxGlowShell, ...}": {
		"prefix": "kRenderFxGlowShell",
		"body" : [ "kRenderFxGlowShell" ],
		"description" : "(19) Glowing Shell"
	},
	"enum RenderFX {..., kRenderFxClampMinScale, ...}": {
		"prefix": "kRenderFxClampMinScale",
		"body" : [ "kRenderFxClampMinScale" ],
		"description" : "(20) Keep this sprite from getting very small (SPRITES only!)"
	},
	"enum RenderModes {..., kRenderNormal, ...}": {
		"prefix": "kRenderNormal",
		"body" : [ "kRenderNormal" ],
		"description" : "(0) src"
	},
	"enum RenderModes {..., kRenderTransColor, ...}": {
		"prefix": "kRenderTransColor",
		"body" : [ "kRenderTransColor" ],
		"description" : "(1) c*a+dest*(1-a)"
	},
	"enum RenderModes {..., kRenderTransTexture, ...}": {
		"prefix": "kRenderTransTexture",
		"body" : [ "kRenderTransTexture" ],
		"description" : "(2) src*a+dest*(1-a)"
	},
	"enum RenderModes {..., kRenderGlow, ...}": {
		"prefix": "kRenderGlow",
		"body" : [ "kRenderGlow" ],
		"description" : "(3) src*a+dest -- No Z buffer checks"
	},
	"enum RenderModes {..., kRenderTransAlpha, ...}": {
		"prefix": "kRenderTransAlpha",
		"body" : [ "kRenderTransAlpha" ],
		"description" : "(4) src*srca+dest*(1-srca)"
	},
	"enum RenderModes {..., kRenderTransAdd, ...}": {
		"prefix": "kRenderTransAdd",
		"body" : [ "kRenderTransAdd" ],
		"description" : "(5) src*a+dest"
	},
	"bool Reflection::ReturnValue::HasReturnValue() const": {
		"prefix": "HasReturnValue",
		"body" : [ "HasReturnValue()" ],
		"description" : "Returns whether there is a return value or not."
	},
	"any@ Reflection::ReturnValue::ToAny() const": {
		"prefix": "ToAny",
		"body" : [ "ToAny()" ],
		"description" : "Returns the return value as an any instance, if there was a return value."
	},
	"void RGBA::RGBA()": {
		"prefix": "RGBA",
		"body" : [ "RGBA()" ],
		"description" : "Constructor"
	},
	"void RGBA::RGBA(uint8 r, uint8 g, uint8 b, uint8 a = 255)": {
		"prefix": "RGBA",
		"body" : [ "RGBA( ${1:uint8 r}, ${2:uint8 g}, ${3:uint8 b}, ${4:uint8 a = 255} )" ],
		"description" : "Constructor"
	},
	"void RGBA::RGBA(const RGBA& in other)": {
		"prefix": "RGBA",
		"body" : [ "RGBA( ${1:const RGBA& in other} )" ],
		"description" : "Copy constructor"
	},
	"RGBA& RGBA::opAssign(const RGBA& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const RGBA& in other} )" ],
		"description" : "Assignment operator"
	},
	"uint8 RGBA::r": {
		"prefix": "r",
		"body" : [ "r" ],
		"description" : "Red component"
	},
	"uint8 RGBA::g": {
		"prefix": "g",
		"body" : [ "g" ],
		"description" : "Green component"
	},
	"uint8 RGBA::b": {
		"prefix": "b",
		"body" : [ "b" ],
		"description" : "Blue component"
	},
	"uint8 RGBA::a": {
		"prefix": "a",
		"body" : [ "a" ],
		"description" : "Alpha component"
	},
	"enum SATCHELCODE {..., SATCHEL_DETONATE, ...}": {
		"prefix": "SATCHEL_DETONATE",
		"body" : [ "SATCHEL_DETONATE" ],
		"description" : "(0) Detonates all satchel charges owned by a player"
	},
	"enum SATCHELCODE {..., SATCHEL_RELEASE, ...}": {
		"prefix": "SATCHEL_RELEASE",
		"body" : [ "SATCHEL_RELEASE" ],
		"description" : "(1) Release all satches charges owner by a player from their owner"
	},
	"CBasePlayer@ SayParameters::GetPlayer() const": {
		"prefix": "GetPlayer",
		"body" : [ "GetPlayer()" ],
		"description" : "Gets the player that is saying something"
	},
	"ClientSayType SayParameters::GetSayType() const": {
		"prefix": "GetSayType",
		"body" : [ "GetSayType()" ],
		"description" : "Gets the say type of this text"
	},
	"const string& SayParameters::GetCommand() const": {
		"prefix": "GetCommand",
		"body" : [ "GetCommand()" ],
		"description" : "Gets the entire command string"
	},
	"const CCommand@ SayParameters::GetArguments() const": {
		"prefix": "GetArguments",
		"body" : [ "GetArguments()" ],
		"description" : "Gets the arguments in this command."
	},
	"bool SayParameters::get_ShouldHide() const": {
		"prefix": "get_ShouldHide",
		"body" : [ "get_ShouldHide()" ],
		"description" : "Gets whether this text will be hidden or not"
	},
	"void SayParameters::set_ShouldHide(bool fShouldHide)": {
		"prefix": "set_ShouldHide",
		"body" : [ "set_ShouldHide( ${1:bool fShouldHide} )" ],
		"description" : "Sets whether this text will be hidden or not"
	},
	"Task@ Schedule::GetTask(int iIndex) const": {
		"prefix": "GetTask",
		"body" : [ "GetTask( ${1:int iIndex} )" ],
		"description" : "Gets a task in this schedule. Must be between 0 and cTasks."
	},
	"string Schedule::szName() const": {
		"prefix": "szName",
		"body" : [ "szName()" ],
		"description" : "Gets the name of this schedule."
	},
	"int Schedule::cTasks": {
		"prefix": "cTasks",
		"body" : [ "cTasks" ],
		"description" : "Number of tasks in this schedule."
	},
	"int Schedule::iInterruptMask": {
		"prefix": "iInterruptMask",
		"body" : [ "iInterruptMask" ],
		"description" : "A bit mask of conditions that can interrupt this schedule."
	},
	"int Schedule::iSoundMask": {
		"prefix": "iSoundMask",
		"body" : [ "iSoundMask" ],
		"description" : "A more specific mask that indicates which TYPES of sounds will interrupt the schedule in the event that the schedule is broken by COND_HEAR_SOUND."
	},
	"enum SCHEDULE_TYPE {..., SCHED_NONE, ...}": {
		"prefix": "SCHED_NONE",
		"body" : [ "SCHED_NONE" ],
		"description" : "(0)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_IDLE_STAND, ...}": {
		"prefix": "SCHED_IDLE_STAND",
		"body" : [ "SCHED_IDLE_STAND" ],
		"description" : "(1)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_IDLE_WALK, ...}": {
		"prefix": "SCHED_IDLE_WALK",
		"body" : [ "SCHED_IDLE_WALK" ],
		"description" : "(2)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_WAKE_ANGRY, ...}": {
		"prefix": "SCHED_WAKE_ANGRY",
		"body" : [ "SCHED_WAKE_ANGRY" ],
		"description" : "(3)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_WAKE_CALLED, ...}": {
		"prefix": "SCHED_WAKE_CALLED",
		"body" : [ "SCHED_WAKE_CALLED" ],
		"description" : "(4)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_ALERT_FACE, ...}": {
		"prefix": "SCHED_ALERT_FACE",
		"body" : [ "SCHED_ALERT_FACE" ],
		"description" : "(5)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_ALERT_SMALL_FLINCH, ...}": {
		"prefix": "SCHED_ALERT_SMALL_FLINCH",
		"body" : [ "SCHED_ALERT_SMALL_FLINCH" ],
		"description" : "(6)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_ALERT_BIG_FLINCH, ...}": {
		"prefix": "SCHED_ALERT_BIG_FLINCH",
		"body" : [ "SCHED_ALERT_BIG_FLINCH" ],
		"description" : "(7)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_ALERT_STAND, ...}": {
		"prefix": "SCHED_ALERT_STAND",
		"body" : [ "SCHED_ALERT_STAND" ],
		"description" : "(8)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_INVESTIGATE_SOUND, ...}": {
		"prefix": "SCHED_INVESTIGATE_SOUND",
		"body" : [ "SCHED_INVESTIGATE_SOUND" ],
		"description" : "(9)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_INVESTIGATE_COMBAT, ...}": {
		"prefix": "SCHED_INVESTIGATE_COMBAT",
		"body" : [ "SCHED_INVESTIGATE_COMBAT" ],
		"description" : "(10)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_COMBAT_FACE, ...}": {
		"prefix": "SCHED_COMBAT_FACE",
		"body" : [ "SCHED_COMBAT_FACE" ],
		"description" : "(11)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_COMBAT_STAND, ...}": {
		"prefix": "SCHED_COMBAT_STAND",
		"body" : [ "SCHED_COMBAT_STAND" ],
		"description" : "(12)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_CHASE_ENEMY, ...}": {
		"prefix": "SCHED_CHASE_ENEMY",
		"body" : [ "SCHED_CHASE_ENEMY" ],
		"description" : "(13)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_CHASE_ENEMY_FAILED, ...}": {
		"prefix": "SCHED_CHASE_ENEMY_FAILED",
		"body" : [ "SCHED_CHASE_ENEMY_FAILED" ],
		"description" : "(14)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_VICTORY_DANCE, ...}": {
		"prefix": "SCHED_VICTORY_DANCE",
		"body" : [ "SCHED_VICTORY_DANCE" ],
		"description" : "(15)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TARGET_FACE, ...}": {
		"prefix": "SCHED_TARGET_FACE",
		"body" : [ "SCHED_TARGET_FACE" ],
		"description" : "(16)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TARGET_CHASE, ...}": {
		"prefix": "SCHED_TARGET_CHASE",
		"body" : [ "SCHED_TARGET_CHASE" ],
		"description" : "(17)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_SMALL_FLINCH, ...}": {
		"prefix": "SCHED_SMALL_FLINCH",
		"body" : [ "SCHED_SMALL_FLINCH" ],
		"description" : "(18)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TAKE_COVER_FROM_ENEMY, ...}": {
		"prefix": "SCHED_TAKE_COVER_FROM_ENEMY",
		"body" : [ "SCHED_TAKE_COVER_FROM_ENEMY" ],
		"description" : "(19)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TAKE_COVER_FROM_BEST_SOUND, ...}": {
		"prefix": "SCHED_TAKE_COVER_FROM_BEST_SOUND",
		"body" : [ "SCHED_TAKE_COVER_FROM_BEST_SOUND" ],
		"description" : "(20)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TAKE_COVER_FROM_ORIGIN, ...}": {
		"prefix": "SCHED_TAKE_COVER_FROM_ORIGIN",
		"body" : [ "SCHED_TAKE_COVER_FROM_ORIGIN" ],
		"description" : "(21)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_COWER, ...}": {
		"prefix": "SCHED_COWER",
		"body" : [ "SCHED_COWER" ],
		"description" : "(22)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_MELEE_ATTACK1, ...}": {
		"prefix": "SCHED_MELEE_ATTACK1",
		"body" : [ "SCHED_MELEE_ATTACK1" ],
		"description" : "(23)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_MELEE_ATTACK2, ...}": {
		"prefix": "SCHED_MELEE_ATTACK2",
		"body" : [ "SCHED_MELEE_ATTACK2" ],
		"description" : "(24)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_RANGE_ATTACK1, ...}": {
		"prefix": "SCHED_RANGE_ATTACK1",
		"body" : [ "SCHED_RANGE_ATTACK1" ],
		"description" : "(25)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_RANGE_ATTACK2, ...}": {
		"prefix": "SCHED_RANGE_ATTACK2",
		"body" : [ "SCHED_RANGE_ATTACK2" ],
		"description" : "(26)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_SPECIAL_ATTACK1, ...}": {
		"prefix": "SCHED_SPECIAL_ATTACK1",
		"body" : [ "SCHED_SPECIAL_ATTACK1" ],
		"description" : "(27)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_SPECIAL_ATTACK2, ...}": {
		"prefix": "SCHED_SPECIAL_ATTACK2",
		"body" : [ "SCHED_SPECIAL_ATTACK2" ],
		"description" : "(28)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_STANDOFF, ...}": {
		"prefix": "SCHED_STANDOFF",
		"body" : [ "SCHED_STANDOFF" ],
		"description" : "(29)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_ARM_WEAPON, ...}": {
		"prefix": "SCHED_ARM_WEAPON",
		"body" : [ "SCHED_ARM_WEAPON" ],
		"description" : "(30)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_RELOAD, ...}": {
		"prefix": "SCHED_RELOAD",
		"body" : [ "SCHED_RELOAD" ],
		"description" : "(31)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_GUARD, ...}": {
		"prefix": "SCHED_GUARD",
		"body" : [ "SCHED_GUARD" ],
		"description" : "(32)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_AMBUSH, ...}": {
		"prefix": "SCHED_AMBUSH",
		"body" : [ "SCHED_AMBUSH" ],
		"description" : "(33)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_DIE, ...}": {
		"prefix": "SCHED_DIE",
		"body" : [ "SCHED_DIE" ],
		"description" : "(34)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_WAIT_TRIGGER, ...}": {
		"prefix": "SCHED_WAIT_TRIGGER",
		"body" : [ "SCHED_WAIT_TRIGGER" ],
		"description" : "(35)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_WAIT_TILL_SEEN, ...}": {
		"prefix": "SCHED_WAIT_TILL_SEEN",
		"body" : [ "SCHED_WAIT_TILL_SEEN" ],
		"description" : "(36)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_FOLLOW, ...}": {
		"prefix": "SCHED_FOLLOW",
		"body" : [ "SCHED_FOLLOW" ],
		"description" : "(37)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_SLEEP, ...}": {
		"prefix": "SCHED_SLEEP",
		"body" : [ "SCHED_SLEEP" ],
		"description" : "(38)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_WAKE, ...}": {
		"prefix": "SCHED_WAKE",
		"body" : [ "SCHED_WAKE" ],
		"description" : "(39)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_BARNACLE_VICTIM_GRAB, ...}": {
		"prefix": "SCHED_BARNACLE_VICTIM_GRAB",
		"body" : [ "SCHED_BARNACLE_VICTIM_GRAB" ],
		"description" : "(40)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_BARNACLE_VICTIM_CHOMP, ...}": {
		"prefix": "SCHED_BARNACLE_VICTIM_CHOMP",
		"body" : [ "SCHED_BARNACLE_VICTIM_CHOMP" ],
		"description" : "(41)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_AISCRIPT, ...}": {
		"prefix": "SCHED_AISCRIPT",
		"body" : [ "SCHED_AISCRIPT" ],
		"description" : "(42)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_FAIL, ...}": {
		"prefix": "SCHED_FAIL",
		"body" : [ "SCHED_FAIL" ],
		"description" : "(43)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TARGET_PLAYERFACE, ...}": {
		"prefix": "SCHED_TARGET_PLAYERFACE",
		"body" : [ "SCHED_TARGET_PLAYERFACE" ],
		"description" : "(44)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TARGET_PLAYERCHASE, ...}": {
		"prefix": "SCHED_TARGET_PLAYERCHASE",
		"body" : [ "SCHED_TARGET_PLAYERCHASE" ],
		"description" : "(45)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TARGET_PLAYERCHASE_FORCE, ...}": {
		"prefix": "SCHED_TARGET_PLAYERCHASE_FORCE",
		"body" : [ "SCHED_TARGET_PLAYERCHASE_FORCE" ],
		"description" : "(46)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_MOVE_AWAY_PLAYERFOLLOW, ...}": {
		"prefix": "SCHED_MOVE_AWAY_PLAYERFOLLOW",
		"body" : [ "SCHED_MOVE_AWAY_PLAYERFOLLOW" ],
		"description" : "(47)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_MOVE_TO_TANK, ...}": {
		"prefix": "SCHED_MOVE_TO_TANK",
		"body" : [ "SCHED_MOVE_TO_TANK" ],
		"description" : "(48)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_WAIT_AT_TANK, ...}": {
		"prefix": "SCHED_WAIT_AT_TANK",
		"body" : [ "SCHED_WAIT_AT_TANK" ],
		"description" : "(49)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_FIND_ATTACK_POINT, ...}": {
		"prefix": "SCHED_FIND_ATTACK_POINT",
		"body" : [ "SCHED_FIND_ATTACK_POINT" ],
		"description" : "(50)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_LOSE_ENEMY, ...}": {
		"prefix": "SCHED_LOSE_ENEMY",
		"body" : [ "SCHED_LOSE_ENEMY" ],
		"description" : "(51)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_RANGE_ATTACK1_DEFAULT, ...}": {
		"prefix": "SCHED_RANGE_ATTACK1_DEFAULT",
		"body" : [ "SCHED_RANGE_ATTACK1_DEFAULT" ],
		"description" : "(52)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_SMALL_FLINCH_SPECIAL, ...}": {
		"prefix": "SCHED_SMALL_FLINCH_SPECIAL",
		"body" : [ "SCHED_SMALL_FLINCH_SPECIAL" ],
		"description" : "(53)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_TELEPORT_FALL, ...}": {
		"prefix": "SCHED_TELEPORT_FALL",
		"body" : [ "SCHED_TELEPORT_FALL" ],
		"description" : "(54)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_GUARD_POINT, ...}": {
		"prefix": "SCHED_GUARD_POINT",
		"body" : [ "SCHED_GUARD_POINT" ],
		"description" : "(55)"
	},
	"enum SCHEDULE_TYPE {..., SCHED_PATH_WAYPOINT, ...}": {
		"prefix": "SCHED_PATH_WAYPOINT",
		"body" : [ "SCHED_PATH_WAYPOINT" ],
		"description" : "(56)"
	},
	"enum SCHEDULE_TYPE {..., LAST_COMMON_SCHEDULE, ...}": {
		"prefix": "LAST_COMMON_SCHEDULE",
		"body" : [ "LAST_COMMON_SCHEDULE" ],
		"description" : "(57)"
	},
	"Task@ ScriptSchedule::GetTask(int iIndex) const": {
		"prefix": "GetTask",
		"body" : [ "GetTask( ${1:int iIndex} )" ],
		"description" : "Gets a task in this schedule. Must be between 0 and cTasks."
	},
	"string ScriptSchedule::szName() const": {
		"prefix": "szName",
		"body" : [ "szName()" ],
		"description" : "Gets the name of this schedule."
	},
	"ScriptSchedule@ ScriptSchedule::ScriptSchedule(int iInterruptMask, int iSoundMask, const string& in szName)": {
		"prefix": "ScriptSchedule",
		"body" : [ "ScriptSchedule( ${1:int iInterruptMask}, ${2:int iSoundMask}, ${3:const string& in szName} )" ],
		"description" : "Constructor"
	},
	"Schedule@ ScriptSchedule::opImplCast()": {
		"prefix": "opImplCast",
		"body" : [ "opImplCast()" ],
		"description" : "Cast to Schedule"
	},
	"void ScriptSchedule::AddTask(const ScriptTask& in task)": {
		"prefix": "AddTask",
		"body" : [ "AddTask( ${1:const ScriptTask& in task} )" ],
		"description" : "Adds a task to the list"
	},
	"int ScriptSchedule::cTasks": {
		"prefix": "cTasks",
		"body" : [ "cTasks" ],
		"description" : "Number of tasks in this schedule."
	},
	"int ScriptSchedule::iInterruptMask": {
		"prefix": "iInterruptMask",
		"body" : [ "iInterruptMask" ],
		"description" : "A bit mask of conditions that can interrupt this schedule."
	},
	"int ScriptSchedule::iSoundMask": {
		"prefix": "iSoundMask",
		"body" : [ "iSoundMask" ],
		"description" : "A more specific mask that indicates which TYPES of sounds will interrupt the schedule in the event that the schedule is broken by COND_HEAR_SOUND."
	},
	"enum SCRIPTSTATE {..., SCRIPT_PLAYING, ...}": {
		"prefix": "SCRIPT_PLAYING",
		"body" : [ "SCRIPT_PLAYING" ],
		"description" : "(0) Playing the sequence"
	},
	"enum SCRIPTSTATE {..., SCRIPT_WAIT, ...}": {
		"prefix": "SCRIPT_WAIT",
		"body" : [ "SCRIPT_WAIT" ],
		"description" : "(1) Waiting on everyone in the script to be ready"
	},
	"enum SCRIPTSTATE {..., SCRIPT_CLEANUP, ...}": {
		"prefix": "SCRIPT_CLEANUP",
		"body" : [ "SCRIPT_CLEANUP" ],
		"description" : "(2) Cancelling the script / cleaning up"
	},
	"enum SCRIPTSTATE {..., SCRIPT_WALK_TO_MARK, ...}": {
		"prefix": "SCRIPT_WALK_TO_MARK",
		"body" : [ "SCRIPT_WALK_TO_MARK" ],
		"description" : "(3) Walk to mark"
	},
	"enum SCRIPTSTATE {..., SCRIPT_RUN_TO_MARK, ...}": {
		"prefix": "SCRIPT_RUN_TO_MARK",
		"body" : [ "SCRIPT_RUN_TO_MARK" ],
		"description" : "(4) Run to mark"
	},
	"void ScriptTask::ScriptTask()": {
		"prefix": "ScriptTask",
		"body" : [ "ScriptTask()" ],
		"description" : "Constructor"
	},
	"void ScriptTask::ScriptTask(int iTask, float flData = 0.0f)": {
		"prefix": "ScriptTask",
		"body" : [ "ScriptTask( ${1:int iTask}, ${2:float flData = 0.0f} )" ],
		"description" : "Constructor"
	},
	"int ScriptTask::iTask": {
		"prefix": "iTask",
		"body" : [ "iTask" ],
		"description" : "Task to execute. Can be monster-specific."
	},
	"float ScriptTask::flData": {
		"prefix": "flData",
		"body" : [ "flData" ],
		"description" : "Task data"
	},
	"enum SeekFile::SeekFile {..., SET, ...}": {
		"prefix": "SET",
		"body" : [ "SeekFile::SET" ],
		"description" : "(0) Seek from the start of the file."
	},
	"enum SeekFile::SeekFile {..., CUR, ...}": {
		"prefix": "CUR",
		"body" : [ "SeekFile::CUR" ],
		"description" : "(1) Seek from the current offset in the file."
	},
	"enum SeekFile::SeekFile {..., END, ...}": {
		"prefix": "END",
		"body" : [ "SeekFile::END" ],
		"description" : "(2) Seek from the end of the file."
	},
	"enum SOLID {..., SOLID_NOT_EXPLICIT, ...}": {
		"prefix": "SOLID_NOT_EXPLICIT",
		"body" : [ "SOLID_NOT_EXPLICIT" ],
		"description" : "(-1) no interaction with other objects (forced by map)"
	},
	"enum SOLID {..., SOLID_NOT, ...}": {
		"prefix": "SOLID_NOT",
		"body" : [ "SOLID_NOT" ],
		"description" : "(0) no interaction with other objects"
	},
	"enum SOLID {..., SOLID_TRIGGER, ...}": {
		"prefix": "SOLID_TRIGGER",
		"body" : [ "SOLID_TRIGGER" ],
		"description" : "(1) touch on edge, but not blocking"
	},
	"enum SOLID {..., SOLID_BBOX, ...}": {
		"prefix": "SOLID_BBOX",
		"body" : [ "SOLID_BBOX" ],
		"description" : "(2) touch on edge, block"
	},
	"enum SOLID {..., SOLID_SLIDEBOX, ...}": {
		"prefix": "SOLID_SLIDEBOX",
		"body" : [ "SOLID_SLIDEBOX" ],
		"description" : "(3) touch on edge, but not an onground"
	},
	"enum SOLID {..., SOLID_BSP, ...}": {
		"prefix": "SOLID_BSP",
		"body" : [ "SOLID_BSP" ],
		"description" : "(4) bsp clip, touch on edge, block"
	},
	"enum SOUND_CHANNEL {..., CHAN_AUTO, ...}": {
		"prefix": "CHAN_AUTO",
		"body" : [ "CHAN_AUTO" ],
		"description" : "(0) Automatically selects a channel for use. You cannot stop sounds while using this channel with StopSound, or in conjunction with the SND_STOP flag."
	},
	"enum SOUND_CHANNEL {..., CHAN_WEAPON, ...}": {
		"prefix": "CHAN_WEAPON",
		"body" : [ "CHAN_WEAPON" ],
		"description" : "(1)"
	},
	"enum SOUND_CHANNEL {..., CHAN_VOICE, ...}": {
		"prefix": "CHAN_VOICE",
		"body" : [ "CHAN_VOICE" ],
		"description" : "(2)"
	},
	"enum SOUND_CHANNEL {..., CHAN_ITEM, ...}": {
		"prefix": "CHAN_ITEM",
		"body" : [ "CHAN_ITEM" ],
		"description" : "(3)"
	},
	"enum SOUND_CHANNEL {..., CHAN_BODY, ...}": {
		"prefix": "CHAN_BODY",
		"body" : [ "CHAN_BODY" ],
		"description" : "(4)"
	},
	"enum SOUND_CHANNEL {..., CHAN_STREAM, ...}": {
		"prefix": "CHAN_STREAM",
		"body" : [ "CHAN_STREAM" ],
		"description" : "(5) allocate stream channel from the static or dynamic area"
	},
	"enum SOUND_CHANNEL {..., CHAN_STATIC, ...}": {
		"prefix": "CHAN_STATIC",
		"body" : [ "CHAN_STATIC" ],
		"description" : "(6) allocate channel from the static area"
	},
	"enum SOUND_CHANNEL {..., CHAN_MUSIC, ...}": {
		"prefix": "CHAN_MUSIC",
		"body" : [ "CHAN_MUSIC" ],
		"description" : "(7)"
	},
	"enum SoundFlag {..., SND_VOLUME, ...}": {
		"prefix": "SND_VOLUME",
		"body" : [ "SND_VOLUME" ],
		"description" : "(1) Volume flag"
	},
	"enum SoundFlag {..., SND_PITCH, ...}": {
		"prefix": "SND_PITCH",
		"body" : [ "SND_PITCH" ],
		"description" : "(2) Pitch flag"
	},
	"enum SoundFlag {..., SND_ATTENUATION, ...}": {
		"prefix": "SND_ATTENUATION",
		"body" : [ "SND_ATTENUATION" ],
		"description" : "(4) Attenuation flag"
	},
	"enum SoundFlag {..., SND_ORIGIN, ...}": {
		"prefix": "SND_ORIGIN",
		"body" : [ "SND_ORIGIN" ],
		"description" : "(8) Origin flag"
	},
	"enum SoundFlag {..., SND_ENT, ...}": {
		"prefix": "SND_ENT",
		"body" : [ "SND_ENT" ],
		"description" : "(16) Entity flag"
	},
	"enum SoundFlag {..., SND_STOP, ...}": {
		"prefix": "SND_STOP",
		"body" : [ "SND_STOP" ],
		"description" : "(32) Stop flag"
	},
	"enum SoundFlag {..., SND_CHANGE_VOL, ...}": {
		"prefix": "SND_CHANGE_VOL",
		"body" : [ "SND_CHANGE_VOL" ],
		"description" : "(64) Change volume flag"
	},
	"enum SoundFlag {..., SND_CHANGE_PITCH, ...}": {
		"prefix": "SND_CHANGE_PITCH",
		"body" : [ "SND_CHANGE_PITCH" ],
		"description" : "(128) Change pitch flag"
	},
	"enum SoundFlag {..., SND_SENTENCE, ...}": {
		"prefix": "SND_SENTENCE",
		"body" : [ "SND_SENTENCE" ],
		"description" : "(256) Sentence flag"
	},
	"enum SoundFlag {..., SND_REFRESH, ...}": {
		"prefix": "SND_REFRESH",
		"body" : [ "SND_REFRESH" ],
		"description" : "(512) Refresh flag"
	},
	"enum SoundFlag {..., SND_FORCE_SINGLE, ...}": {
		"prefix": "SND_FORCE_SINGLE",
		"body" : [ "SND_FORCE_SINGLE" ],
		"description" : "(1024) Force single flag"
	},
	"enum SoundFlag {..., SND_FORCE_LOOP, ...}": {
		"prefix": "SND_FORCE_LOOP",
		"body" : [ "SND_FORCE_LOOP" ],
		"description" : "(2048) Force loop flag"
	},
	"enum SoundFlag {..., SND_LINEAR, ...}": {
		"prefix": "SND_LINEAR",
		"body" : [ "SND_LINEAR" ],
		"description" : "(4096) Linear flag"
	},
	"enum SoundFlag {..., SND_SKIP_ORIGIN_USE_ENT, ...}": {
		"prefix": "SND_SKIP_ORIGIN_USE_ENT",
		"body" : [ "SND_SKIP_ORIGIN_USE_ENT" ],
		"description" : "(8192) Skip Origin and use entity flag"
	},
	"void string::string()": {
		"prefix": "string",
		"body" : [ "string()" ],
		"description" : "Constructor"
	},
	"void string::string(const string& in szString)": {
		"prefix": "string",
		"body" : [ "string( ${1:const string& in szString} )" ],
		"description" : "Copy constructor"
	},
	"void string::string(double flValue)": {
		"prefix": "string",
		"body" : [ "string( ${1:double flValue} )" ],
		"description" : "Construct a string from a double."
	},
	"void string::string(int64 iValue)": {
		"prefix": "string",
		"body" : [ "string( ${1:int64 iValue} )" ],
		"description" : "Construct a string from a 64 bit integer."
	},
	"void string::string(uint64 uiValue)": {
		"prefix": "string",
		"body" : [ "string( ${1:uint64 uiValue} )" ],
		"description" : "Construct a string from a 64 bit unsigned integer."
	},
	"void string::string(bool bValue)": {
		"prefix": "string",
		"body" : [ "string( ${1:bool bValue} )" ],
		"description" : "Construct a string from a boolean."
	},
	"void string::string(char character)": {
		"prefix": "string",
		"body" : [ "string( ${1:char character} )" ],
		"description" : "Construct a string from a char."
	},
	"string& string::Assign(const string& in szString, uint uiBegin, uint uiCount)": {
		"prefix": "Assign",
		"body" : [ "Assign( ${1:const string& in szString}, ${2:uint uiBegin}, ${3:uint uiCount} )" ],
		"description" : "Assigns a string to this, copying up to uiCount characters."
	},
	"string& string::opAssign(const string& in szString)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const string& in szString} )" ],
		"description" : "Assigns a string to this one."
	},
	"string& string::opAssign(double flValue)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:double flValue} )" ],
		"description" : "Assigns a double to this string."
	},
	"string& string::opAssign(int64 iValue)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:int64 iValue} )" ],
		"description" : "Assigns a 64 bit integer to this string."
	},
	"string& string::opAssign(uint64 uiValue)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:uint64 uiValue} )" ],
		"description" : "Assigns a 64 bit unsigned int to this string."
	},
	"string& string::opAssign(bool bValue)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:bool bValue} )" ],
		"description" : "Assigns a boolean to this string."
	},
	"string& string::opAssign(char character)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:char character} )" ],
		"description" : "Assigns a character to this string."
	},
	"uint string::Length() const": {
		"prefix": "Length",
		"body" : [ "Length()" ],
		"description" : "Gets the length of this string."
	},
	"bool string::IsEmpty() const": {
		"prefix": "IsEmpty",
		"body" : [ "IsEmpty()" ],
		"description" : "Returns whether this string is empty."
	},
	"void string::Resize(uint uiSize, bool bKeepData = true)": {
		"prefix": "Resize",
		"body" : [ "Resize( ${1:uint uiSize}, ${2:bool bKeepData = true} )" ],
		"description" : "Shrinks this string to uiSize. If bKeepData is true, the original string is kept."
	},
	"void string::Reserve(uint iMinimum, bool bKeepData = true)": {
		"prefix": "Reserve",
		"body" : [ "Reserve( ${1:uint iMinimum}, ${2:bool bKeepData = true} )" ],
		"description" : "Reserves at least iMinimum characters worth of capacity. If bKeepData is true, the original string is kept."
	},
	"void string::Clear()": {
		"prefix": "Clear",
		"body" : [ "Clear()" ],
		"description" : "Clears the contents of this string."
	},
	"char string::opIndex(uint uiIndex) const": {
		"prefix": "opIndex",
		"body" : [ "opIndex( ${1:uint uiIndex} )" ],
		"description" : "Gets a character by index."
	},
	"void string::SetCharAt(uint uiIndex, char character)": {
		"prefix": "SetCharAt",
		"body" : [ "SetCharAt( ${1:uint uiIndex}, ${2:char character} )" ],
		"description" : "Sets a character by index."
	},
	"string& string::opAddAssign(const string& in szString)": {
		"prefix": "opAddAssign",
		"body" : [ "opAddAssign( ${1:const string& in szString} )" ],
		"description" : "Appends the given string to this one."
	},
	"string& string::opAddAssign(double flValue)": {
		"prefix": "opAddAssign",
		"body" : [ "opAddAssign( ${1:double flValue} )" ],
		"description" : "Appends the given double to this string."
	},
	"string& string::opAddAssign(int64 iValue)": {
		"prefix": "opAddAssign",
		"body" : [ "opAddAssign( ${1:int64 iValue} )" ],
		"description" : "Appends the given 64 bit integer to this string."
	},
	"string& string::opAddAssign(uint64 uiValue)": {
		"prefix": "opAddAssign",
		"body" : [ "opAddAssign( ${1:uint64 uiValue} )" ],
		"description" : "Appends the given 64 bit unsigned integer to this string."
	},
	"string& string::opAddAssign(bool bValue)": {
		"prefix": "opAddAssign",
		"body" : [ "opAddAssign( ${1:bool bValue} )" ],
		"description" : "Appends the given boolean to this string."
	},
	"string& string::opAddAssign(char character)": {
		"prefix": "opAddAssign",
		"body" : [ "opAddAssign( ${1:char character} )" ],
		"description" : "Appends the given character to this string."
	},
	"int string::opCmp(const string& in szString) const": {
		"prefix": "opCmp",
		"body" : [ "opCmp( ${1:const string& in szString} )" ],
		"description" : "Compares strings."
	},
	"int string::Compare(const string& in szString) const": {
		"prefix": "Compare",
		"body" : [ "Compare( ${1:const string& in szString} )" ],
		"description" : "Compares strings."
	},
	"int string::CompareN(const string& in szString, const uint amount) const": {
		"prefix": "CompareN",
		"body" : [ "CompareN( ${1:const string& in szString}, ${2:const uint amount} )" ],
		"description" : "Compares strings up to amount characters."
	},
	"int string::ICompare(const string& in szString) const": {
		"prefix": "ICompare",
		"body" : [ "ICompare( ${1:const string& in szString} )" ],
		"description" : "Compares strings case-insensitively."
	},
	"int string::ICompareN(const string& in szString, const uint amount) const": {
		"prefix": "ICompareN",
		"body" : [ "ICompareN( ${1:const string& in szString}, ${2:const uint amount} )" ],
		"description" : "Compares strings up to amount characters case-insensitively."
	},
	"bool string::opEquals(const string& in szString) const": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:const string& in szString} )" ],
		"description" : "Returns whether strings are equal."
	},
	"void string::Trim(const string& in szCharacter = ' ')": {
		"prefix": "Trim",
		"body" : [ "Trim( ${1:const string& in szCharacter = ' '} )" ],
		"description" : "Trims leading and trailing whitespace, or a given character."
	},
	"bool string::StartsWith(const string& in szString, const String::CompareType compareType = String::DEFAULT_COMPARE) const": {
		"prefix": "StartsWith",
		"body" : [ "StartsWith( ${1:const string& in szString}, ${2:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Returns true if the string starts with the given string."
	},
	"bool string::EndsWith(const string& in szString, const String::CompareType compareType = String::DEFAULT_COMPARE) const": {
		"prefix": "EndsWith",
		"body" : [ "EndsWith( ${1:const string& in szString}, ${2:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Returns true if the string ends with the given string."
	},
	"uint string::Find(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const": {
		"prefix": "Find",
		"body" : [ "Find( ${1:const string& in szString}, ${2:const uint startIndex = 0}, ${3:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Find the first instance of the given string. Returns String::INVALID_INDEX if not found."
	},
	"uint string::RFind(const string& in szString, uint startIndex = String::INVALID_INDEX, const String::CompareType compareType = String::DEFAULT_COMPARE) const": {
		"prefix": "RFind",
		"body" : [ "RFind( ${1:const string& in szString}, ${2:uint startIndex = String::INVALID_INDEX}, ${3:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Find the first instance of the given string, searching in reverse. Returns String::INVALID_INDEX if not found."
	},
	"uint string::FindFirstOf(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const": {
		"prefix": "FindFirstOf",
		"body" : [ "FindFirstOf( ${1:const string& in szString}, ${2:const uint startIndex = 0}, ${3:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Find the first instance of any character in the given string. Returns String::INVALID_INDEX if not found."
	},
	"uint string::FindLastOf(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const": {
		"prefix": "FindLastOf",
		"body" : [ "FindLastOf( ${1:const string& in szString}, ${2:const uint startIndex = 0}, ${3:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Find the last instance of any character in the given string. Returns String::INVALID_INDEX if not found."
	},
	"uint string::FindFirstNotOf(const string& in szString, uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const": {
		"prefix": "FindFirstNotOf",
		"body" : [ "FindFirstNotOf( ${1:const string& in szString}, ${2:uint startIndex = 0}, ${3:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Find the first instance of the given string. Returns String::INVALID_INDEX if not found."
	},
	"uint string::FindLastNotOf(const string& in szString, uint startIndex = String::INVALID_INDEX, const String::CompareType compareType = String::DEFAULT_COMPARE) const": {
		"prefix": "FindLastNotOf",
		"body" : [ "FindLastNotOf( ${1:const string& in szString}, ${2:uint startIndex = String::INVALID_INDEX}, ${3:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Find the first instance of the given string, searching in reverse. Returns String::INVALID_INDEX if not found."
	},
	"string string::Tokenize(const string& in delimiter) const": {
		"prefix": "Tokenize",
		"body" : [ "Tokenize( ${1:const string& in delimiter} )" ],
		"description" : "Get the next token of the given string. Returns String::NO_MORE_TOKENS if none remaining."
	},
	"string& string::ToLowercase()": {
		"prefix": "ToLowercase",
		"body" : [ "ToLowercase()" ],
		"description" : "Converts this string to lower case."
	},
	"string& string::ToUppercase()": {
		"prefix": "ToUppercase",
		"body" : [ "ToUppercase()" ],
		"description" : "Converts this string to upper case."
	},
	"string string::SubString(uint startIndex = 0, uint count = String::INVALID_INDEX) const": {
		"prefix": "SubString",
		"body" : [ "SubString( ${1:uint startIndex = 0}, ${2:uint count = String::INVALID_INDEX} )" ],
		"description" : "Returns a substring of this string."
	},
	"string& string::Replace(const string& in szSubstring, const string& in szReplacement, const String::CompareType compareType = String::DEFAULT_COMPARE)": {
		"prefix": "Replace",
		"body" : [ "Replace( ${1:const string& in szSubstring}, ${2:const string& in szReplacement}, ${3:const String::CompareType compareType = String::DEFAULT_COMPARE} )" ],
		"description" : "Replaces the given substring with the given replacement string."
	},
	"void string::Truncate(const size_t uiMaxLength)": {
		"prefix": "Truncate",
		"body" : [ "Truncate( ${1:const size_t uiMaxLength} )" ],
		"description" : "Truncates the string to uiMaxLength characters."
	},
	"string string::opAdd(const string& in szString) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:const string& in szString} )" ],
		"description" : "Returns a copy of this string with the given string appended."
	},
	"string string::opAdd(double flValue) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:double flValue} )" ],
		"description" : "Returns a copy of this string with the given double appended."
	},
	"string string::opAdd(int64 iValue) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:int64 iValue} )" ],
		"description" : "Returns a copy of this string with the given 64 bit integer appended."
	},
	"string string::opAdd(uint64 uiValue) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:uint64 uiValue} )" ],
		"description" : "Returns a copy of this string with the given 64 bit unsigned integer appended."
	},
	"string string::opAdd(bool bValue) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:bool bValue} )" ],
		"description" : "Returns a copy of this string with the given boolean appended."
	},
	"string string::opAdd(char character) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:char character} )" ],
		"description" : "Returns a copy of this string with the given character appended."
	},
	"array<string>@ string::Split(const string& in szDelimiter) const": {
		"prefix": "Split",
		"body" : [ "Split( ${1:const string& in szDelimiter} )" ],
		"description" : "Splits this string by the given delimiter."
	},
	"void string_t::string_t()": {
		"prefix": "string_t",
		"body" : [ "string_t()" ],
		"description" : "Default Constructor"
	},
	"void string_t::string_t(const string_t& in str)": {
		"prefix": "string_t",
		"body" : [ "string_t( ${1:const string_t& in str} )" ],
		"description" : "Copy Constructor"
	},
	"void string_t::string_t(const string& in str)": {
		"prefix": "string_t",
		"body" : [ "string_t( ${1:const string& in str} )" ],
		"description" : "Construct a string_t from a string"
	},
	"void string_t::string_t(int str)": {
		"prefix": "string_t",
		"body" : [ "string_t( ${1:int str} )" ],
		"description" : "Construct a string_t from an integer"
	},
	"string_t& string_t::opAssign(const string_t& in str)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const string_t& in str} )" ],
		"description" : "Assignment operator"
	},
	"string_t& string_t::opAssign(const string& in str)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const string& in str} )" ],
		"description" : "Assignment operator"
	},
	"string_t& string_t::opAssign(int str)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:int str} )" ],
		"description" : "Assignment operator"
	},
	"string string_t::opImplConv() const": {
		"prefix": "opImplConv",
		"body" : [ "opImplConv()" ],
		"description" : "Converts this string_t to a string."
	},
	"int string_t::opImplConv() const": {
		"prefix": "opImplConv",
		"body" : [ "opImplConv()" ],
		"description" : "Converts this string_t to an integer."
	},
	"void Regex::SubMatch::SubMatch()": {
		"prefix": "SubMatch",
		"body" : [ "SubMatch()" ],
		"description" : "Constructor. Do not use."
	},
	"void Regex::SubMatch::SubMatch(const SubMatch& in other)": {
		"prefix": "SubMatch",
		"body" : [ "SubMatch( ${1:const SubMatch& in other} )" ],
		"description" : "Copy constructor"
	},
	"int Regex::SubMatch::GetLength() const": {
		"prefix": "GetLength",
		"body" : [ "GetLength()" ],
		"description" : "Gets the length of the submatch"
	},
	"string Regex::SubMatch::GetString() const": {
		"prefix": "GetString",
		"body" : [ "GetString()" ],
		"description" : "Gets this submatch as a string"
	},
	"int Regex::SubMatch::Compare(const SubMatch& in other) const": {
		"prefix": "Compare",
		"body" : [ "Compare( ${1:const SubMatch& in other} )" ],
		"description" : "Compares this submatch to another"
	},
	"int Regex::SubMatch::Compare(const string& in szString) const": {
		"prefix": "Compare",
		"body" : [ "Compare( ${1:const string& in szString} )" ],
		"description" : "Compares this submatch to a string"
	},
	"enum TANKBULLET {..., TANK_BULLET_NONE, ...}": {
		"prefix": "TANK_BULLET_NONE",
		"body" : [ "TANK_BULLET_NONE" ],
		"description" : "(0) No bullet. Nothing is fired when this is set"
	},
	"enum TANKBULLET {..., TANK_BULLET_9MM, ...}": {
		"prefix": "TANK_BULLET_9MM",
		"body" : [ "TANK_BULLET_9MM" ],
		"description" : "(1) 9mm rounds"
	},
	"enum TANKBULLET {..., TANK_BULLET_MP5, ...}": {
		"prefix": "TANK_BULLET_MP5",
		"body" : [ "TANK_BULLET_MP5" ],
		"description" : "(2) MP5 rounds"
	},
	"enum TANKBULLET {..., TANK_BULLET_12MM, ...}": {
		"prefix": "TANK_BULLET_12MM",
		"body" : [ "TANK_BULLET_12MM" ],
		"description" : "(3) 12 mm rounds"
	},
	"enum TankFlags {..., SF_TANK_ACTIVE, ...}": {
		"prefix": "SF_TANK_ACTIVE",
		"body" : [ "SF_TANK_ACTIVE" ],
		"description" : "(1) Whether the tank is active or not"
	},
	"enum TankFlags {..., SF_TANK_LINEOFSIGHT, ...}": {
		"prefix": "SF_TANK_LINEOFSIGHT",
		"body" : [ "SF_TANK_LINEOFSIGHT" ],
		"description" : "(16) Whether to only attack if the tank has a direct line of sight of its target or continue firing."
	},
	"enum TankFlags {..., SF_TANK_CANCONTROL, ...}": {
		"prefix": "SF_TANK_CANCONTROL",
		"body" : [ "SF_TANK_CANCONTROL" ],
		"description" : "(32) Whether this func_tank is controllable or not"
	},
	"enum TankFlags {..., SF_TANK_USERELATIONS, ...}": {
		"prefix": "SF_TANK_USERELATIONS",
		"body" : [ "SF_TANK_USERELATIONS" ],
		"description" : "(512) If set, uses the relationship specified when dealing with player targets. Otherwise, defaults to always attacking monsters."
	},
	"enum TankFlags {..., SF_TANK_PLAYERCANTFIRE, ...}": {
		"prefix": "SF_TANK_PLAYERCANTFIRE",
		"body" : [ "SF_TANK_PLAYERCANTFIRE" ],
		"description" : "(1024) If set, controlling player can't fire this tank."
	},
	"int Task::iTask": {
		"prefix": "iTask",
		"body" : [ "iTask" ],
		"description" : "Task to execute. Can be monster-specific."
	},
	"float Task::flData": {
		"prefix": "flData",
		"body" : [ "flData" ],
		"description" : "Task data"
	},
	"enum TASK_TYPE {..., TASK_INVALID, ...}": {
		"prefix": "TASK_INVALID",
		"body" : [ "TASK_INVALID" ],
		"description" : "(0)"
	},
	"enum TASK_TYPE {..., TASK_WAIT, ...}": {
		"prefix": "TASK_WAIT",
		"body" : [ "TASK_WAIT" ],
		"description" : "(1)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_FACE_ENEMY, ...}": {
		"prefix": "TASK_WAIT_FACE_ENEMY",
		"body" : [ "TASK_WAIT_FACE_ENEMY" ],
		"description" : "(2)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_PVS, ...}": {
		"prefix": "TASK_WAIT_PVS",
		"body" : [ "TASK_WAIT_PVS" ],
		"description" : "(3)"
	},
	"enum TASK_TYPE {..., TASK_SUGGEST_STATE, ...}": {
		"prefix": "TASK_SUGGEST_STATE",
		"body" : [ "TASK_SUGGEST_STATE" ],
		"description" : "(4)"
	},
	"enum TASK_TYPE {..., TASK_WALK_TO_TARGET, ...}": {
		"prefix": "TASK_WALK_TO_TARGET",
		"body" : [ "TASK_WALK_TO_TARGET" ],
		"description" : "(5)"
	},
	"enum TASK_TYPE {..., TASK_RUN_TO_TARGET, ...}": {
		"prefix": "TASK_RUN_TO_TARGET",
		"body" : [ "TASK_RUN_TO_TARGET" ],
		"description" : "(6)"
	},
	"enum TASK_TYPE {..., TASK_MOVE_TO_TARGET_RANGE, ...}": {
		"prefix": "TASK_MOVE_TO_TARGET_RANGE",
		"body" : [ "TASK_MOVE_TO_TARGET_RANGE" ],
		"description" : "(7)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_ENEMY, ...}": {
		"prefix": "TASK_GET_PATH_TO_ENEMY",
		"body" : [ "TASK_GET_PATH_TO_ENEMY" ],
		"description" : "(8)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_ENEMY_LKP, ...}": {
		"prefix": "TASK_GET_PATH_TO_ENEMY_LKP",
		"body" : [ "TASK_GET_PATH_TO_ENEMY_LKP" ],
		"description" : "(9)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_ENEMY_CORPSE, ...}": {
		"prefix": "TASK_GET_PATH_TO_ENEMY_CORPSE",
		"body" : [ "TASK_GET_PATH_TO_ENEMY_CORPSE" ],
		"description" : "(10)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_LEADER, ...}": {
		"prefix": "TASK_GET_PATH_TO_LEADER",
		"body" : [ "TASK_GET_PATH_TO_LEADER" ],
		"description" : "(11)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_SPOT, ...}": {
		"prefix": "TASK_GET_PATH_TO_SPOT",
		"body" : [ "TASK_GET_PATH_TO_SPOT" ],
		"description" : "(12)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_TARGET, ...}": {
		"prefix": "TASK_GET_PATH_TO_TARGET",
		"body" : [ "TASK_GET_PATH_TO_TARGET" ],
		"description" : "(13)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_HINTNODE, ...}": {
		"prefix": "TASK_GET_PATH_TO_HINTNODE",
		"body" : [ "TASK_GET_PATH_TO_HINTNODE" ],
		"description" : "(14)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_LASTPOSITION, ...}": {
		"prefix": "TASK_GET_PATH_TO_LASTPOSITION",
		"body" : [ "TASK_GET_PATH_TO_LASTPOSITION" ],
		"description" : "(15)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_BESTSOUND, ...}": {
		"prefix": "TASK_GET_PATH_TO_BESTSOUND",
		"body" : [ "TASK_GET_PATH_TO_BESTSOUND" ],
		"description" : "(16)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_BESTSCENT, ...}": {
		"prefix": "TASK_GET_PATH_TO_BESTSCENT",
		"body" : [ "TASK_GET_PATH_TO_BESTSCENT" ],
		"description" : "(17)"
	},
	"enum TASK_TYPE {..., TASK_RUN_PATH, ...}": {
		"prefix": "TASK_RUN_PATH",
		"body" : [ "TASK_RUN_PATH" ],
		"description" : "(18)"
	},
	"enum TASK_TYPE {..., TASK_WALK_PATH, ...}": {
		"prefix": "TASK_WALK_PATH",
		"body" : [ "TASK_WALK_PATH" ],
		"description" : "(19)"
	},
	"enum TASK_TYPE {..., TASK_STRAFE_PATH, ...}": {
		"prefix": "TASK_STRAFE_PATH",
		"body" : [ "TASK_STRAFE_PATH" ],
		"description" : "(20)"
	},
	"enum TASK_TYPE {..., TASK_CLEAR_MOVE_WAIT, ...}": {
		"prefix": "TASK_CLEAR_MOVE_WAIT",
		"body" : [ "TASK_CLEAR_MOVE_WAIT" ],
		"description" : "(21)"
	},
	"enum TASK_TYPE {..., TASK_STORE_LASTPOSITION, ...}": {
		"prefix": "TASK_STORE_LASTPOSITION",
		"body" : [ "TASK_STORE_LASTPOSITION" ],
		"description" : "(22)"
	},
	"enum TASK_TYPE {..., TASK_CLEAR_LASTPOSITION, ...}": {
		"prefix": "TASK_CLEAR_LASTPOSITION",
		"body" : [ "TASK_CLEAR_LASTPOSITION" ],
		"description" : "(23)"
	},
	"enum TASK_TYPE {..., TASK_PLAY_ACTIVE_IDLE, ...}": {
		"prefix": "TASK_PLAY_ACTIVE_IDLE",
		"body" : [ "TASK_PLAY_ACTIVE_IDLE" ],
		"description" : "(24)"
	},
	"enum TASK_TYPE {..., TASK_FIND_HINTNODE, ...}": {
		"prefix": "TASK_FIND_HINTNODE",
		"body" : [ "TASK_FIND_HINTNODE" ],
		"description" : "(25)"
	},
	"enum TASK_TYPE {..., TASK_CLEAR_HINTNODE, ...}": {
		"prefix": "TASK_CLEAR_HINTNODE",
		"body" : [ "TASK_CLEAR_HINTNODE" ],
		"description" : "(26)"
	},
	"enum TASK_TYPE {..., TASK_SMALL_FLINCH, ...}": {
		"prefix": "TASK_SMALL_FLINCH",
		"body" : [ "TASK_SMALL_FLINCH" ],
		"description" : "(27)"
	},
	"enum TASK_TYPE {..., TASK_FACE_IDEAL, ...}": {
		"prefix": "TASK_FACE_IDEAL",
		"body" : [ "TASK_FACE_IDEAL" ],
		"description" : "(28)"
	},
	"enum TASK_TYPE {..., TASK_FACE_ROUTE, ...}": {
		"prefix": "TASK_FACE_ROUTE",
		"body" : [ "TASK_FACE_ROUTE" ],
		"description" : "(29)"
	},
	"enum TASK_TYPE {..., TASK_FACE_ENEMY, ...}": {
		"prefix": "TASK_FACE_ENEMY",
		"body" : [ "TASK_FACE_ENEMY" ],
		"description" : "(30)"
	},
	"enum TASK_TYPE {..., TASK_FACE_HINTNODE, ...}": {
		"prefix": "TASK_FACE_HINTNODE",
		"body" : [ "TASK_FACE_HINTNODE" ],
		"description" : "(31)"
	},
	"enum TASK_TYPE {..., TASK_FACE_TARGET, ...}": {
		"prefix": "TASK_FACE_TARGET",
		"body" : [ "TASK_FACE_TARGET" ],
		"description" : "(32)"
	},
	"enum TASK_TYPE {..., TASK_FACE_LASTPOSITION, ...}": {
		"prefix": "TASK_FACE_LASTPOSITION",
		"body" : [ "TASK_FACE_LASTPOSITION" ],
		"description" : "(33)"
	},
	"enum TASK_TYPE {..., TASK_RANGE_ATTACK1, ...}": {
		"prefix": "TASK_RANGE_ATTACK1",
		"body" : [ "TASK_RANGE_ATTACK1" ],
		"description" : "(34)"
	},
	"enum TASK_TYPE {..., TASK_RANGE_ATTACK2, ...}": {
		"prefix": "TASK_RANGE_ATTACK2",
		"body" : [ "TASK_RANGE_ATTACK2" ],
		"description" : "(35)"
	},
	"enum TASK_TYPE {..., TASK_MELEE_ATTACK1, ...}": {
		"prefix": "TASK_MELEE_ATTACK1",
		"body" : [ "TASK_MELEE_ATTACK1" ],
		"description" : "(36)"
	},
	"enum TASK_TYPE {..., TASK_MELEE_ATTACK2, ...}": {
		"prefix": "TASK_MELEE_ATTACK2",
		"body" : [ "TASK_MELEE_ATTACK2" ],
		"description" : "(37)"
	},
	"enum TASK_TYPE {..., TASK_RELOAD, ...}": {
		"prefix": "TASK_RELOAD",
		"body" : [ "TASK_RELOAD" ],
		"description" : "(38)"
	},
	"enum TASK_TYPE {..., TASK_RANGE_ATTACK1_NOTURN, ...}": {
		"prefix": "TASK_RANGE_ATTACK1_NOTURN",
		"body" : [ "TASK_RANGE_ATTACK1_NOTURN" ],
		"description" : "(39)"
	},
	"enum TASK_TYPE {..., TASK_RANGE_ATTACK2_NOTURN, ...}": {
		"prefix": "TASK_RANGE_ATTACK2_NOTURN",
		"body" : [ "TASK_RANGE_ATTACK2_NOTURN" ],
		"description" : "(40)"
	},
	"enum TASK_TYPE {..., TASK_MELEE_ATTACK1_NOTURN, ...}": {
		"prefix": "TASK_MELEE_ATTACK1_NOTURN",
		"body" : [ "TASK_MELEE_ATTACK1_NOTURN" ],
		"description" : "(41)"
	},
	"enum TASK_TYPE {..., TASK_MELEE_ATTACK2_NOTURN, ...}": {
		"prefix": "TASK_MELEE_ATTACK2_NOTURN",
		"body" : [ "TASK_MELEE_ATTACK2_NOTURN" ],
		"description" : "(42)"
	},
	"enum TASK_TYPE {..., TASK_RELOAD_NOTURN, ...}": {
		"prefix": "TASK_RELOAD_NOTURN",
		"body" : [ "TASK_RELOAD_NOTURN" ],
		"description" : "(43)"
	},
	"enum TASK_TYPE {..., TASK_SPECIAL_ATTACK1, ...}": {
		"prefix": "TASK_SPECIAL_ATTACK1",
		"body" : [ "TASK_SPECIAL_ATTACK1" ],
		"description" : "(44)"
	},
	"enum TASK_TYPE {..., TASK_SPECIAL_ATTACK2, ...}": {
		"prefix": "TASK_SPECIAL_ATTACK2",
		"body" : [ "TASK_SPECIAL_ATTACK2" ],
		"description" : "(45)"
	},
	"enum TASK_TYPE {..., TASK_CROUCH, ...}": {
		"prefix": "TASK_CROUCH",
		"body" : [ "TASK_CROUCH" ],
		"description" : "(46)"
	},
	"enum TASK_TYPE {..., TASK_STAND, ...}": {
		"prefix": "TASK_STAND",
		"body" : [ "TASK_STAND" ],
		"description" : "(47)"
	},
	"enum TASK_TYPE {..., TASK_GUARD, ...}": {
		"prefix": "TASK_GUARD",
		"body" : [ "TASK_GUARD" ],
		"description" : "(48)"
	},
	"enum TASK_TYPE {..., TASK_STEP_LEFT, ...}": {
		"prefix": "TASK_STEP_LEFT",
		"body" : [ "TASK_STEP_LEFT" ],
		"description" : "(49)"
	},
	"enum TASK_TYPE {..., TASK_STEP_RIGHT, ...}": {
		"prefix": "TASK_STEP_RIGHT",
		"body" : [ "TASK_STEP_RIGHT" ],
		"description" : "(50)"
	},
	"enum TASK_TYPE {..., TASK_STEP_FORWARD, ...}": {
		"prefix": "TASK_STEP_FORWARD",
		"body" : [ "TASK_STEP_FORWARD" ],
		"description" : "(51)"
	},
	"enum TASK_TYPE {..., TASK_STEP_BACK, ...}": {
		"prefix": "TASK_STEP_BACK",
		"body" : [ "TASK_STEP_BACK" ],
		"description" : "(52)"
	},
	"enum TASK_TYPE {..., TASK_DODGE_LEFT, ...}": {
		"prefix": "TASK_DODGE_LEFT",
		"body" : [ "TASK_DODGE_LEFT" ],
		"description" : "(53)"
	},
	"enum TASK_TYPE {..., TASK_DODGE_RIGHT, ...}": {
		"prefix": "TASK_DODGE_RIGHT",
		"body" : [ "TASK_DODGE_RIGHT" ],
		"description" : "(54)"
	},
	"enum TASK_TYPE {..., TASK_SOUND_ANGRY, ...}": {
		"prefix": "TASK_SOUND_ANGRY",
		"body" : [ "TASK_SOUND_ANGRY" ],
		"description" : "(55)"
	},
	"enum TASK_TYPE {..., TASK_SOUND_DEATH, ...}": {
		"prefix": "TASK_SOUND_DEATH",
		"body" : [ "TASK_SOUND_DEATH" ],
		"description" : "(56)"
	},
	"enum TASK_TYPE {..., TASK_SET_ACTIVITY, ...}": {
		"prefix": "TASK_SET_ACTIVITY",
		"body" : [ "TASK_SET_ACTIVITY" ],
		"description" : "(57)"
	},
	"enum TASK_TYPE {..., TASK_SET_SCHEDULE, ...}": {
		"prefix": "TASK_SET_SCHEDULE",
		"body" : [ "TASK_SET_SCHEDULE" ],
		"description" : "(58)"
	},
	"enum TASK_TYPE {..., TASK_SET_FAIL_SCHEDULE, ...}": {
		"prefix": "TASK_SET_FAIL_SCHEDULE",
		"body" : [ "TASK_SET_FAIL_SCHEDULE" ],
		"description" : "(59)"
	},
	"enum TASK_TYPE {..., TASK_CLEAR_FAIL_SCHEDULE, ...}": {
		"prefix": "TASK_CLEAR_FAIL_SCHEDULE",
		"body" : [ "TASK_CLEAR_FAIL_SCHEDULE" ],
		"description" : "(60)"
	},
	"enum TASK_TYPE {..., TASK_PLAY_SEQUENCE, ...}": {
		"prefix": "TASK_PLAY_SEQUENCE",
		"body" : [ "TASK_PLAY_SEQUENCE" ],
		"description" : "(61)"
	},
	"enum TASK_TYPE {..., TASK_PLAY_SEQUENCE_FACE_ENEMY, ...}": {
		"prefix": "TASK_PLAY_SEQUENCE_FACE_ENEMY",
		"body" : [ "TASK_PLAY_SEQUENCE_FACE_ENEMY" ],
		"description" : "(62)"
	},
	"enum TASK_TYPE {..., TASK_PLAY_SEQUENCE_FACE_TARGET, ...}": {
		"prefix": "TASK_PLAY_SEQUENCE_FACE_TARGET",
		"body" : [ "TASK_PLAY_SEQUENCE_FACE_TARGET" ],
		"description" : "(63)"
	},
	"enum TASK_TYPE {..., TASK_SOUND_IDLE, ...}": {
		"prefix": "TASK_SOUND_IDLE",
		"body" : [ "TASK_SOUND_IDLE" ],
		"description" : "(64)"
	},
	"enum TASK_TYPE {..., TASK_SOUND_WAKE, ...}": {
		"prefix": "TASK_SOUND_WAKE",
		"body" : [ "TASK_SOUND_WAKE" ],
		"description" : "(65)"
	},
	"enum TASK_TYPE {..., TASK_SOUND_PAIN, ...}": {
		"prefix": "TASK_SOUND_PAIN",
		"body" : [ "TASK_SOUND_PAIN" ],
		"description" : "(66)"
	},
	"enum TASK_TYPE {..., TASK_SOUND_DIE, ...}": {
		"prefix": "TASK_SOUND_DIE",
		"body" : [ "TASK_SOUND_DIE" ],
		"description" : "(67)"
	},
	"enum TASK_TYPE {..., TASK_FIND_COVER_FROM_BEST_SOUND, ...}": {
		"prefix": "TASK_FIND_COVER_FROM_BEST_SOUND",
		"body" : [ "TASK_FIND_COVER_FROM_BEST_SOUND" ],
		"description" : "(68)"
	},
	"enum TASK_TYPE {..., TASK_FIND_COVER_FROM_ENEMY, ...}": {
		"prefix": "TASK_FIND_COVER_FROM_ENEMY",
		"body" : [ "TASK_FIND_COVER_FROM_ENEMY" ],
		"description" : "(69)"
	},
	"enum TASK_TYPE {..., TASK_FIND_LATERAL_COVER_FROM_ENEMY, ...}": {
		"prefix": "TASK_FIND_LATERAL_COVER_FROM_ENEMY",
		"body" : [ "TASK_FIND_LATERAL_COVER_FROM_ENEMY" ],
		"description" : "(70)"
	},
	"enum TASK_TYPE {..., TASK_FIND_NODE_COVER_FROM_ENEMY, ...}": {
		"prefix": "TASK_FIND_NODE_COVER_FROM_ENEMY",
		"body" : [ "TASK_FIND_NODE_COVER_FROM_ENEMY" ],
		"description" : "(71)"
	},
	"enum TASK_TYPE {..., TASK_FIND_NEAR_NODE_COVER_FROM_ENEMY, ...}": {
		"prefix": "TASK_FIND_NEAR_NODE_COVER_FROM_ENEMY",
		"body" : [ "TASK_FIND_NEAR_NODE_COVER_FROM_ENEMY" ],
		"description" : "(72)"
	},
	"enum TASK_TYPE {..., TASK_FIND_FAR_NODE_COVER_FROM_ENEMY, ...}": {
		"prefix": "TASK_FIND_FAR_NODE_COVER_FROM_ENEMY",
		"body" : [ "TASK_FIND_FAR_NODE_COVER_FROM_ENEMY" ],
		"description" : "(73)"
	},
	"enum TASK_TYPE {..., TASK_FIND_COVER_FROM_ORIGIN, ...}": {
		"prefix": "TASK_FIND_COVER_FROM_ORIGIN",
		"body" : [ "TASK_FIND_COVER_FROM_ORIGIN" ],
		"description" : "(74)"
	},
	"enum TASK_TYPE {..., TASK_EAT, ...}": {
		"prefix": "TASK_EAT",
		"body" : [ "TASK_EAT" ],
		"description" : "(75)"
	},
	"enum TASK_TYPE {..., TASK_DIE, ...}": {
		"prefix": "TASK_DIE",
		"body" : [ "TASK_DIE" ],
		"description" : "(76)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_FOR_SCRIPT, ...}": {
		"prefix": "TASK_WAIT_FOR_SCRIPT",
		"body" : [ "TASK_WAIT_FOR_SCRIPT" ],
		"description" : "(77)"
	},
	"enum TASK_TYPE {..., TASK_PLAY_SCRIPT, ...}": {
		"prefix": "TASK_PLAY_SCRIPT",
		"body" : [ "TASK_PLAY_SCRIPT" ],
		"description" : "(78)"
	},
	"enum TASK_TYPE {..., TASK_ENABLE_SCRIPT, ...}": {
		"prefix": "TASK_ENABLE_SCRIPT",
		"body" : [ "TASK_ENABLE_SCRIPT" ],
		"description" : "(79)"
	},
	"enum TASK_TYPE {..., TASK_PLANT_ON_SCRIPT, ...}": {
		"prefix": "TASK_PLANT_ON_SCRIPT",
		"body" : [ "TASK_PLANT_ON_SCRIPT" ],
		"description" : "(80)"
	},
	"enum TASK_TYPE {..., TASK_FACE_SCRIPT, ...}": {
		"prefix": "TASK_FACE_SCRIPT",
		"body" : [ "TASK_FACE_SCRIPT" ],
		"description" : "(81)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_RANDOM, ...}": {
		"prefix": "TASK_WAIT_RANDOM",
		"body" : [ "TASK_WAIT_RANDOM" ],
		"description" : "(82)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_INDEFINITE, ...}": {
		"prefix": "TASK_WAIT_INDEFINITE",
		"body" : [ "TASK_WAIT_INDEFINITE" ],
		"description" : "(83)"
	},
	"enum TASK_TYPE {..., TASK_STOP_MOVING, ...}": {
		"prefix": "TASK_STOP_MOVING",
		"body" : [ "TASK_STOP_MOVING" ],
		"description" : "(84)"
	},
	"enum TASK_TYPE {..., TASK_TURN_LEFT, ...}": {
		"prefix": "TASK_TURN_LEFT",
		"body" : [ "TASK_TURN_LEFT" ],
		"description" : "(85)"
	},
	"enum TASK_TYPE {..., TASK_TURN_RIGHT, ...}": {
		"prefix": "TASK_TURN_RIGHT",
		"body" : [ "TASK_TURN_RIGHT" ],
		"description" : "(86)"
	},
	"enum TASK_TYPE {..., TASK_REMEMBER, ...}": {
		"prefix": "TASK_REMEMBER",
		"body" : [ "TASK_REMEMBER" ],
		"description" : "(87)"
	},
	"enum TASK_TYPE {..., TASK_FORGET, ...}": {
		"prefix": "TASK_FORGET",
		"body" : [ "TASK_FORGET" ],
		"description" : "(88)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_FOR_MOVEMENT, ...}": {
		"prefix": "TASK_WAIT_FOR_MOVEMENT",
		"body" : [ "TASK_WAIT_FOR_MOVEMENT" ],
		"description" : "(89)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_FOR_MOVEMENT_AP, ...}": {
		"prefix": "TASK_WAIT_FOR_MOVEMENT_AP",
		"body" : [ "TASK_WAIT_FOR_MOVEMENT_AP" ],
		"description" : "(90)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_FOR_MOVEMENT_ENEMY_OCCLUDED, ...}": {
		"prefix": "TASK_WAIT_FOR_MOVEMENT_ENEMY_OCCLUDED",
		"body" : [ "TASK_WAIT_FOR_MOVEMENT_ENEMY_OCCLUDED" ],
		"description" : "(91)"
	},
	"enum TASK_TYPE {..., TASK_WALK_PLAYERPATH_FOR_UNITS, ...}": {
		"prefix": "TASK_WALK_PLAYERPATH_FOR_UNITS",
		"body" : [ "TASK_WALK_PLAYERPATH_FOR_UNITS" ],
		"description" : "(92)"
	},
	"enum TASK_TYPE {..., TASK_MOVE_AWAY_PLAYERPATH, ...}": {
		"prefix": "TASK_MOVE_AWAY_PLAYERPATH",
		"body" : [ "TASK_MOVE_AWAY_PLAYERPATH" ],
		"description" : "(93)"
	},
	"enum TASK_TYPE {..., TASK_FIND_TANK, ...}": {
		"prefix": "TASK_FIND_TANK",
		"body" : [ "TASK_FIND_TANK" ],
		"description" : "(94)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_TANK, ...}": {
		"prefix": "TASK_GET_PATH_TO_TANK",
		"body" : [ "TASK_GET_PATH_TO_TANK" ],
		"description" : "(95)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_AT_TANK, ...}": {
		"prefix": "TASK_WAIT_AT_TANK",
		"body" : [ "TASK_WAIT_AT_TANK" ],
		"description" : "(96)"
	},
	"enum TASK_TYPE {..., TASK_FIND_ATTACKPOINT_TO_ENEMY, ...}": {
		"prefix": "TASK_FIND_ATTACKPOINT_TO_ENEMY",
		"body" : [ "TASK_FIND_ATTACKPOINT_TO_ENEMY" ],
		"description" : "(97)"
	},
	"enum TASK_TYPE {..., TASK_WAIT_FOR_MOVEMENT_GRENADE, ...}": {
		"prefix": "TASK_WAIT_FOR_MOVEMENT_GRENADE",
		"body" : [ "TASK_WAIT_FOR_MOVEMENT_GRENADE" ],
		"description" : "(98)"
	},
	"enum TASK_TYPE {..., TASK_MOVE_TO_TARGET_RANGE_FORCE, ...}": {
		"prefix": "TASK_MOVE_TO_TARGET_RANGE_FORCE",
		"body" : [ "TASK_MOVE_TO_TARGET_RANGE_FORCE" ],
		"description" : "(99)"
	},
	"enum TASK_TYPE {..., TASK_PLAY_SEQUENCE_COWER, ...}": {
		"prefix": "TASK_PLAY_SEQUENCE_COWER",
		"body" : [ "TASK_PLAY_SEQUENCE_COWER" ],
		"description" : "(100)"
	},
	"enum TASK_TYPE {..., TASK_USE_TANK, ...}": {
		"prefix": "TASK_USE_TANK",
		"body" : [ "TASK_USE_TANK" ],
		"description" : "(101)"
	},
	"enum TASK_TYPE {..., TASK_RUN_TO_TANK, ...}": {
		"prefix": "TASK_RUN_TO_TANK",
		"body" : [ "TASK_RUN_TO_TANK" ],
		"description" : "(102)"
	},
	"enum TASK_TYPE {..., TASK_FIND_COVER_DISTANCE_FROM_ENEMY, ...}": {
		"prefix": "TASK_FIND_COVER_DISTANCE_FROM_ENEMY",
		"body" : [ "TASK_FIND_COVER_DISTANCE_FROM_ENEMY" ],
		"description" : "(103)"
	},
	"enum TASK_TYPE {..., TASK_GET_PATH_TO_BESTCOMBATSOUND, ...}": {
		"prefix": "TASK_GET_PATH_TO_BESTCOMBATSOUND",
		"body" : [ "TASK_GET_PATH_TO_BESTCOMBATSOUND" ],
		"description" : "(104)"
	},
	"enum TASK_TYPE {..., TASK_MOVE_TO_ENEMY, ...}": {
		"prefix": "TASK_MOVE_TO_ENEMY",
		"body" : [ "TASK_MOVE_TO_ENEMY" ],
		"description" : "(105)"
	},
	"enum TASK_TYPE {..., TASK_PATH_WAYPOINT_INITIALIZE, ...}": {
		"prefix": "TASK_PATH_WAYPOINT_INITIALIZE",
		"body" : [ "TASK_PATH_WAYPOINT_INITIALIZE" ],
		"description" : "(106)"
	},
	"enum TASK_TYPE {..., TASK_PATH_WAYPOINT_MOVEMENT, ...}": {
		"prefix": "TASK_PATH_WAYPOINT_MOVEMENT",
		"body" : [ "TASK_PATH_WAYPOINT_MOVEMENT" ],
		"description" : "(107)"
	},
	"enum TASK_TYPE {..., TASK_PATH_WAYPOINT_ANGLES, ...}": {
		"prefix": "TASK_PATH_WAYPOINT_ANGLES",
		"body" : [ "TASK_PATH_WAYPOINT_ANGLES" ],
		"description" : "(108)"
	},
	"enum TASK_TYPE {..., TASK_PATH_WAYPOINT_ARRIVAL, ...}": {
		"prefix": "TASK_PATH_WAYPOINT_ARRIVAL",
		"body" : [ "TASK_PATH_WAYPOINT_ARRIVAL" ],
		"description" : "(109)"
	},
	"enum TASK_TYPE {..., TASK_PATH_WAYPOINT_WAIT, ...}": {
		"prefix": "TASK_PATH_WAYPOINT_WAIT",
		"body" : [ "TASK_PATH_WAYPOINT_WAIT" ],
		"description" : "(110)"
	},
	"enum TASK_TYPE {..., TASK_PATH_WAYPOINT_DEPARTURE, ...}": {
		"prefix": "TASK_PATH_WAYPOINT_DEPARTURE",
		"body" : [ "TASK_PATH_WAYPOINT_DEPARTURE" ],
		"description" : "(111)"
	},
	"enum TASK_TYPE {..., LAST_COMMON_TASK, ...}": {
		"prefix": "LAST_COMMON_TASK",
		"body" : [ "LAST_COMMON_TASK" ],
		"description" : "(112)"
	},
	"enum TaskData {..., TARGET_MOVE_NORMAL, ...}": {
		"prefix": "TARGET_MOVE_NORMAL",
		"body" : [ "TARGET_MOVE_NORMAL" ],
		"description" : "(0) Move normally"
	},
	"enum TaskData {..., TARGET_MOVE_SCRIPTED, ...}": {
		"prefix": "TARGET_MOVE_SCRIPTED",
		"body" : [ "TARGET_MOVE_SCRIPTED" ],
		"description" : "(1) Move scripted"
	},
	"enum TE_BOUNCE {..., TE_BOUNCE_NULL, ...}": {
		"prefix": "TE_BOUNCE_NULL",
		"body" : [ "TE_BOUNCE_NULL" ],
		"description" : "(0)"
	},
	"enum TE_BOUNCE {..., TE_BOUNCE_SHELL, ...}": {
		"prefix": "TE_BOUNCE_SHELL",
		"body" : [ "TE_BOUNCE_SHELL" ],
		"description" : "(1)"
	},
	"enum TE_BOUNCE {..., TE_BOUNCE_SHOTSHELL, ...}": {
		"prefix": "TE_BOUNCE_SHOTSHELL",
		"body" : [ "TE_BOUNCE_SHOTSHELL" ],
		"description" : "(2)"
	},
	"enum TE_ExplosionFlag {..., TE_EXPLFLAG_NONE, ...}": {
		"prefix": "TE_EXPLFLAG_NONE",
		"body" : [ "TE_EXPLFLAG_NONE" ],
		"description" : "(0) All flags clear makes default Half-Life explosion"
	},
	"enum TE_ExplosionFlag {..., TE_EXPLFLAG_NOADDITIVE, ...}": {
		"prefix": "TE_EXPLFLAG_NOADDITIVE",
		"body" : [ "TE_EXPLFLAG_NOADDITIVE" ],
		"description" : "(1) Sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite)"
	},
	"enum TE_ExplosionFlag {..., TE_EXPLFLAG_NODLIGHTS, ...}": {
		"prefix": "TE_EXPLFLAG_NODLIGHTS",
		"body" : [ "TE_EXPLFLAG_NODLIGHTS" ],
		"description" : "(2) Do not render dynamic lights"
	},
	"enum TE_ExplosionFlag {..., TE_EXPLFLAG_NOSOUND, ...}": {
		"prefix": "TE_EXPLFLAG_NOSOUND",
		"body" : [ "TE_EXPLFLAG_NOSOUND" ],
		"description" : "(4) Do not play client explosion sound"
	},
	"enum TE_ExplosionFlag {..., TE_EXPLFLAG_NOPARTICLES, ...}": {
		"prefix": "TE_EXPLFLAG_NOPARTICLES",
		"body" : [ "TE_EXPLFLAG_NOPARTICLES" ],
		"description" : "(8) Do not draw particles"
	},
	"enum TE_FireFieldFlag {..., TEFIRE_FLAG_ALLFLOAT, ...}": {
		"prefix": "TEFIRE_FLAG_ALLFLOAT",
		"body" : [ "TEFIRE_FLAG_ALLFLOAT" ],
		"description" : "(1) All sprites will drift upwards as they animate"
	},
	"enum TE_FireFieldFlag {..., TEFIRE_FLAG_SOMEFLOAT, ...}": {
		"prefix": "TEFIRE_FLAG_SOMEFLOAT",
		"body" : [ "TEFIRE_FLAG_SOMEFLOAT" ],
		"description" : "(2) Some of the sprites will drift upwards. (50% chance)"
	},
	"enum TE_FireFieldFlag {..., TEFIRE_FLAG_LOOP, ...}": {
		"prefix": "TEFIRE_FLAG_LOOP",
		"body" : [ "TEFIRE_FLAG_LOOP" ],
		"description" : "(4) If set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite's duration."
	},
	"enum TE_FireFieldFlag {..., TEFIRE_FLAG_ALPHA, ...}": {
		"prefix": "TEFIRE_FLAG_ALPHA",
		"body" : [ "TEFIRE_FLAG_ALPHA" ],
		"description" : "(8) If set, sprite is rendered alpha blended at 50% else, opaque"
	},
	"enum TE_FireFieldFlag {..., TEFIRE_FLAG_PLANAR, ...}": {
		"prefix": "TEFIRE_FLAG_PLANAR",
		"body" : [ "TEFIRE_FLAG_PLANAR" ],
		"description" : "(16) If set, all fire sprites have same initial Z instead of randomly filling a cube. "
	},
	"enum TE_FireFieldFlag {..., TEFIRE_FLAG_ADDITIVE, ...}": {
		"prefix": "TEFIRE_FLAG_ADDITIVE",
		"body" : [ "TEFIRE_FLAG_ADDITIVE" ],
		"description" : "(32) If set, sprite is rendered non-opaque with additive"
	},
	"enum TempEntityType {..., TE_BEAMPOINTS, ...}": {
		"prefix": "TE_BEAMPOINTS",
		"body" : [ "TE_BEAMPOINTS" ],
		"description" : "(0) Beam effect between two points"
	},
	"enum TempEntityType {..., TE_BEAMENTPOINT, ...}": {
		"prefix": "TE_BEAMENTPOINT",
		"body" : [ "TE_BEAMENTPOINT" ],
		"description" : "(1) Beam effect between point and entity"
	},
	"enum TempEntityType {..., TE_GUNSHOT, ...}": {
		"prefix": "TE_GUNSHOT",
		"body" : [ "TE_GUNSHOT" ],
		"description" : "(2) Particle effect plus ricochet sound"
	},
	"enum TempEntityType {..., TE_EXPLOSION, ...}": {
		"prefix": "TE_EXPLOSION",
		"body" : [ "TE_EXPLOSION" ],
		"description" : "(3) Additive sprite, 2 dynamic lights, flickering particles, explosion sound, move vertically 8 pps"
	},
	"enum TempEntityType {..., TE_TAREXPLOSION, ...}": {
		"prefix": "TE_TAREXPLOSION",
		"body" : [ "TE_TAREXPLOSION" ],
		"description" : "(4) Quake1 \"tarbaby\" explosion with sound"
	},
	"enum TempEntityType {..., TE_SMOKE, ...}": {
		"prefix": "TE_SMOKE",
		"body" : [ "TE_SMOKE" ],
		"description" : "(5) Alphablend sprite, move vertically 30 pps"
	},
	"enum TempEntityType {..., TE_TRACER, ...}": {
		"prefix": "TE_TRACER",
		"body" : [ "TE_TRACER" ],
		"description" : "(6) Tracer effect from point to point"
	},
	"enum TempEntityType {..., TE_LIGHTNING, ...}": {
		"prefix": "TE_LIGHTNING",
		"body" : [ "TE_LIGHTNING" ],
		"description" : "(7) TE_BEAMPOINTS with simplified parameters"
	},
	"enum TempEntityType {..., TE_BEAMENTS, ...}": {
		"prefix": "TE_BEAMENTS",
		"body" : [ "TE_BEAMENTS" ],
		"description" : "(8) Beam effect between two entities"
	},
	"enum TempEntityType {..., TE_SPARKS, ...}": {
		"prefix": "TE_SPARKS",
		"body" : [ "TE_SPARKS" ],
		"description" : "(9) Spark effect"
	},
	"enum TempEntityType {..., TE_LAVASPLASH, ...}": {
		"prefix": "TE_LAVASPLASH",
		"body" : [ "TE_LAVASPLASH" ],
		"description" : "(10) Lava splash effect"
	},
	"enum TempEntityType {..., TE_TELEPORT, ...}": {
		"prefix": "TE_TELEPORT",
		"body" : [ "TE_TELEPORT" ],
		"description" : "(11) Teleport effect"
	},
	"enum TempEntityType {..., TE_EXPLOSION2, ...}": {
		"prefix": "TE_EXPLOSION2",
		"body" : [ "TE_EXPLOSION2" ],
		"description" : "(12) Explosion effect"
	},
	"enum TempEntityType {..., TE_BSPDECAL, ...}": {
		"prefix": "TE_BSPDECAL",
		"body" : [ "TE_BSPDECAL" ],
		"description" : "(13) Decal from the .BSP file "
	},
	"enum TempEntityType {..., TE_IMPLOSION, ...}": {
		"prefix": "TE_IMPLOSION",
		"body" : [ "TE_IMPLOSION" ],
		"description" : "(14) Tracers moving toward a point"
	},
	"enum TempEntityType {..., TE_SPRITETRAIL, ...}": {
		"prefix": "TE_SPRITETRAIL",
		"body" : [ "TE_SPRITETRAIL" ],
		"description" : "(15) Line of moving glow sprites with gravity, fadeout, and collisions"
	},
	"enum TempEntityType {..., TE_SPRITE, ...}": {
		"prefix": "TE_SPRITE",
		"body" : [ "TE_SPRITE" ],
		"description" : "(17) Additive sprite, plays 1 cycle"
	},
	"enum TempEntityType {..., TE_BEAMSPRITE, ...}": {
		"prefix": "TE_BEAMSPRITE",
		"body" : [ "TE_BEAMSPRITE" ],
		"description" : "(18) A beam with a sprite at the end"
	},
	"enum TempEntityType {..., TE_BEAMTORUS, ...}": {
		"prefix": "TE_BEAMTORUS",
		"body" : [ "TE_BEAMTORUS" ],
		"description" : "(19) Screen aligned beam ring, expands to max radius over lifetime"
	},
	"enum TempEntityType {..., TE_BEAMDISK, ...}": {
		"prefix": "TE_BEAMDISK",
		"body" : [ "TE_BEAMDISK" ],
		"description" : "(20) Disk that expands to max radius over lifetime"
	},
	"enum TempEntityType {..., TE_BEAMCYLINDER, ...}": {
		"prefix": "TE_BEAMCYLINDER",
		"body" : [ "TE_BEAMCYLINDER" ],
		"description" : "(21) Cylinder that expands to max radius over lifetime"
	},
	"enum TempEntityType {..., TE_BEAMFOLLOW, ...}": {
		"prefix": "TE_BEAMFOLLOW",
		"body" : [ "TE_BEAMFOLLOW" ],
		"description" : "(22) Create a line of decaying beam segments until entity stops moving"
	},
	"enum TempEntityType {..., TE_GLOWSPRITE, ...}": {
		"prefix": "TE_GLOWSPRITE",
		"body" : [ "TE_GLOWSPRITE" ],
		"description" : "(23) Glowing sprite"
	},
	"enum TempEntityType {..., TE_BEAMRING, ...}": {
		"prefix": "TE_BEAMRING",
		"body" : [ "TE_BEAMRING" ],
		"description" : "(24) Connect a beam ring to two entities"
	},
	"enum TempEntityType {..., TE_STREAK_SPLASH, ...}": {
		"prefix": "TE_STREAK_SPLASH",
		"body" : [ "TE_STREAK_SPLASH" ],
		"description" : "(25) Oriented shower of tracers"
	},
	"enum TempEntityType {..., TE_DLIGHT, ...}": {
		"prefix": "TE_DLIGHT",
		"body" : [ "TE_DLIGHT" ],
		"description" : "(27) Dynamic light effect"
	},
	"enum TempEntityType {..., TE_ELIGHT, ...}": {
		"prefix": "TE_ELIGHT",
		"body" : [ "TE_ELIGHT" ],
		"description" : "(28) Point entity light, no world effect"
	},
	"enum TempEntityType {..., TE_TEXTMESSAGE, ...}": {
		"prefix": "TE_TEXTMESSAGE",
		"body" : [ "TE_TEXTMESSAGE" ],
		"description" : "(29) Text message"
	},
	"enum TempEntityType {..., TE_LINE, ...}": {
		"prefix": "TE_LINE",
		"body" : [ "TE_LINE" ],
		"description" : "(30) Draws a line"
	},
	"enum TempEntityType {..., TE_BOX, ...}": {
		"prefix": "TE_BOX",
		"body" : [ "TE_BOX" ],
		"description" : "(31) Draws a box"
	},
	"enum TempEntityType {..., TE_KILLBEAM, ...}": {
		"prefix": "TE_KILLBEAM",
		"body" : [ "TE_KILLBEAM" ],
		"description" : "(99) Kill all beams attached to entity"
	},
	"enum TempEntityType {..., TE_LARGEFUNNEL, ...}": {
		"prefix": "TE_LARGEFUNNEL",
		"body" : [ "TE_LARGEFUNNEL" ],
		"description" : "(100) Creates a large funnel"
	},
	"enum TempEntityType {..., TE_BLOODSTREAM, ...}": {
		"prefix": "TE_BLOODSTREAM",
		"body" : [ "TE_BLOODSTREAM" ],
		"description" : "(101) Particle spray"
	},
	"enum TempEntityType {..., TE_SHOWLINE, ...}": {
		"prefix": "TE_SHOWLINE",
		"body" : [ "TE_SHOWLINE" ],
		"description" : "(102) Line of particles every 5 units, dies in 30 seconds"
	},
	"enum TempEntityType {..., TE_BLOOD, ...}": {
		"prefix": "TE_BLOOD",
		"body" : [ "TE_BLOOD" ],
		"description" : "(103) Particle spray"
	},
	"enum TempEntityType {..., TE_DECAL, ...}": {
		"prefix": "TE_DECAL",
		"body" : [ "TE_DECAL" ],
		"description" : "(104) Decal applied to a brush entity (not the world)"
	},
	"enum TempEntityType {..., TE_FIZZ, ...}": {
		"prefix": "TE_FIZZ",
		"body" : [ "TE_FIZZ" ],
		"description" : "(105) Create alpha sprites inside of entity, float upwards"
	},
	"enum TempEntityType {..., TE_MODEL, ...}": {
		"prefix": "TE_MODEL",
		"body" : [ "TE_MODEL" ],
		"description" : "(106) Create a moving model that bounces and makes a sound when it hits"
	},
	"enum TempEntityType {..., TE_EXPLODEMODEL, ...}": {
		"prefix": "TE_EXPLODEMODEL",
		"body" : [ "TE_EXPLODEMODEL" ],
		"description" : "(107) Spherical shower of models, picks from sets"
	},
	"enum TempEntityType {..., TE_BREAKMODEL, ...}": {
		"prefix": "TE_BREAKMODEL",
		"body" : [ "TE_BREAKMODEL" ],
		"description" : "(108) Box of models or sprites"
	},
	"enum TempEntityType {..., TE_GUNSHOTDECAL, ...}": {
		"prefix": "TE_GUNSHOTDECAL",
		"body" : [ "TE_GUNSHOTDECAL" ],
		"description" : "(109) Decal and ricochet sound"
	},
	"enum TempEntityType {..., TE_SPRITE_SPRAY, ...}": {
		"prefix": "TE_SPRITE_SPRAY",
		"body" : [ "TE_SPRITE_SPRAY" ],
		"description" : "(110) Spray of alpha sprites"
	},
	"enum TempEntityType {..., TE_ARMOR_RICOCHET, ...}": {
		"prefix": "TE_ARMOR_RICOCHET",
		"body" : [ "TE_ARMOR_RICOCHET" ],
		"description" : "(111) Quick spark sprite, client ricochet sound. "
	},
	"enum TempEntityType {..., TE_PLAYERDECAL, ...}": {
		"prefix": "TE_PLAYERDECAL",
		"body" : [ "TE_PLAYERDECAL" ],
		"description" : "(112) Draw a player decal (spray paint)"
	},
	"enum TempEntityType {..., TE_BUBBLES, ...}": {
		"prefix": "TE_BUBBLES",
		"body" : [ "TE_BUBBLES" ],
		"description" : "(113) Create alpha sprites inside of box, float upwards"
	},
	"enum TempEntityType {..., TE_BUBBLETRAIL, ...}": {
		"prefix": "TE_BUBBLETRAIL",
		"body" : [ "TE_BUBBLETRAIL" ],
		"description" : "(114) Create alpha sprites along a line, float upwards"
	},
	"enum TempEntityType {..., TE_BLOODSPRITE, ...}": {
		"prefix": "TE_BLOODSPRITE",
		"body" : [ "TE_BLOODSPRITE" ],
		"description" : "(115) Spray of opaque sprite1's that fall, single sprite2 for 1..2 secs (this is a high-priority tent)"
	},
	"enum TempEntityType {..., TE_WORLDDECAL, ...}": {
		"prefix": "TE_WORLDDECAL",
		"body" : [ "TE_WORLDDECAL" ],
		"description" : "(116) Decal applied to the world brush"
	},
	"enum TempEntityType {..., TE_WORLDDECALHIGH, ...}": {
		"prefix": "TE_WORLDDECALHIGH",
		"body" : [ "TE_WORLDDECALHIGH" ],
		"description" : "(117) Decal (with texture index > 256) applied to world brush"
	},
	"enum TempEntityType {..., TE_DECALHIGH, ...}": {
		"prefix": "TE_DECALHIGH",
		"body" : [ "TE_DECALHIGH" ],
		"description" : "(118) Same as TE_DECAL, but the texture index was greater than 256"
	},
	"enum TempEntityType {..., TE_PROJECTILE, ...}": {
		"prefix": "TE_PROJECTILE",
		"body" : [ "TE_PROJECTILE" ],
		"description" : "(119) Makes a projectile (like a nail) (this is a high-priority tent)"
	},
	"enum TempEntityType {..., TE_SPRAY, ...}": {
		"prefix": "TE_SPRAY",
		"body" : [ "TE_SPRAY" ],
		"description" : "(120) Throws a shower of sprites or models"
	},
	"enum TempEntityType {..., TE_PLAYERSPRITES, ...}": {
		"prefix": "TE_PLAYERSPRITES",
		"body" : [ "TE_PLAYERSPRITES" ],
		"description" : "(121) Sprites emit from a player's bounding box (ONLY use for players!)"
	},
	"enum TempEntityType {..., TE_PARTICLEBURST, ...}": {
		"prefix": "TE_PARTICLEBURST",
		"body" : [ "TE_PARTICLEBURST" ],
		"description" : "(122) Very similar to lavasplash."
	},
	"enum TempEntityType {..., TE_FIREFIELD, ...}": {
		"prefix": "TE_FIREFIELD",
		"body" : [ "TE_FIREFIELD" ],
		"description" : "(123) Makes a field of fire."
	},
	"enum TempEntityType {..., TE_PLAYERATTACHMENT, ...}": {
		"prefix": "TE_PLAYERATTACHMENT",
		"body" : [ "TE_PLAYERATTACHMENT" ],
		"description" : "(124) Attaches a TENT to a player (this is a high-priority tent)"
	},
	"enum TempEntityType {..., TE_KILLPLAYERATTACHMENTS, ...}": {
		"prefix": "TE_KILLPLAYERATTACHMENTS",
		"body" : [ "TE_KILLPLAYERATTACHMENTS" ],
		"description" : "(125) Will expire all TENTS attached to a player."
	},
	"enum TempEntityType {..., TE_MULTIGUNSHOT, ...}": {
		"prefix": "TE_MULTIGUNSHOT",
		"body" : [ "TE_MULTIGUNSHOT" ],
		"description" : "(126) Much more compact shotgun message"
	},
	"enum TempEntityType {..., TE_USERTRACER, ...}": {
		"prefix": "TE_USERTRACER",
		"body" : [ "TE_USERTRACER" ],
		"description" : "(127) Larger message than the standard tracer, but allows some customization."
	},
	"enum TextureType {..., CHAR_TEX_CONCRETE, ...}": {
		"prefix": "CHAR_TEX_CONCRETE",
		"body" : [ "CHAR_TEX_CONCRETE" ],
		"description" : "('C') Concrete (Default)"
	},
	"enum TextureType {..., CHAR_TEX_METAL, ...}": {
		"prefix": "CHAR_TEX_METAL",
		"body" : [ "CHAR_TEX_METAL" ],
		"description" : "('M') Metal"
	},
	"enum TextureType {..., CHAR_TEX_DIRT, ...}": {
		"prefix": "CHAR_TEX_DIRT",
		"body" : [ "CHAR_TEX_DIRT" ],
		"description" : "('D') Dirt"
	},
	"enum TextureType {..., CHAR_TEX_VENT, ...}": {
		"prefix": "CHAR_TEX_VENT",
		"body" : [ "CHAR_TEX_VENT" ],
		"description" : "('V') Vent"
	},
	"enum TextureType {..., CHAR_TEX_GRATE, ...}": {
		"prefix": "CHAR_TEX_GRATE",
		"body" : [ "CHAR_TEX_GRATE" ],
		"description" : "('G') Grate"
	},
	"enum TextureType {..., CHAR_TEX_TILE, ...}": {
		"prefix": "CHAR_TEX_TILE",
		"body" : [ "CHAR_TEX_TILE" ],
		"description" : "('T') Tile"
	},
	"enum TextureType {..., CHAR_TEX_SLOSH, ...}": {
		"prefix": "CHAR_TEX_SLOSH",
		"body" : [ "CHAR_TEX_SLOSH" ],
		"description" : "('S') Slosh"
	},
	"enum TextureType {..., CHAR_TEX_WOOD, ...}": {
		"prefix": "CHAR_TEX_WOOD",
		"body" : [ "CHAR_TEX_WOOD" ],
		"description" : "('W') Wood"
	},
	"enum TextureType {..., CHAR_TEX_COMPUTER, ...}": {
		"prefix": "CHAR_TEX_COMPUTER",
		"body" : [ "CHAR_TEX_COMPUTER" ],
		"description" : "('P') Computer"
	},
	"enum TextureType {..., CHAR_TEX_GLASS, ...}": {
		"prefix": "CHAR_TEX_GLASS",
		"body" : [ "CHAR_TEX_GLASS" ],
		"description" : "('Y') Glass"
	},
	"enum TextureType {..., CHAR_TEX_FLESH, ...}": {
		"prefix": "CHAR_TEX_FLESH",
		"body" : [ "CHAR_TEX_FLESH" ],
		"description" : "('F') Flesh"
	},
	"enum TextureType {..., CHAR_TEX_SNOW, ...}": {
		"prefix": "CHAR_TEX_SNOW",
		"body" : [ "CHAR_TEX_SNOW" ],
		"description" : "('O') Snow"
	},
	"void TimeDifference::TimeDifference()": {
		"prefix": "TimeDifference",
		"body" : [ "TimeDifference()" ],
		"description" : "Default constructor"
	},
	"void TimeDifference::TimeDifference(const TimeDifference& in other)": {
		"prefix": "TimeDifference",
		"body" : [ "TimeDifference( ${1:const TimeDifference& in other} )" ],
		"description" : "Copy constructor"
	},
	"void TimeDifference::TimeDifference(double flValue)": {
		"prefix": "TimeDifference",
		"body" : [ "TimeDifference( ${1:double flValue} )" ],
		"description" : "Sets the time difference to the given value, in seconds"
	},
	"void TimeDifference::TimeDifference(const DateTime& in end, const DateTime& in begin)": {
		"prefix": "TimeDifference",
		"body" : [ "TimeDifference( ${1:const DateTime& in end}, ${2:const DateTime& in begin} )" ],
		"description" : "Sets the time difference to the range between beginning and end. If begin is later than end, is negative."
	},
	"void TimeDifference::TimeDifference(const DateTime& in time)": {
		"prefix": "TimeDifference",
		"body" : [ "TimeDifference( ${1:const DateTime& in time} )" ],
		"description" : "Sets the time difference to the range between 0 and time."
	},
	"TimeDifference& TimeDifference::opAssign(const TimeDifference& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const TimeDifference& in other} )" ],
		"description" : "Assignment operator"
	},
	"TimeDifference& TimeDifference::opAssign(double timeDiff)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:double timeDiff} )" ],
		"description" : "Assignment operator"
	},
	"TimeDifference& TimeDifference::opAssign(const DateTime& in time)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const DateTime& in time} )" ],
		"description" : "Assignment operator"
	},
	"double TimeDifference::GetTimeDifference() const": {
		"prefix": "GetTimeDifference",
		"body" : [ "GetTimeDifference()" ],
		"description" : "Gets the time difference"
	},
	"bool TimeDifference::IsPositive() const": {
		"prefix": "IsPositive",
		"body" : [ "IsPositive()" ],
		"description" : "Returns whether the time difference is positive."
	},
	"int TimeDifference::GetSeconds() const": {
		"prefix": "GetSeconds",
		"body" : [ "GetSeconds()" ],
		"description" : "Gets the time difference in seconds."
	},
	"int TimeDifference::GetMinutes() const": {
		"prefix": "GetMinutes",
		"body" : [ "GetMinutes()" ],
		"description" : "Gets the time difference in minutes."
	},
	"int TimeDifference::GetHours() const": {
		"prefix": "GetHours",
		"body" : [ "GetHours()" ],
		"description" : "Gets the time difference in hours."
	},
	"int TimeDifference::GetDays() const": {
		"prefix": "GetDays",
		"body" : [ "GetDays()" ],
		"description" : "Gets the time difference in days."
	},
	"int TimeDifference::GetYears() const": {
		"prefix": "GetYears",
		"body" : [ "GetYears()" ],
		"description" : "Gets the time difference in years."
	},
	"void TimeDifference::MakeAbsolute()": {
		"prefix": "MakeAbsolute",
		"body" : [ "MakeAbsolute()" ],
		"description" : "Makes the time difference absolute."
	},
	"void TimeDifference::SetDifferenceBetween(const DateTime& in end, const DateTime& in begin)": {
		"prefix": "SetDifferenceBetween",
		"body" : [ "SetDifferenceBetween( ${1:const DateTime& in end}, ${2:const DateTime& in begin} )" ],
		"description" : "Sets the time difference to the range between beginning and end. If begin is later than end, is negative."
	},
	"void TimeDifference::SetTime(const DateTime& in time)": {
		"prefix": "SetTime",
		"body" : [ "SetTime( ${1:const DateTime& in time} )" ],
		"description" : "Sets the time difference to the range between 0 and time."
	},
	"enum TOGGLE_STATE {..., TS_AT_TOP, ...}": {
		"prefix": "TS_AT_TOP",
		"body" : [ "TS_AT_TOP" ],
		"description" : "(0) Entity is at top"
	},
	"enum TOGGLE_STATE {..., TS_AT_BOTTOM, ...}": {
		"prefix": "TS_AT_BOTTOM",
		"body" : [ "TS_AT_BOTTOM" ],
		"description" : "(1) Entity is at bottom"
	},
	"enum TOGGLE_STATE {..., TS_GOING_UP, ...}": {
		"prefix": "TS_GOING_UP",
		"body" : [ "TS_GOING_UP" ],
		"description" : "(2) Entity is going up"
	},
	"enum TOGGLE_STATE {..., TS_GOING_DOWN, ...}": {
		"prefix": "TS_GOING_DOWN",
		"body" : [ "TS_GOING_DOWN" ],
		"description" : "(3) Entity is going down"
	},
	"void TraceResult::TraceResult()": {
		"prefix": "TraceResult",
		"body" : [ "TraceResult()" ],
		"description" : "Constructor."
	},
	"void TraceResult::TraceResult(const TraceResult& in tr)": {
		"prefix": "TraceResult",
		"body" : [ "TraceResult( ${1:const TraceResult& in tr} )" ],
		"description" : "Constructor."
	},
	"TraceResult& TraceResult::opAssign(const TraceResult& in tr)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const TraceResult& in tr} )" ],
		"description" : "Assignment operator"
	},
	"int TraceResult::fAllSolid": {
		"prefix": "fAllSolid",
		"body" : [ "fAllSolid" ],
		"description" : "Flag telling whether the trace occured in an all solid area."
	},
	"int TraceResult::fStartSolid": {
		"prefix": "fStartSolid",
		"body" : [ "fStartSolid" ],
		"description" : "Flag telling whether the trace started in a solid area."
	},
	"int TraceResult::fInOpen": {
		"prefix": "fInOpen",
		"body" : [ "fInOpen" ],
		"description" : "Flag telling whether the trace ended in an open area."
	},
	"int TraceResult::fInWater": {
		"prefix": "fInWater",
		"body" : [ "fInWater" ],
		"description" : "Flag telling whether the trace ended in water"
	},
	"float TraceResult::flFraction": {
		"prefix": "flFraction",
		"body" : [ "flFraction" ],
		"description" : "Fraction."
	},
	"Vector TraceResult::vecEndPos": {
		"prefix": "vecEndPos",
		"body" : [ "vecEndPos" ],
		"description" : "End position."
	},
	"float TraceResult::flPlaneDist": {
		"prefix": "flPlaneDist",
		"body" : [ "flPlaneDist" ],
		"description" : "Plane distance."
	},
	"Vector TraceResult::vecPlaneNormal": {
		"prefix": "vecPlaneNormal",
		"body" : [ "vecPlaneNormal" ],
		"description" : "Plane normal"
	},
	"edict_t@ TraceResult::pHit": {
		"prefix": "pHit",
		"body" : [ "pHit" ],
		"description" : "Hit entity"
	},
	"int TraceResult::iHitgroup": {
		"prefix": "iHitgroup",
		"body" : [ "iHitgroup" ],
		"description" : "Hit group."
	},
	"enum Train {..., TRAIN_ACTIVE, ...}": {
		"prefix": "TRAIN_ACTIVE",
		"body" : [ "TRAIN_ACTIVE" ],
		"description" : "(128)"
	},
	"enum Train {..., TRAIN_NEW, ...}": {
		"prefix": "TRAIN_NEW",
		"body" : [ "TRAIN_NEW" ],
		"description" : "(192)"
	},
	"enum Train {..., TRAIN_OFF, ...}": {
		"prefix": "TRAIN_OFF",
		"body" : [ "TRAIN_OFF" ],
		"description" : "(0)"
	},
	"enum Train {..., TRAIN_NEUTRAL, ...}": {
		"prefix": "TRAIN_NEUTRAL",
		"body" : [ "TRAIN_NEUTRAL" ],
		"description" : "(1)"
	},
	"enum Train {..., TRAIN_SLOW, ...}": {
		"prefix": "TRAIN_SLOW",
		"body" : [ "TRAIN_SLOW" ],
		"description" : "(2)"
	},
	"enum Train {..., TRAIN_MEDIUM, ...}": {
		"prefix": "TRAIN_MEDIUM",
		"body" : [ "TRAIN_MEDIUM" ],
		"description" : "(3)"
	},
	"enum Train {..., TRAIN_FAST, ...}": {
		"prefix": "TRAIN_FAST",
		"body" : [ "TRAIN_FAST" ],
		"description" : "(4)"
	},
	"enum Train {..., TRAIN_BACK, ...}": {
		"prefix": "TRAIN_BACK",
		"body" : [ "TRAIN_BACK" ],
		"description" : "(5)"
	},
	"enum ConCommandKind::Type {..., ConCommand, ...}": {
		"prefix": "ConCommand",
		"body" : [ "ConCommandKind::ConCommand" ],
		"description" : "(1) This console command is a command"
	},
	"enum ConCommandKind::Type {..., ClientCommand, ...}": {
		"prefix": "ClientCommand",
		"body" : [ "ConCommandKind::ClientCommand" ],
		"description" : "(2) This console command is a client command"
	},
	"enum ConCommandKind::Type {..., CVar, ...}": {
		"prefix": "CVar",
		"body" : [ "ConCommandKind::CVar" ],
		"description" : "(3) This console command is a cvar"
	},
	"uint32 size_t": {
		"prefix": "size_t",
		"body" : [ "size_t" ],
		"description" : "Size type used for denoting sizes"
	},
	"uint8 OpenFileFlags_t": {
		"prefix": "OpenFileFlags_t",
		"body" : [ "OpenFileFlags_t" ],
		"description" : "Open File Flags"
	},
	"uint8 SeekFileFlags_t": {
		"prefix": "SeekFileFlags_t",
		"body" : [ "SeekFileFlags_t" ],
		"description" : "Seek File Flags"
	},
	"uint PersistID_t": {
		"prefix": "PersistID_t",
		"body" : [ "PersistID_t" ],
		"description" : "Persistence object id type."
	},
	"int32 TextMenuId_t": {
		"prefix": "TextMenuId_t",
		"body" : [ "TextMenuId_t" ],
		"description" : "Menu id."
	},
	"uint64 time_t": {
		"prefix": "time_t",
		"body" : [ "time_t" ],
		"description" : "Unix timestamp type."
	},
	"uint32 ConCommandFlags_t": {
		"prefix": "ConCommandFlags_t",
		"body" : [ "ConCommandFlags_t" ],
		"description" : "Type to store console command flags in"
	},
	"enum USE_TYPE {..., USE_OFF, ...}": {
		"prefix": "USE_OFF",
		"body" : [ "USE_OFF" ],
		"description" : "(0) Turns off an entity"
	},
	"enum USE_TYPE {..., USE_ON, ...}": {
		"prefix": "USE_ON",
		"body" : [ "USE_ON" ],
		"description" : "(1) Turns on an entity"
	},
	"enum USE_TYPE {..., USE_SET, ...}": {
		"prefix": "USE_SET",
		"body" : [ "USE_SET" ],
		"description" : "(2) Sets the state of an entity (use float parameter in Use)"
	},
	"enum USE_TYPE {..., USE_TOGGLE, ...}": {
		"prefix": "USE_TOGGLE",
		"body" : [ "USE_TOGGLE" ],
		"description" : "(3) Toggles the state of an entity"
	},
	"enum USE_TYPE {..., USE_KILL, ...}": {
		"prefix": "USE_KILL",
		"body" : [ "USE_KILL" ],
		"description" : "(4) Kills an entity"
	},
	"void Vector::Vector()": {
		"prefix": "Vector",
		"body" : [ "Vector()" ],
		"description" : "Default constructs a 3D vector (0, 0, 0)"
	},
	"void Vector::Vector(const Vector& in vec)": {
		"prefix": "Vector",
		"body" : [ "Vector( ${1:const Vector& in vec} )" ],
		"description" : "Copy constructs a 3D vector"
	},
	"void Vector::Vector(float x, float y, float z)": {
		"prefix": "Vector",
		"body" : [ "Vector( ${1:float x}, ${2:float y}, ${3:float z} )" ],
		"description" : "Constructs a 3D vector from 3 floats"
	},
	"Vector& Vector::opAssign(const Vector& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const Vector& in other} )" ],
		"description" : "Assign vector"
	},
	"Vector Vector::opNeg() const": {
		"prefix": "opNeg",
		"body" : [ "opNeg()" ],
		"description" : "Negate vector"
	},
	"Vector Vector::opAdd(const Vector& in other) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:const Vector& in other} )" ],
		"description" : "Add vectors"
	},
	"Vector Vector::opSub(const Vector& in other) const": {
		"prefix": "opSub",
		"body" : [ "opSub( ${1:const Vector& in other} )" ],
		"description" : "Subtract vectors"
	},
	"Vector Vector::opMul(float fl) const": {
		"prefix": "opMul",
		"body" : [ "opMul( ${1:float fl} )" ],
		"description" : "Multiply vector by value"
	},
	"Vector Vector::opMul_r(float fl) const": {
		"prefix": "opMul_r",
		"body" : [ "opMul_r( ${1:float fl} )" ],
		"description" : "Multiply vector by value"
	},
	"Vector Vector::opDiv(float fl) const": {
		"prefix": "opDiv",
		"body" : [ "opDiv( ${1:float fl} )" ],
		"description" : "Divide vector by value"
	},
	"Vector Vector::opDiv_r(float fl) const": {
		"prefix": "opDiv_r",
		"body" : [ "opDiv_r( ${1:float fl} )" ],
		"description" : "Divide vector by value"
	},
	"float& Vector::opIndex(size_t uiIndex)": {
		"prefix": "opIndex",
		"body" : [ "opIndex( ${1:size_t uiIndex} )" ],
		"description" : "Index operator"
	},
	"float Vector::opIndex(size_t uiIndex) const": {
		"prefix": "opIndex",
		"body" : [ "opIndex( ${1:size_t uiIndex} )" ],
		"description" : "Index operator"
	},
	"bool Vector::opEquals(const Vector& in other) const": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:const Vector& in other} )" ],
		"description" : "Compare vectors"
	},
	"Vector Vector::opMul(const Vector& in other) const": {
		"prefix": "opMul",
		"body" : [ "opMul( ${1:const Vector& in other} )" ],
		"description" : "Multiply vectors"
	},
	"Vector Vector::opDiv(const Vector& in other) const": {
		"prefix": "opDiv",
		"body" : [ "opDiv( ${1:const Vector& in other} )" ],
		"description" : "Divide vectors"
	},
	"float Vector::Length() const": {
		"prefix": "Length",
		"body" : [ "Length()" ],
		"description" : "Gets the length of this vector"
	},
	"float Vector::Length2D() const": {
		"prefix": "Length2D",
		"body" : [ "Length2D()" ],
		"description" : "Gets the length of this vector in 2D"
	},
	"Vector Vector::Normalize() const": {
		"prefix": "Normalize",
		"body" : [ "Normalize()" ],
		"description" : "Returns the normalized form of this vector"
	},
	"Vector2D Vector::Make2D() const": {
		"prefix": "Make2D",
		"body" : [ "Make2D()" ],
		"description" : "Returns the 2D form of this vector"
	},
	"string Vector::ToString() const": {
		"prefix": "ToString",
		"body" : [ "ToString()" ],
		"description" : "Returns a string representation of this vector"
	},
	"float Vector::x": {
		"prefix": "x",
		"body" : [ "x" ],
		"description" : "Vector x variable"
	},
	"float Vector::y": {
		"prefix": "y",
		"body" : [ "y" ],
		"description" : "Vector y variable"
	},
	"float Vector::z": {
		"prefix": "z",
		"body" : [ "z" ],
		"description" : "Vector z variable"
	},
	"void Vector2D::Vector2D()": {
		"prefix": "Vector2D",
		"body" : [ "Vector2D()" ],
		"description" : "Default constructs a 2D vector (0, 0)"
	},
	"void Vector2D::Vector2D(const Vector2D& in other)": {
		"prefix": "Vector2D",
		"body" : [ "Vector2D( ${1:const Vector2D& in other} )" ],
		"description" : "Copy constructs a 2D vector"
	},
	"void Vector2D::Vector2D(float x, float y)": {
		"prefix": "Vector2D",
		"body" : [ "Vector2D( ${1:float x}, ${2:float y} )" ],
		"description" : "Constructs a 2D vector from 2 floats"
	},
	"Vector2D& Vector2D::opAssign(const Vector2D& in other)": {
		"prefix": "opAssign",
		"body" : [ "opAssign( ${1:const Vector2D& in other} )" ],
		"description" : "Assign vector"
	},
	"Vector2D Vector2D::opAdd(const Vector2D& in other) const": {
		"prefix": "opAdd",
		"body" : [ "opAdd( ${1:const Vector2D& in other} )" ],
		"description" : "Add vectors"
	},
	"Vector2D Vector2D::opSub(const Vector2D& in other) const": {
		"prefix": "opSub",
		"body" : [ "opSub( ${1:const Vector2D& in other} )" ],
		"description" : "Subtract vectors"
	},
	"Vector2D Vector2D::opMul(float fl) const": {
		"prefix": "opMul",
		"body" : [ "opMul( ${1:float fl} )" ],
		"description" : "Multiply vector by a value"
	},
	"Vector2D Vector2D::opMul_r(float fl) const": {
		"prefix": "opMul_r",
		"body" : [ "opMul_r( ${1:float fl} )" ],
		"description" : "Multiply vector by a value"
	},
	"Vector2D Vector2D::opDiv(float fl) const": {
		"prefix": "opDiv",
		"body" : [ "opDiv( ${1:float fl} )" ],
		"description" : "Divide vector by a value"
	},
	"Vector2D Vector2D::opDiv_r(float fl) const": {
		"prefix": "opDiv_r",
		"body" : [ "opDiv_r( ${1:float fl} )" ],
		"description" : "Divide vector by a value"
	},
	"bool Vector2D::opEquals(const Vector2D& in other) const": {
		"prefix": "opEquals",
		"body" : [ "opEquals( ${1:const Vector2D& in other} )" ],
		"description" : "Compare vectors"
	},
	"float Vector2D::Length() const": {
		"prefix": "Length",
		"body" : [ "Length()" ],
		"description" : "Gets the length of this vector"
	},
	"Vector2D Vector2D::Normalize() const": {
		"prefix": "Normalize",
		"body" : [ "Normalize()" ],
		"description" : "Returns the normalized form of this vector"
	},
	"string Vector2D::ToString() const": {
		"prefix": "ToString",
		"body" : [ "ToString()" ],
		"description" : "Returns a string representation of this vector"
	},
	"float Vector2D::x": {
		"prefix": "x",
		"body" : [ "x" ],
		"description" : "Vector2D x variable"
	},
	"float Vector2D::y": {
		"prefix": "y",
		"body" : [ "y" ],
		"description" : "Vector2D y variable"
	},
	"Vote@ Vote::Vote(const string& in szName, const string& in szVoteText, float flVoteLength, float flPercentageNeeded)": {
		"prefix": "Vote",
		"body" : [ "Vote( ${1:const string& in szName}, ${2:const string& in szVoteText}, ${3:float flVoteLength}, ${4:float flPercentageNeeded} )" ],
		"description" : "Constructor"
	},
	"const string& Vote::GetName() const": {
		"prefix": "GetName",
		"body" : [ "GetName()" ],
		"description" : "Gets name of this vote."
	},
	"const string& Vote::GetVoteText() const": {
		"prefix": "GetVoteText",
		"body" : [ "GetVoteText()" ],
		"description" : "Gets the vote text."
	},
	"void Vote::SetVoteText(const string& in szVoteText)": {
		"prefix": "SetVoteText",
		"body" : [ "SetVoteText( ${1:const string& in szVoteText} )" ],
		"description" : "Sets the vote text."
	},
	"const string& Vote::GetYesText() const": {
		"prefix": "GetYesText",
		"body" : [ "GetYesText()" ],
		"description" : "Gets the yes button text."
	},
	"void Vote::SetYesText(const string& in szYesText)": {
		"prefix": "SetYesText",
		"body" : [ "SetYesText( ${1:const string& in szYesText} )" ],
		"description" : "Sets the yes button text."
	},
	"const string& Vote::GetNoText() const": {
		"prefix": "GetNoText",
		"body" : [ "GetNoText()" ],
		"description" : "Gets the no button text."
	},
	"void Vote::SetNoText(const string& in szNoText)": {
		"prefix": "SetNoText",
		"body" : [ "SetNoText( ${1:const string& in szNoText} )" ],
		"description" : "Sets the no button text."
	},
	"void Vote::SetVoteBlockedCallback(VoteBlocked@ pCallback)": {
		"prefix": "SetVoteBlockedCallback",
		"body" : [ "SetVoteBlockedCallback( ${1:VoteBlocked@ pCallback} )" ],
		"description" : "Sets the vote blocked callback."
	},
	"void Vote::SetVoteEndCallback(VoteEnd@ pCallback)": {
		"prefix": "SetVoteEndCallback",
		"body" : [ "SetVoteEndCallback( ${1:VoteEnd@ pCallback} )" ],
		"description" : "Sets the vote end callback."
	},
	"void Vote::Start()": {
		"prefix": "Start",
		"body" : [ "Start()" ],
		"description" : "Starts this vote."
	},
	"any@ Vote::GetUserData()": {
		"prefix": "GetUserData",
		"body" : [ "GetUserData()" ],
		"description" : "Gets the user data set on this vote."
	},
	"void Vote::SetUserData(any@ pUserData)": {
		"prefix": "SetUserData",
		"body" : [ "SetUserData( ${1:any@ pUserData} )" ],
		"description" : "Sets the user data on this vote."
	},
	"void Vote::ClearUserData()": {
		"prefix": "ClearUserData",
		"body" : [ "ClearUserData()" ],
		"description" : "Clears the user data set on this vote."
	},
	"enum WALKMOVE {..., WALKMOVE_NORMAL, ...}": {
		"prefix": "WALKMOVE_NORMAL",
		"body" : [ "WALKMOVE_NORMAL" ],
		"description" : "(0) normal walkmove"
	},
	"enum WALKMOVE {..., WALKMOVE_WORLDONLY, ...}": {
		"prefix": "WALKMOVE_WORLDONLY",
		"body" : [ "WALKMOVE_WORLDONLY" ],
		"description" : "(1) doesn't hit ANY entities, no matter what the solid type"
	},
	"enum WALKMOVE {..., WALKMOVE_CHECKONLY, ...}": {
		"prefix": "WALKMOVE_CHECKONLY",
		"body" : [ "WALKMOVE_CHECKONLY" ],
		"description" : "(2) move, but don't touch triggers"
	},
	"enum WATERLEVEL {..., WATERLEVEL_DRY, ...}": {
		"prefix": "WATERLEVEL_DRY",
		"body" : [ "WATERLEVEL_DRY" ],
		"description" : "(0) Not in water"
	},
	"enum WATERLEVEL {..., WATERLEVEL_FEET, ...}": {
		"prefix": "WATERLEVEL_FEET",
		"body" : [ "WATERLEVEL_FEET" ],
		"description" : "(1) Feet underwater"
	},
	"enum WATERLEVEL {..., WATERLEVEL_WAIST, ...}": {
		"prefix": "WATERLEVEL_WAIST",
		"body" : [ "WATERLEVEL_WAIST" ],
		"description" : "(2) Waist underwater"
	},
	"enum WATERLEVEL {..., WATERLEVEL_HEAD, ...}": {
		"prefix": "WATERLEVEL_HEAD",
		"body" : [ "WATERLEVEL_HEAD" ],
		"description" : "(3) Head underwater (completely submerged)"
	},
	"Vector Waypoint::vecLocation": {
		"prefix": "vecLocation",
		"body" : [ "vecLocation" ],
		"description" : "Location of this waypoint."
	},
	"Vector Waypoint::vecJumpVelocity": {
		"prefix": "vecJumpVelocity",
		"body" : [ "vecJumpVelocity" ],
		"description" : "Saved jump velocity."
	},
	"Vector Waypoint::vecLadderVelocity": {
		"prefix": "vecLadderVelocity",
		"body" : [ "vecLadderVelocity" ],
		"description" : "Saved ladder velocity."
	},
	"EHandle Waypoint::hDoor": {
		"prefix": "hDoor",
		"body" : [ "hDoor" ],
		"description" : "Handle to a door to use."
	},
	"float Waypoint::flSavedMoveWait": {
		"prefix": "flSavedMoveWait",
		"body" : [ "flSavedMoveWait" ],
		"description" : "How long to wait on this waypoint."
	},
	"int Waypoint::iType": {
		"prefix": "iType",
		"body" : [ "iType" ],
		"description" : "Type(s) of this waypoint."
	},
	"enum WeaponIds {..., WEAPON_NONE, ...}": {
		"prefix": "WEAPON_NONE",
		"body" : [ "WEAPON_NONE" ],
		"description" : "(0) Weapon id used for invalid weapon ids."
	},
	"enum WeaponIds {..., WEAPON_CROWBAR, ...}": {
		"prefix": "WEAPON_CROWBAR",
		"body" : [ "WEAPON_CROWBAR" ],
		"description" : "(1)"
	},
	"enum WeaponIds {..., WEAPON_GLOCK, ...}": {
		"prefix": "WEAPON_GLOCK",
		"body" : [ "WEAPON_GLOCK" ],
		"description" : "(2)"
	},
	"enum WeaponIds {..., WEAPON_PYTHON, ...}": {
		"prefix": "WEAPON_PYTHON",
		"body" : [ "WEAPON_PYTHON" ],
		"description" : "(3)"
	},
	"enum WeaponIds {..., WEAPON_MP5, ...}": {
		"prefix": "WEAPON_MP5",
		"body" : [ "WEAPON_MP5" ],
		"description" : "(4)"
	},
	"enum WeaponIds {..., WEAPON_CHAINGUN, ...}": {
		"prefix": "WEAPON_CHAINGUN",
		"body" : [ "WEAPON_CHAINGUN" ],
		"description" : "(5)"
	},
	"enum WeaponIds {..., WEAPON_CROSSBOW, ...}": {
		"prefix": "WEAPON_CROSSBOW",
		"body" : [ "WEAPON_CROSSBOW" ],
		"description" : "(6)"
	},
	"enum WeaponIds {..., WEAPON_SHOTGUN, ...}": {
		"prefix": "WEAPON_SHOTGUN",
		"body" : [ "WEAPON_SHOTGUN" ],
		"description" : "(7)"
	},
	"enum WeaponIds {..., WEAPON_RPG, ...}": {
		"prefix": "WEAPON_RPG",
		"body" : [ "WEAPON_RPG" ],
		"description" : "(8)"
	},
	"enum WeaponIds {..., WEAPON_GAUSS, ...}": {
		"prefix": "WEAPON_GAUSS",
		"body" : [ "WEAPON_GAUSS" ],
		"description" : "(9)"
	},
	"enum WeaponIds {..., WEAPON_EGON, ...}": {
		"prefix": "WEAPON_EGON",
		"body" : [ "WEAPON_EGON" ],
		"description" : "(10)"
	},
	"enum WeaponIds {..., WEAPON_HORNETGUN, ...}": {
		"prefix": "WEAPON_HORNETGUN",
		"body" : [ "WEAPON_HORNETGUN" ],
		"description" : "(11)"
	},
	"enum WeaponIds {..., WEAPON_HANDGRENADE, ...}": {
		"prefix": "WEAPON_HANDGRENADE",
		"body" : [ "WEAPON_HANDGRENADE" ],
		"description" : "(12)"
	},
	"enum WeaponIds {..., WEAPON_TRIPMINE, ...}": {
		"prefix": "WEAPON_TRIPMINE",
		"body" : [ "WEAPON_TRIPMINE" ],
		"description" : "(13)"
	},
	"enum WeaponIds {..., WEAPON_SATCHEL, ...}": {
		"prefix": "WEAPON_SATCHEL",
		"body" : [ "WEAPON_SATCHEL" ],
		"description" : "(14)"
	},
	"enum WeaponIds {..., WEAPON_SNARK, ...}": {
		"prefix": "WEAPON_SNARK",
		"body" : [ "WEAPON_SNARK" ],
		"description" : "(15)"
	},
	"enum WeaponIds {..., WEAPON_UZI, ...}": {
		"prefix": "WEAPON_UZI",
		"body" : [ "WEAPON_UZI" ],
		"description" : "(17)"
	},
	"enum WeaponIds {..., WEAPON_MEDKIT, ...}": {
		"prefix": "WEAPON_MEDKIT",
		"body" : [ "WEAPON_MEDKIT" ],
		"description" : "(18)"
	},
	"enum WeaponIds {..., WEAPON_CROWBAR_ELECTRIC, ...}": {
		"prefix": "WEAPON_CROWBAR_ELECTRIC",
		"body" : [ "WEAPON_CROWBAR_ELECTRIC" ],
		"description" : "(19)"
	},
	"enum WeaponIds {..., WEAPON_PIPEWRENCH, ...}": {
		"prefix": "WEAPON_PIPEWRENCH",
		"body" : [ "WEAPON_PIPEWRENCH" ],
		"description" : "(20)"
	},
	"enum WeaponIds {..., WEAPON_MINIGUN, ...}": {
		"prefix": "WEAPON_MINIGUN",
		"body" : [ "WEAPON_MINIGUN" ],
		"description" : "(21)"
	},
	"enum WeaponIds {..., WEAPON_GRAPPLE, ...}": {
		"prefix": "WEAPON_GRAPPLE",
		"body" : [ "WEAPON_GRAPPLE" ],
		"description" : "(22)"
	},
	"enum WeaponIds {..., WEAPON_SNIPERRIFLE, ...}": {
		"prefix": "WEAPON_SNIPERRIFLE",
		"body" : [ "WEAPON_SNIPERRIFLE" ],
		"description" : "(23)"
	},
	"enum WeaponIds {..., WEAPON_M249, ...}": {
		"prefix": "WEAPON_M249",
		"body" : [ "WEAPON_M249" ],
		"description" : "(24)"
	},
	"enum WeaponIds {..., WEAPON_M16, ...}": {
		"prefix": "WEAPON_M16",
		"body" : [ "WEAPON_M16" ],
		"description" : "(25)"
	},
	"enum WeaponIds {..., WEAPON_SPORELAUNCHER, ...}": {
		"prefix": "WEAPON_SPORELAUNCHER",
		"body" : [ "WEAPON_SPORELAUNCHER" ],
		"description" : "(26)"
	},
	"enum WeaponIds {..., WEAPON_DESERT_EAGLE, ...}": {
		"prefix": "WEAPON_DESERT_EAGLE",
		"body" : [ "WEAPON_DESERT_EAGLE" ],
		"description" : "(27)"
	},
	"enum WeaponIds {..., WEAPON_SHOCKRIFLE, ...}": {
		"prefix": "WEAPON_SHOCKRIFLE",
		"body" : [ "WEAPON_SHOCKRIFLE" ],
		"description" : "(28)"
	},
	"enum WeaponIds {..., WEAPON_DISPLACER, ...}": {
		"prefix": "WEAPON_DISPLACER",
		"body" : [ "WEAPON_DISPLACER" ],
		"description" : "(29)"
	},
	"enum WeaponIds {..., MAX_WEAPONS, ...}": {
		"prefix": "MAX_WEAPONS",
		"body" : [ "MAX_WEAPONS" ],
		"description" : "(256) Maximum number of weapons that the game supports"
	}
}